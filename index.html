<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ONTOHATE V2 ‚Äî 4 Taxonomias (A | B em colunas)</title>

  <!-- D3 -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#f6f7f9;
      --text:#101828;
      --muted:#475467;
      --line:#e4e7ec;
      --shadow: 0 10px 24px rgba(16,24,40,.10);
      --radius: 14px;

      /* cor por taxonomia */
      --t1:#2563eb;
      --t2:#16a34a;
      --t3:#f97316;
      --t4:#a855f7;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    header{
      position: sticky; top:0; z-index: 10;
      background: rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
      padding: 12px 14px;
      display:flex; flex-wrap:wrap;
      gap: 10px 12px;
      align-items:center; justify-content: space-between;
    }
    .brand{display:flex; flex-direction:column; gap:4px; min-width: 280px;}
    .brand h1{margin:0; font-size:14px; font-weight:800;}
    .brand .sub{margin:0; font-size:12px; color:var(--muted); max-width: 820px; line-height: 1.25;}

    .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end;}
    .btn,.file,.input,.select,.pill{
      border:1px solid var(--line);
      background: var(--panel);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1;
      display:inline-flex;
      gap:8px;
      align-items:center;
      box-shadow: 0 1px 0 rgba(16,24,40,.04);
    }
    .btn{cursor:pointer; user-select:none;}
    .btn:hover{filter: brightness(.98);}
    .file input[type="file"]{display:none;}
    .input input, .select select{border:none; outline:none; background:transparent; color:var(--text); font-size: 12px;}
    .input input{width: 220px;}
    .select select{appearance:none;}

    .pill{background:#fff; box-shadow:none;}
    .pill strong{font-weight:700;}
    .dot{width:10px; height:10px; border-radius:999px; display:inline-block; background:var(--t1);
      border: 1px solid rgba(16,24,40,.12);}

    #wrap{
      height: calc(100% - 72px);
      display:grid;
      grid-template-columns: 1fr 380px;
      gap: 14px;
      padding: 14px;
      box-sizing: border-box;
    }
    @media (max-width: 980px){
      #wrap{grid-template-columns: 1fr; height:auto;}
      body{height:auto;}
    }

    .card{
      background:#fff;
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .canvas{min-height: 680px; display:flex; flex-direction:column;}
    .canvasHeader{
      padding: 10px 12px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .canvasHeader .title{display:flex; flex-direction:column; gap:4px;}
    .canvasHeader .title b{font-size:13px;}
    .canvasHeader .title span{font-size:12px; color:var(--muted);}
    .canvasHeader .meta{font-size:12px; color:var(--muted); text-align:right; white-space:nowrap;}
    .canvasBody{flex:1; overflow:hidden;}
    svg{width:100%; height:100%; display:block; background:#fff;}

    .side{padding: 12px; display:flex; flex-direction:column; gap:10px;}
    .side h2{font-size:13px; margin:0;}
    .side p{margin:0; font-size:12px; color:var(--muted); line-height:1.35;}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .sep{height:1px; background: var(--line); margin: 6px 0;}

    /* SVG styles */
    .divider{stroke: rgba(16,24,40,.12); stroke-width: 2;}
    .colLabel{font-size: 12px; fill: var(--muted); font-weight: 700;}
    .link{fill:none; stroke: rgba(16,24,40,.16); stroke-width: 1.2;}
    .node rect{fill:#fff; stroke: rgba(16,24,40,.20); stroke-width: 1; rx:10; ry:10;}
    .node .name{font-size: 12px; fill: var(--text); font-weight: 600;}
    .node .small{font-size: 10px; fill: var(--muted);}
    .node--match rect{stroke-width: 2.2; stroke: rgba(249,115,22,.95);}

    .toast{
      position:fixed; left:14px; bottom:14px; z-index:50;
      background:#fff; border:1px solid var(--line);
      padding:10px 12px; border-radius: 12px;
      box-shadow: var(--shadow);
      font-size:12px; color: var(--muted);
      max-width: min(900px, calc(100% - 28px));
      white-space: pre-wrap;
    }
    .toast.bad{border-color: rgba(255,107,107,.55); color:#7a0b0b;}
  </style>
</head>

<body>
<header>
  <div class="brand">
    <h1>ONTOHATE V2 ‚Äî Taxonomias (A | B em duas colunas)</h1>
    <p class="sub">
      O canvas divide em <b>duas colunas</b>: esquerda = Subontologia A, direita = Subontologia B.
      <b>Todas as classes</b> de A e B entram. Rela√ß√µes Classe‚ÜíSuperclasse s√≥ s√£o mantidas quando a superclasse tamb√©m est√° no mesmo lado (A ou B).
      Se n√£o estiver, a classe vira ‚Äúraiz‚Äù daquele lado (n√£o some).
    </p>
  </div>

  <div class="controls">
    <label class="file btn">
      üìÑ Carregar XLSX
      <input id="fileInput" type="file" accept=".xlsx,.xls" />
    </label>

    <div class="btn" id="btnLoadDefault">‚¨áÔ∏è Carregar Ontohate_V2.xlsx</div>

    <div class="select">
      üß≠
      <select id="taxSelector">
        <option value="1">Taxonomia 1</option>
        <option value="2">Taxonomia 2</option>
        <option value="3">Taxonomia 3</option>
        <option value="4">Taxonomia 4</option>
      </select>
    </div>

    <div class="input">
      üîé <input id="search" placeholder="Buscar classe (nos dois lados)" />
    </div>

    <div class="btn" id="btnFit">‚§¢ Ajustar ao canvas</div>
    <div class="btn" id="btnExpandAll">‚ûï Expandir</div>
    <div class="btn" id="btnCollapseAll">‚ûñ Recolher</div>

    <div class="pill">
      <span class="dot" id="taxDot"></span>
      <span id="stats"><strong>Arquivo:</strong> ‚Äî | <strong>A:</strong> ‚Äî | <strong>B:</strong> ‚Äî</span>
    </div>
  </div>
</header>

<div id="wrap">
  <div class="card canvas">
    <div class="canvasHeader">
      <div class="title">
        <b id="canvasTitle">‚Äî</b>
        <span id="canvasSubtitle">‚Äî</span>
      </div>
      <div class="meta" id="canvasMeta">‚Äî</div>
    </div>
    <div class="canvasBody">
      <svg id="svg"></svg>
    </div>
  </div>

  <div class="card side">
    <h2>Pares de subontologias (1‚Äì4)</h2>
    <p>Se o nome da subontologia na planilha for diferente, selecione A/B e clique <b>Aplicar</b>.</p>

    <div class="row">
      <span class="pill"><span class="dot" id="sideDot"></span><b id="pairLabel">‚Äî</b></span>
    </div>

    <div class="row">
      <span class="select">A:
        <select id="pairA"></select>
      </span>
      <span class="select">B:
        <select id="pairB"></select>
      </span>
      <span class="btn" id="btnApplyPair">Aplicar</span>
    </div>

    <div class="sep"></div>

    <p><b>Sem sobreposi√ß√£o:</b> cada lado tem espa√ßamento pr√≥prio e o texto quebra em linhas.</p>
    <p><b>Cores:</b> a cor da taxonomia contorna os n√≥s; A fica com preenchimento mais claro, B com preenchimento um pouco mais forte.</p>
  </div>
</div>

<div class="toast" id="toast" style="display:none;"></div>

<script>
/* ======= Presets (edite os hints se necess√°rio) ======= */
const TAX_PRESETS = {
  1: { label: "Taxonomia 1", aHint: "naturez", bHint: "manif",   colorVar: "--t1" },
  2: { label: "Taxonomia 2", aHint: "motiv",   bHint: "consequ", colorVar: "--t2" },
  3: { label: "Taxonomia 3", aHint: "context", bHint: "moder",   colorVar: "--t3" },
  4: { label: "Taxonomia 4", aHint: "recurso", bHint: "moder",   colorVar: "--t4" },
};

/* ======= UI ======= */
const svg = d3.select("#svg");
const toastEl = document.getElementById("toast");
const statsEl = document.getElementById("stats");
const fileInput = document.getElementById("fileInput");
const searchEl = document.getElementById("search");
const taxSelector = document.getElementById("taxSelector");
const pairA = document.getElementById("pairA");
const pairB = document.getElementById("pairB");
const pairLabel = document.getElementById("pairLabel");
const btnApplyPair = document.getElementById("btnApplyPair");
const canvasTitle = document.getElementById("canvasTitle");
const canvasSubtitle = document.getElementById("canvasSubtitle");
const canvasMeta = document.getElementById("canvasMeta");
const taxDot = document.getElementById("taxDot");
const sideDot = document.getElementById("sideDot");

function toast(msg, bad=false){
  toastEl.textContent = msg;
  toastEl.classList.toggle("bad", !!bad);
  toastEl.style.display = "block";
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(()=> toastEl.style.display="none", 8500);
}
function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
function setDotColor(varName){
  const c = cssVar(varName);
  taxDot.style.background = c;
  sideDot.style.background = c;
}
function norm(s){
  return String(s||"").trim().toLowerCase().normalize("NFD").replace(/\p{Diacritic}/gu,"");
}
function normalizeKey(k){ return norm(k); }
function pick(row, wanted){
  const keys = Object.keys(row || {});
  const map = new Map(keys.map(k => [normalizeKey(k), k]));
  for (const w of wanted){
    const kk = map.get(normalizeKey(w));
    if (kk != null) return row[kk];
  }
  return undefined;
}
function bestMatch(groups, hint){
  const h = norm(hint);
  if (!groups.length) return "";
  const candidates = groups.filter(g => norm(g).includes(h));
  return candidates.length ? candidates[0] : groups[0];
}
function fillSelect(selectEl, options, selected){
  selectEl.innerHTML = "";
  for (const o of options){
    const opt = document.createElement("option");
    opt.value = o;
    opt.textContent = o;
    if (o === selected) opt.selected = true;
    selectEl.appendChild(opt);
  }
}
function wrapLabel(text, maxChars=30){
  const t = String(text||"");
  if (t.length <= maxChars) return [t];
  const parts = t.split(/[_\s-]+/);
  if (parts.length === 1) return [t.slice(0, maxChars) + "‚Ä¶"];
  const lines = [];
  let cur = "";
  for (const p of parts){
    const next = cur ? (cur + " " + p) : p;
    if (next.length > maxChars){
      if (cur) lines.push(cur);
      cur = p;
    } else cur = next;
    if (lines.length >= 2) break;
  }
  if (cur && lines.length < 2) lines.push(cur);
  const joined = parts.join(" ");
  if (joined.length > lines.join(" ").length) lines[lines.length-1] += "‚Ä¶";
  return lines;
}

/* ======= Zoom ======= */
let viewport = null;
const zoom = d3.zoom()
  .scaleExtent([0.12, 3])
  .on("zoom", (event) => { if (viewport) viewport.attr("transform", event.transform); });

/* ======= State ======= */
let RAW = null;      // {nodes, edges, groups, sheetNames, fileName}
let CURRENT = null;  // {taxId, label, selA, selB, forestA, forestB, counts...}
let rootA = null;
let rootB = null;
let nodeLayerA = null;
let nodeLayerB = null;
let updateFn = null;
let fitToCanvasFn = null;
let expandAllFn = null;
let collapseAllFn = null;

/* ======= Load XLSX ======= */
document.getElementById("btnLoadDefault").addEventListener("click", loadDefault);
fileInput.addEventListener("change", async (ev) => {
  const f = ev.target.files?.[0];
  if (!f) return;
  const buf = await f.arrayBuffer();
  await parseAndInit(buf, f.name);
});
async function loadDefault(){
  const url = "Ontohate_V2.xlsx";
  try{
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error(`N√£o encontrei ${url} (HTTP ${res.status}). Verifique o nome exato no repo.`);
    const buf = await res.arrayBuffer();
    await parseAndInit(buf, url);
  } catch(e){
    toast("Erro ao carregar XLSX:\n" + e.message, true);
  }
}
async function parseAndInit(buf, fileName){
  let wb;
  try{ wb = XLSX.read(buf, { type:"array" }); }
  catch(e){ toast("Falha ao ler o XLSX:\n" + e.message, true); return; }

  const sheetNames = wb.SheetNames || [];
  if (!sheetNames.length){ toast("XLSX sem abas.", true); return; }

  const nodes = new Map(); // name -> {name, group, sheet}
  const edges = [];        // [child, parent]
  const groupSet = new Set();

  function ensureNode(name, group="", sheet=""){
    const n = String(name||"").trim();
    if (!n) return null;
    if (!nodes.has(n)) nodes.set(n, { name:n, group:String(group||"").trim(), sheet:String(sheet||"").trim() });
    else{
      const cur = nodes.get(n);
      if (!cur.group && group) cur.group = String(group).trim();
      if (!cur.sheet && sheet) cur.sheet = String(sheet).trim();
    }
    if (nodes.get(n).group) groupSet.add(nodes.get(n).group);
    return n;
  }

  let usedRows = 0;
  for (const sname of sheetNames){
    const ws = wb.Sheets[sname];
    if (!ws) continue;
    const json = XLSX.utils.sheet_to_json(ws, { defval:"" });

    for (const r of json){
      const child = pick(r, ["Classe", "Class", "classe"]);
      const parent = pick(r, ["Superclasse", "Superclass", "superclasse"]);
      const group  = pick(r, ["Subontologia", "Sub-ontologia", "Subontology", "subontologia"]);

      const c = String(child||"").trim();
      if (!c) continue;
      const p = String(parent||"").trim();
      const g = String(group||"").trim();

      ensureNode(c, g, sname);
      if (p) ensureNode(p, "", "");
      if (p) edges.push([c,p]);
      usedRows++;
    }
  }
  if (!usedRows || nodes.size === 0){ toast("N√£o encontrei a coluna 'Classe' na planilha.", true); return; }

  // dedup edges
  const seen = new Set();
  const edgesUniq = [];
  for (const [c,p] of edges){
    const k = c + "‚Üí" + p;
    if (!seen.has(k)){ seen.add(k); edgesUniq.push([c,p]); }
  }

  const groups = Array.from(groupSet).sort((a,b)=> a.localeCompare(b));
  const GROUP_OPTIONS = ["(Sem subontologia)", ...groups];

  RAW = { nodes, edges: edgesUniq, groups: GROUP_OPTIONS, sheetNames, fileName };

  // init UI
  taxSelector.value = "1";
  syncPairUIFromPreset(1);
  applyTaxonomy();

  toast(`Planilha carregada: ${fileName}\nAbas: ${sheetNames.length}\nClasses totais: ${nodes.size}\nSubontologias: ${groups.length} (+ sem subontologia)`);
}

/* ======= Pair selection ======= */
taxSelector.addEventListener("change", () => {
  if (!RAW) return;
  const id = Number(taxSelector.value);
  syncPairUIFromPreset(id);
  applyTaxonomy();
});
btnApplyPair.addEventListener("click", () => { if (RAW) applyTaxonomy(); });

function syncPairUIFromPreset(taxId){
  const preset = TAX_PRESETS[taxId];
  pairLabel.textContent = preset.label;
  setDotColor(preset.colorVar);

  const options = RAW?.groups || ["(Sem subontologia)"];
  const real = options.filter(g => g !== "(Sem subontologia)");
  const a = bestMatch(real, preset.aHint) || (real[0] || "(Sem subontologia)");
  const b = bestMatch(real, preset.bHint) || (real[1] || real[0] || "(Sem subontologia)");

  fillSelect(pairA, options, a);
  fillSelect(pairB, options, b);
}

/* ======= Build two forests: one for A, one for B ======= */
function applyTaxonomy(){
  if (!RAW) return;

  const taxId = Number(taxSelector.value);
  const preset = TAX_PRESETS[taxId];
  const taxColor = cssVar(preset.colorVar);
  setDotColor(preset.colorVar);

  const selA = pairA.value;
  const selB = pairB.value;

  const inA = new Set();
  const inB = new Set();

  for (const [name, obj] of RAW.nodes.entries()){
    const g = (obj.group || "").trim();
    const gx = g ? g : "(Sem subontologia)";
    if (gx === selA) inA.add(name);
    if (gx === selB) inB.add(name);
  }

  if (inA.size === 0 && inB.size === 0){
    toast(`Nenhuma classe encontrada para A=${selA} e B=${selB}`, true);
    return;
  }

  // helper to build one side (A or B): keep edges only inside that set
  function buildSide(sideSet, sideName){
    const childrenOf = new Map(); // parent -> [child]
    const hasParentInSide = new Set();
    let edgesCount = 0;

    for (const [c,p] of RAW.edges){
      if (!sideSet.has(c)) continue;
      if (!sideSet.has(p)) continue;
      edgesCount++;
      hasParentInSide.add(c);
      if (!childrenOf.has(p)) childrenOf.set(p, []);
      childrenOf.get(p).push(c);
    }
    for (const [p, kids] of childrenOf.entries()){
      kids.sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));
    }

    const roots = [];
    for (const n of sideSet){
      if (!hasParentInSide.has(n)) roots.push(n);
    }
    roots.sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));

    let idCounter = 0;
    function buildSubtree(name, stack=new Set()){
      const base = RAW.nodes.get(name) || { name, group:"", sheet:"" };
      const node = {
        name: base.name,
        group: (base.group || "").trim() || "(Sem subontologia)",
        sheet: base.sheet || "",
        _id: `${sideName}-${++idCounter}`,
        children: []
      };
      if (stack.has(name)) return node;
      stack.add(name);
      const kids = childrenOf.get(name) || [];
      for (const k of kids) node.children.push(buildSubtree(k, new Set(stack)));
      return node;
    }

    const forest = {
      name: sideName,
      group: "Raiz",
      sheet: "",
      _id: `${sideName}-ROOT`,
      children: roots.map(r => buildSubtree(r))
    };
    return { forest, edgesCount, nodesCount: sideSet.size };
  }

  const sideA = buildSide(inA, `A: ${selA}`);
  const sideB = buildSide(inB, `B: ${selB}`);

  CURRENT = {
    taxId, label: preset.label, selA, selB,
    forestA: sideA.forest, forestB: sideB.forest,
    countA: sideA.nodesCount, countB: sideB.nodesCount,
    edgesA: sideA.edgesCount, edgesB: sideB.edgesCount,
    taxColor
  };

  canvasTitle.textContent = `${preset.label}: ${selA}  |  ${selB}`;
  canvasSubtitle.textContent = `Coluna esquerda = A, coluna direita = B`;
  canvasMeta.textContent = `A: ${sideA.nodesCount} classes / ${sideA.edgesCount} rela√ß√µes ‚Ä¢ B: ${sideB.nodesCount} classes / ${sideB.edgesCount} rela√ß√µes`;

  statsEl.innerHTML = `<strong>Arquivo:</strong> ${RAW.fileName} | <strong>A:</strong> ${sideA.nodesCount} classes | <strong>B:</strong> ${sideB.nodesCount} classes`;

  renderTwoColumns(sideA.forest, sideB.forest, taxColor);
}

/* ======= Render two columns (A left, B right) ======= */
document.getElementById("btnFit").addEventListener("click", () => { if (fitToCanvasFn) fitToCanvasFn(true); });
document.getElementById("btnExpandAll").addEventListener("click", () => {
  if (!updateFn || !expandAllFn) return;
  expandAllFn();
  updateFn();
  applySearchHighlight();
  fitToCanvasFn?.(false);
});
document.getElementById("btnCollapseAll").addEventListener("click", () => {
  if (!updateFn || !collapseAllFn) return;
  collapseAllFn();
  updateFn();
  applySearchHighlight();
  fitToCanvasFn?.(false);
});
searchEl.addEventListener("input", () => applySearchHighlight());

function renderTwoColumns(forestA, forestB, taxColor){
  svg.selectAll("*").remove();
  viewport = svg.append("g").attr("id","viewport");
  svg.call(zoom);
  svg.call(zoom.transform, d3.zoomIdentity.translate(18, 18).scale(1));

  const linkLayer = viewport.append("g").attr("id","links");
  const nodeLayer = viewport.append("g").attr("id","nodes");

  // split width
  const svgEl = svg.node();
  const W = svgEl.clientWidth || 1000;
  const H = svgEl.clientHeight || 700;
  const gutter = 70;
  const leftW = Math.max(380, (W - gutter) / 2);
  const rightW = Math.max(380, (W - gutter) / 2);
  const leftX0 = 0;
  const rightX0 = leftW + gutter;

  // divider + labels (fixed in viewport coords)
  const headerG = viewport.append("g").attr("id","colHeader");
  headerG.append("line").attr("class","divider")
    .attr("x1", leftW + gutter/2).attr("x2", leftW + gutter/2)
    .attr("y1", 0).attr("y2", Math.max(H, 900));

  headerG.append("text").attr("class","colLabel")
    .attr("x", leftX0 + 10).attr("y", 18).text(forestA.name);
  headerG.append("text").attr("class","colLabel")
    .attr("x", rightX0 + 10).attr("y", 18).text(forestB.name);

  // Build trees with different origins
  const dx = 56;
  const dy = 320;
  const tree = d3.tree().nodeSize([dx, dy]);

  rootA = d3.hierarchy(forestA);
  rootB = d3.hierarchy(forestB);

  // collapse deeper initially
  collapseDeep(rootA);
  collapseDeep(rootB);

  function collapseDeep(r){
    r.children?.forEach(c => c.children?.forEach(cc => collapse(cc)));
  }
  function collapse(d){
    if (d.children){
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  // Expand/collapse all across both trees
  expandAllFn = () => { expandAll(rootA); expandAll(rootB); };
  collapseAllFn = () => { collapseAll(rootA); collapseAll(rootB); };

  function expandAll(d){
    if (d._children){ d.children = d._children; d._children = null; }
    (d.children||[]).forEach(expandAll);
  }
  function collapseAll(d){
    (d.children||[]).forEach(collapseAll);
    if (d.depth >= 2) collapse(d);
  }

  function diagonal(d){ return d3.linkHorizontal().x(d=>d.y).y(d=>d.x)(d); }

  function nodeFill(isB){
    // A mais claro, B um pouco mais marcado
    return isB ? "rgba(0,0,0,.03)" : "rgba(0,0,0,.015)";
  }

  function layoutAndGet(nodeRoot, xOffset){
    tree(nodeRoot);
    const nodes = nodeRoot.descendants();
    const links = nodeRoot.links();
    // shift to start after header area
    for (const n of nodes){
      n.y = xOffset + n.y + 10;
      n.x = n.x + 40;
    }
    // also shift link coordinates because based on nodes
    return { nodes, links };
  }

  // draw/update
  updateFn = () => {
    const A = layoutAndGet(rootA, leftX0);
    const B = layoutAndGet(rootB, rightX0);

    const allNodes = [...A.nodes.map(d=>({d, side:"A"})), ...B.nodes.map(d=>({d, side:"B"}))];
    const allLinks = [
      ...A.links.map(l=>({l, side:"A"})),
      ...B.links.map(l=>({l, side:"B"}))
    ];

    // LINKS
    const linkSel = linkLayer.selectAll("path.link")
      .data(allLinks, x => x.l.target.data._id);

    linkSel.enter().append("path")
      .attr("class","link")
      .attr("d", x => {
        const o = {x: x.l.source.x, y: x.l.source.y};
        return diagonal({source:o, target:o});
      })
      .merge(linkSel)
      .transition().duration(240)
      .attr("d", x => diagonal(x.l));

    linkSel.exit().transition().duration(200).attr("opacity",0).remove();

    // NODES
    const nodeSel = nodeLayer.selectAll("g.node")
      .data(allNodes, x => x.d.data._id);

    const nodeEnter = nodeSel.enter().append("g")
      .attr("class","node")
      .attr("transform", x => `translate(${x.d.y},${x.d.x})`)
      .on("click", (_, x) => {
        const d = x.d;
        if (d.children){ d._children = d.children; d.children = null; }
        else { d.children = d._children; d._children = null; }
        updateFn();
        applySearchHighlight();
      });

    nodeEnter.each(function(x){
      const d = x.d;
      const isB = (x.side === "B");
      const g = d3.select(this);
      const lines = wrapLabel(d.data.name, 30);
      const hasKids = (d.children || d._children);

      const w = 360;
      const h = lines.length === 1 ? 46 : 60;

      g.append("rect")
        .attr("x", 0).attr("y", -h/2)
        .attr("width", w).attr("height", h)
        .attr("fill", nodeFill(isB))
        .attr("stroke", taxColor)
        .attr("stroke-width", d.data.group === "Raiz" ? 2.6 : 1.8);

      const t = g.append("text").attr("class","name").attr("x", 12).attr("y", -6);
      if (lines.length === 1){
        t.attr("y",-2).text(lines[0]);
      } else {
        t.append("tspan").attr("x",12).attr("dy",0).text(lines[0]);
        t.append("tspan").attr("x",12).attr("dy",14).text(lines[1]);
      }

      g.append("text")
        .attr("class","small")
        .attr("x", 12).attr("y", h/2 - 10)
        .text(`Subontologia: ${d.data.group}`);

      g.append("text")
        .attr("class","small")
        .attr("x", w - 10).attr("y", -2)
        .attr("text-anchor","end")
        .text(hasKids ? (d.children ? "‚ñæ" : "‚ñ∏") : "");
    });

    nodeSel.merge(nodeEnter)
      .transition().duration(240)
      .attr("transform", x => `translate(${x.d.y},${x.d.x})`);

    nodeSel.exit().transition().duration(200).attr("opacity",0).remove();
  };

  updateFn();

  // Fit to canvas: consider both columns bounds
  fitToCanvasFn = (strong=true) => {
    if (!viewport) return;
    const bounds = viewport.node().getBBox();
    const svgEl2 = svg.node();
    const w = svgEl2.clientWidth || 800;
    const h = svgEl2.clientHeight || 600;
    const pad = 40;

    const bw = bounds.width + pad*2;
    const bh = bounds.height + pad*2;
    const scale = Math.min(2.4, Math.max(0.12, Math.min(w/bw, h/bh)));

    const tx = (w - bounds.width*scale)/2 - bounds.x*scale;
    const ty = (h - bounds.height*scale)/2 - bounds.y*scale;

    const t = d3.zoomIdentity.translate(tx, ty).scale(scale);
    svg.transition().duration(strong ? 380 : 220).call(zoom.transform, t);
  };

  fitToCanvasFn(true);
  applySearchHighlight();
}

/* ======= Search highlight in both columns ======= */
function applySearchHighlight(){
  const q = norm(searchEl.value);
  svg.selectAll("g.node").classed("node--match", false);
  if (!q) return;

  svg.selectAll("g.node").each(function(x){
    // x is bound datum: {d, side} or undefined during transitions. Guard:
    const datum = d3.select(this).datum();
    if (!datum || !datum.d) return;
    if (norm(datum.d.data.name).includes(q)){
      d3.select(this).classed("node--match", true);
    }
  });
}

/* ======= Auto-load ======= */
(async function(){
  try{ await loadDefault(); } catch(_) {}
})();
</script>
</body>
</html>

