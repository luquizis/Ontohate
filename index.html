<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ONTOHATE V2 ‚Äî Taxonomias (2‚Äì4) Top-Down + Raiz + Export</title>

  <!-- D3 -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#f6f7f9;
      --text:#101828;
      --muted:#475467;
      --line:#e4e7ec;
      --shadow: 0 10px 24px rgba(16,24,40,.10);
      --radius: 14px;

      /* Paleta fixa por taxonomia */
      --t1:#2563eb; /* azul */
      --t2:#16a34a; /* verde */
      --t3:#f97316; /* laranja */
      --t4:#a855f7; /* roxo */
    }

    html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: Arial, Helvetica, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
    header{
      position: sticky; top:0; z-index: 10;
      background: rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
      padding: 12px 14px;
      display:flex; flex-wrap:wrap;
      gap: 10px 12px;
      align-items:center; justify-content: space-between;
    }
    .brand{display:flex; flex-direction:column; gap:4px; min-width: 280px;}
    .brand h1{margin:0; font-size:14px; font-weight:800;}
    .brand .sub{margin:0; font-size:12px; color:var(--muted); max-width: 980px; line-height: 1.25;}

    .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end;}
    .btn,.file,.input,.select,.pill{
      border:1px solid var(--line);
      background: var(--panel);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1;
      display:inline-flex;
      gap:8px;
      align-items:center;
      box-shadow: 0 1px 0 rgba(16,24,40,.04);
    }
    .btn{cursor:pointer; user-select:none;}
    .btn:hover{filter: brightness(.98);}
    .file input[type="file"]{display:none;}
    .input input, .select select{
      border:none; outline:none; background:transparent; color:var(--text); font-size: 12px;
      font-family: Arial, Helvetica, sans-serif;
    }
    .input input{width: 220px;}
    .select select{appearance:none;}

    .pill{background:#fff; box-shadow:none;}
    .pill strong{font-weight:700;}
    .dot{width:10px; height:10px; border-radius:999px; display:inline-block; background:var(--t1);
      border: 1px solid rgba(16,24,40,.12);}

    #wrap{
      height: calc(100% - 72px);
      display:grid;
      grid-template-columns: 1fr 460px;
      gap: 14px;
      padding: 14px;
      box-sizing: border-box;
    }
    @media (max-width: 1100px){
      #wrap{grid-template-columns: 1fr; height:auto;}
      body{height:auto;}
    }

    .card{
      background:#fff;
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .canvas{min-height: 740px; display:flex; flex-direction:column;}
    .canvasHeader{
      padding: 10px 12px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .canvasHeader .title{display:flex; flex-direction:column; gap:4px;}
    .canvasHeader .title b{font-size:13px;}
    .canvasHeader .title span{font-size:12px; color:var(--muted);}
    .canvasHeader .meta{font-size:12px; color:var(--muted); text-align:right; white-space:nowrap;}
    .canvasBody{flex:1; overflow:hidden;}
    svg{width:100%; height:100%; display:block; background:#fff;}

    .side{padding: 12px; display:flex; flex-direction:column; gap:10px;}
    .side h2{font-size:13px; margin:0;}
    .side p{margin:0; font-size:12px; color:var(--muted); line-height:1.35;}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .sep{height:1px; background: var(--line); margin: 6px 0;}
    .mini{font-size:11px;color:var(--muted)}
    .chk{display:flex; align-items:center; gap:8px; border:1px solid var(--line); background:#fff; border-radius: 12px; padding: 8px 10px; font-size:12px;}
    .chk input{accent-color:#111827}

    /* SVG styles (render + export) */
    .link{
      fill:none;
      stroke: rgba(16,24,40,.18);
      stroke-width: 1.25;
      stroke-linecap: round;
      stroke-linejoin: round;
      vector-effect: non-scaling-stroke; /* evita ‚Äúdesconfigurar‚Äù ao exportar/zoom */
    }
    .node rect{
      stroke: rgba(16,24,40,.18);
      stroke-width: 1.2;
      rx:10; ry:10;
      shape-rendering: geometricPrecision;
    }
    .node .name{
      font-size: 12px;
      font-weight: 700; /* negrito */
      font-family: Arial, Helvetica, sans-serif; /* for√ßa Arial */
      text-rendering: geometricPrecision;
    }
    .node .small{
      font-size: 10px;
      font-weight: 700;
      font-family: Arial, Helvetica, sans-serif;
      opacity:.95;
    }
    .node--match rect{
      stroke-width: 2.4;
      stroke: rgba(249,115,22,.95);
    }

    /* Tooltip */
    .tooltip{
      position: fixed;
      z-index: 9999;
      display: none;
      max-width: 560px;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 10px 12px;
      font-size: 12px;
      color: var(--text);
      pointer-events: none;
      white-space: pre-wrap;
      font-family: Arial, Helvetica, sans-serif;
    }
    .tooltip .tTitle{font-weight: 800; margin-bottom: 6px;}
    .tooltip .tMeta{color: var(--muted); margin-bottom: 8px; font-weight: 700;}
    .tooltip .tSection{margin-top: 8px;}
    .tooltip .tSection b{display:block; margin-bottom: 4px;}
    .tooltip .tEmpty{color: var(--muted); font-style: italic;}

    .toast{
      position:fixed; left:14px; bottom:14px; z-index:50;
      background:#fff; border:1px solid var(--line);
      padding:10px 12px; border-radius: 12px;
      box-shadow: var(--shadow);
      font-size:12px; color: var(--muted);
      max-width: min(980px, calc(100% - 28px));
      white-space: pre-wrap;
      font-family: Arial, Helvetica, sans-serif;
    }
    .toast.bad{border-color: rgba(255,107,107,.55); color:#7a0b0b;}
  </style>
</head>

<body>
<header>
  <div class="brand">
    <h1>ONTOHATE V2 ‚Äî Taxonomias (2‚Äì4) ‚Ä¢ Top-Down por raiz ‚Ä¢ Export</h1>
    <p class="sub">
      Selecione 2‚Äì4 taxonomias. A visualiza√ß√£o vira um <b>√∫nico grafo</b> (sem divis√£o em colunas) e os cruzamentos aparecem naturalmente.
      Escolha uma <b>raiz</b> e a hierarquia ser√° <b>apenas raiz + descendentes</b> (superclasses acima s√£o exclu√≠das).
    </p>
  </div>

  <div class="controls">
    <label class="file btn">
      üìÑ Carregar XLSX
      <input id="fileInput" type="file" accept=".xlsx,.xls" />
    </label>

    <div class="btn" id="btnLoadDefault">‚¨áÔ∏è Carregar Ontohate_V2.xlsx</div>

    <div class="input">
      üîé <input id="search" placeholder="Buscar classe" />
    </div>

    <div class="btn" id="btnFit">‚§¢ Ajustar</div>
    <div class="btn" id="btnExpandAll">‚ûï Expandir</div>
    <div class="btn" id="btnCollapseAll">‚ûñ Recolher</div>

    <div class="btn" id="btnSvg">‚¨áÔ∏é SVG</div>
    <div class="select" title="PNG em alta resolu√ß√£o">
      PNG
      <select id="pngScale">
        <option value="3">3√ó</option>
        <option value="4">4√ó</option>
      </select>
    </div>
    <div class="btn" id="btnPng">‚¨áÔ∏é PNG</div>

    <div class="pill">
      <span class="dot" id="taxDot"></span>
      <span id="stats"><strong>Arquivo:</strong> ‚Äî | <strong>Recorte:</strong> ‚Äî</span>
    </div>
  </div>
</header>

<div id="wrap">
  <div class="card canvas">
    <div class="canvasHeader">
      <div class="title">
        <b id="canvasTitle">‚Äî</b>
        <span id="canvasSubtitle">‚Äî</span>
      </div>
      <div class="meta" id="canvasMeta">‚Äî</div>
    </div>
    <div class="canvasBody">
      <svg id="svg"></svg>
    </div>
  </div>

  <div class="card side">
    <h2>Taxonomias ativas (2‚Äì4)</h2>
    <p class="mini">Marque quais taxonomias entram no recorte. Cada taxonomia representa <b>duas subontologias</b> (A e B).</p>

    <div class="row">
      <label class="chk"><input type="checkbox" id="tax1" checked> <span class="dot" style="background:var(--t1)"></span> Taxonomia 1</label>
      <label class="chk"><input type="checkbox" id="tax2" checked> <span class="dot" style="background:var(--t2)"></span> Taxonomia 2</label>
      <label class="chk"><input type="checkbox" id="tax3"> <span class="dot" style="background:var(--t3)"></span> Taxonomia 3</label>
      <label class="chk"><input type="checkbox" id="tax4"> <span class="dot" style="background:var(--t4)"></span> Taxonomia 4</label>
    </div>

    <div class="sep"></div>

    <h2>Pares de subontologias (por taxonomia)</h2>
    <p class="mini">A subontologia √© <b>padronizada</b> (ex.: remove ‚Äú(v2)‚Äù e duplicidades). Ajuste os pares se necess√°rio.</p>

    <div class="row">
      <span class="select">T1 A: <select id="t1a"></select></span>
      <span class="select">T1 B: <select id="t1b"></select></span>
    </div>
    <div class="row">
      <span class="select">T2 A: <select id="t2a"></select></span>
      <span class="select">T2 B: <select id="t2b"></select></span>
    </div>
    <div class="row">
      <span class="select">T3 A: <select id="t3a"></select></span>
      <span class="select">T3 B: <select id="t3b"></select></span>
    </div>
    <div class="row">
      <span class="select">T4 A: <select id="t4a"></select></span>
      <span class="select">T4 B: <select id="t4b"></select></span>
    </div>

    <div class="row">
      <span class="btn" id="btnApply">Aplicar recorte</span>
    </div>

    <div class="sep"></div>

    <h2>Raiz Top-Down</h2>
    <p class="mini">A raiz escolhida fica sempre no topo. O gr√°fico mostra <b>apenas a raiz e os descendentes</b> (superclasses acima s√£o exclu√≠das).</p>

    <div class="row">
      <span class="select">Raiz:
        <select id="rootSelect"></select>
      </span>
      <span class="btn" id="btnApplyRoot">Aplicar raiz</span>
    </div>

    <div class="sep"></div>

    <p class="mini"><b>Tooltip:</b> hover mostra comments/observa√ß√µes do XLSX.</p>
  </div>
</div>

<div class="tooltip" id="tooltip"></div>
<div class="toast" id="toast" style="display:none;"></div>

<script>
/* ============================
   1) Paleta e presets
============================ */
const TAX = {
  1: { label:"Taxonomia 1", colorVar:"--t1", aHint:"naturez", bHint:"manif" },
  2: { label:"Taxonomia 2", colorVar:"--t2", aHint:"motiv",   bHint:"consequ" },
  3: { label:"Taxonomia 3", colorVar:"--t3", aHint:"context", bHint:"moder" },
  4: { label:"Taxonomia 4", colorVar:"--t4", aHint:"recurso", bHint:"moder" },
};

/* ============================
   2) UI refs
============================ */
const svg = d3.select("#svg");
let viewport = null;

const toastEl = document.getElementById("toast");
const tooltipEl = document.getElementById("tooltip");

const fileInput = document.getElementById("fileInput");
const btnLoadDefault = document.getElementById("btnLoadDefault");
const btnFit = document.getElementById("btnFit");
const btnExpandAll = document.getElementById("btnExpandAll");
const btnCollapseAll = document.getElementById("btnCollapseAll");
const btnSvg = document.getElementById("btnSvg");
const btnPng = document.getElementById("btnPng");
const pngScaleSel = document.getElementById("pngScale");

const searchEl = document.getElementById("search");
const statsEl = document.getElementById("stats");
const taxDot = document.getElementById("taxDot");

const canvasTitle = document.getElementById("canvasTitle");
const canvasSubtitle = document.getElementById("canvasSubtitle");
const canvasMeta = document.getElementById("canvasMeta");

const tax1 = document.getElementById("tax1");
const tax2 = document.getElementById("tax2");
const tax3 = document.getElementById("tax3");
const tax4 = document.getElementById("tax4");

const t1a = document.getElementById("t1a"), t1b = document.getElementById("t1b");
const t2a = document.getElementById("t2a"), t2b = document.getElementById("t2b");
const t3a = document.getElementById("t3a"), t3b = document.getElementById("t3b");
const t4a = document.getElementById("t4a"), t4b = document.getElementById("t4b");

const btnApply = document.getElementById("btnApply");
const rootSelect = document.getElementById("rootSelect");
const btnApplyRoot = document.getElementById("btnApplyRoot");

/* ============================
   3) Helpers
============================ */
function toast(msg, bad=false){
  toastEl.textContent = msg;
  toastEl.classList.toggle("bad", !!bad);
  toastEl.style.display = "block";
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(()=> toastEl.style.display="none", 9000);
}
function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
function setTaxDotToMixed(){
  // apenas um ‚Äúindicador‚Äù, escolhe a primeira taxonomia ativa
  const first = getActiveTaxIds()[0] || 1;
  taxDot.style.background = cssVar(TAX[first].colorVar);
}
function norm(s){
  return String(s||"").trim().toLowerCase().normalize("NFD").replace(/\p{Diacritic}/gu,"");
}
function normalizeKey(k){ return norm(k); }
function pick(row, wanted){
  const keys = Object.keys(row || {});
  const map = new Map(keys.map(k => [normalizeKey(k), k]));
  for (const w of wanted){
    const kk = map.get(normalizeKey(w));
    if (kk != null) return row[kk];
  }
  return undefined;
}
function wrapLabel(text, maxChars=28){
  const t = String(text||"");
  if (t.length <= maxChars) return [t];
  const parts = t.split(/[_\s-]+/);
  if (parts.length === 1) return [t.slice(0, maxChars) + "‚Ä¶"];
  const lines = [];
  let cur = "";
  for (const p of parts){
    const next = cur ? (cur + " " + p) : p;
    if (next.length > maxChars){
      if (cur) lines.push(cur);
      cur = p;
    } else cur = next;
    if (lines.length >= 2) break;
  }
  if (cur && lines.length < 2) lines.push(cur);
  const joined = parts.join(" ");
  if (joined.length > lines.join(" ").length) lines[lines.length-1] += "‚Ä¶";
  return lines;
}
function fillSelect(sel, options, selected){
  sel.innerHTML = "";
  for (const o of options){
    const opt = document.createElement("option");
    opt.value = o;
    opt.textContent = o;
    if (o === selected) opt.selected = true;
    sel.appendChild(opt);
  }
}
function bestMatch(groups, hint){
  const h = norm(hint);
  if (!groups.length) return "";
  const c = groups.filter(g => norm(g).includes(h));
  return c.length ? c[0] : groups[0];
}

/* ===== padroniza√ß√£o de subontologia =====
   - remove "(v2)" e varia√ß√µes
   - remove espa√ßos duplicados
   - trim
*/
function canonSubontology(name){
  let s = String(name||"").trim();
  if (!s) return "";
  // remove qualquer "(v2)" no final (ou no meio) e varia√ß√µes de espa√ßo
  s = s.replace(/\(\s*v2\s*\)/ig, "").trim();
  s = s.replace(/\bv2\b/ig, "").trim(); // caso algu√©m tenha "Subontologia v2"
  s = s.replace(/\s+/g, " ").trim();
  return s;
}

/* ============================
   4) Tooltip
============================ */
function escapeHtml(s){
  return String(s||"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function showTooltip(evt, payload){
  const pad = 14;
  const vw = window.innerWidth, vh = window.innerHeight;

  tooltipEl.innerHTML = `
    <div class="tTitle">${escapeHtml(payload.name || "")}</div>
    <div class="tMeta">${escapeHtml(payload.group || "")}</div>
    <div class="tSection">
      <b>Comments</b>
      <div>${payload.comment ? escapeHtml(payload.comment) : '<span class="tEmpty">(sem comments)</span>'}</div>
    </div>
    <div class="tSection">
      <b>Observa√ß√µes</b>
      <div>${payload.obs ? escapeHtml(payload.obs) : '<span class="tEmpty">(sem observa√ß√µes)</span>'}</div>
    </div>
  `;
  tooltipEl.style.display = "block";

  const rect = tooltipEl.getBoundingClientRect();
  let x = evt.clientX + 14;
  let y = evt.clientY + 14;
  if (x + rect.width + pad > vw) x = evt.clientX - rect.width - 14;
  if (y + rect.height + pad > vh) y = evt.clientY - rect.height - 14;
  x = Math.max(pad, x);
  y = Math.max(pad, y);
  tooltipEl.style.left = x + "px";
  tooltipEl.style.top = y + "px";
}
function moveTooltip(evt){
  if (tooltipEl.style.display !== "block") return;
  const pad = 14;
  const vw = window.innerWidth, vh = window.innerHeight;
  const rect = tooltipEl.getBoundingClientRect();
  let x = evt.clientX + 14;
  let y = evt.clientY + 14;
  if (x + rect.width + pad > vw) x = evt.clientX - rect.width - 14;
  if (y + rect.height + pad > vh) y = evt.clientY - rect.height - 14;
  x = Math.max(pad, x);
  y = Math.max(pad, y);
  tooltipEl.style.left = x + "px";
  tooltipEl.style.top = y + "px";
}
function hideTooltip(){ tooltipEl.style.display = "none"; tooltipEl.innerHTML = ""; }

/* ============================
   5) Color/contrast helpers
============================ */
function hexToRgb(hex){
  const h = hex.replace("#","").trim();
  if (h.length !== 6) return {r:0,g:0,b:0};
  return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
}
function rgbToHex(r,g,b){
  const to = (n)=> n.toString(16).padStart(2,"0");
  return `#${to(r)}${to(g)}${to(b)}`;
}
function mix(hexA, hexB, t){
  const a = hexToRgb(hexA), b = hexToRgb(hexB);
  const r = Math.round(a.r*(1-t) + b.r*t);
  const g = Math.round(a.g*(1-t) + b.g*t);
  const bb = Math.round(a.b*(1-t) + b.b*t);
  return rgbToHex(r,g,bb);
}
function luminance(hex){
  const {r,g,b} = hexToRgb(hex);
  const srgb = [r,g,b].map(v=>{
    const c = v/255;
    return (c<=0.03928)? c/12.92 : Math.pow((c+0.055)/1.055, 2.4);
  });
  return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
}
function contrastText(bgHex){ return luminance(bgHex) > 0.55 ? "#101828" : "#ffffff"; }

/* ============================
   6) Zoom
============================ */
const zoom = d3.zoom()
  .scaleExtent([0.10, 3.5])
  .on("zoom", (event) => { if (viewport) viewport.attr("transform", event.transform); });

/* ============================
   7) State
============================ */
let RAW = null; // { nodes: Map(name -> {name, groupCanon, groupRaw, comment, obs}), edges: [[child,parent]], subontologiesCanon: [..] }
let VIEW = null; // { includedNodes, root, treeRootHierarchy, counts, activeTaxIds, activeSubontologies, colorOfSubontology }

/* ============================
   8) XLSX load
============================ */
btnLoadDefault.addEventListener("click", loadDefault);
fileInput.addEventListener("change", async (ev) => {
  const f = ev.target.files?.[0];
  if (!f) return;
  const buf = await f.arrayBuffer();
  await parseAndInit(buf, f.name);
});

async function loadDefault(){
  const url = "Ontohate_V2.xlsx";
  try{
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error(`N√£o encontrei ${url} (HTTP ${res.status}). Verifique o nome exato no repo.`);
    const buf = await res.arrayBuffer();
    await parseAndInit(buf, url);
  } catch(e){
    toast("Erro ao carregar XLSX:\n" + e.message, true);
  }
}

async function parseAndInit(buf, fileName){
  let wb;
  try{ wb = XLSX.read(buf, { type:"array" }); }
  catch(e){ toast("Falha ao ler o XLSX:\n" + e.message, true); return; }

  const sheetNames = wb.SheetNames || [];
  if (!sheetNames.length){ toast("XLSX sem abas.", true); return; }

  const nodes = new Map(); // name -> obj
  const edges = [];
  const suboCanonSet = new Set();

  function ensureNode(name, groupRaw="", comment="", obs=""){
    const n = String(name||"").trim();
    if (!n) return null;

    const gRaw = String(groupRaw||"").trim();
    const gCanon = canonSubontology(gRaw || "");

    if (!nodes.has(n)){
      nodes.set(n, {
        name: n,
        groupRaw: gRaw,
        groupCanon: gCanon || "(Sem subontologia)",
        comment: String(comment||"").trim(),
        obs: String(obs||"").trim(),
      });
    } else {
      const cur = nodes.get(n);
      if ((!cur.groupRaw || cur.groupRaw==="") && gRaw) cur.groupRaw = gRaw;
      if ((!cur.groupCanon || cur.groupCanon==="(Sem subontologia)") && gCanon) cur.groupCanon = gCanon;
      const cmt = String(comment||"").trim();
      const ob  = String(obs||"").trim();
      if (cmt && !cur.comment) cur.comment = cmt;
      if (ob  && !cur.obs) cur.obs = ob;
    }

    if (gCanon) suboCanonSet.add(gCanon);
    return n;
  }

  let usedRows = 0;
  for (const sname of sheetNames){
    const ws = wb.Sheets[sname];
    if (!ws) continue;
    const json = XLSX.utils.sheet_to_json(ws, { defval:"" });

    for (const r of json){
      const child = pick(r, ["Classe", "Class", "classe"]);
      const parent = pick(r, ["Superclasse", "Superclass", "superclasse"]);
      const group  = pick(r, ["Subontologia", "Sub-ontologia", "Subontology", "subontologia"]);

      const comment = pick(r, ["Comment", "Comments", "comment", "comments", "rdfs:comment", "RDFS:comment", "Anota√ß√£o", "Anotacao", "anotacao", "anota√ß√£o"]);
      const obs     = pick(r, ["Observa√ß√£o", "Observacao", "observacao", "observa√ß√£o", "Observa√ß√µes", "Observacoes", "observacoes", "notes", "Notes", "nota", "notas"]);

      const c = String(child||"").trim();
      if (!c) continue;

      const p = String(parent||"").trim();
      const g = String(group||"").trim();

      ensureNode(c, g, comment, obs);
      if (p) ensureNode(p, "", "", "");
      if (p) edges.push([c,p]);
      usedRows++;
    }
  }

  if (!usedRows || nodes.size === 0){
    toast("N√£o encontrei a coluna 'Classe' na planilha.", true);
    return;
  }

  // Dedup edges
  const seen = new Set();
  const edgesUniq = [];
  for (const [c,p] of edges){
    const k = c + "‚Üí" + p;
    if (!seen.has(k)){ seen.add(k); edgesUniq.push([c,p]); }
  }

  const subontologiesCanon = Array.from(suboCanonSet).sort((a,b)=>a.localeCompare(b));

  RAW = { nodes, edges: edgesUniq, subontologiesCanon, fileName };

  // init selects (subontologias can√¥nicas)
  initTaxonomySelectors();

  // default pairs by hint
  autoPickPairsByHint();

  // root list (filled after apply)
  applyAll();
  toast(`Planilha carregada: ${fileName}\nClasses totais: ${nodes.size}\nSubontologias (padronizadas): ${subontologiesCanon.length}`);
}

/* ============================
   9) Tax selectors / active selection
============================ */
function initTaxonomySelectors(){
  const options = ["(Sem subontologia)", ...RAW.subontologiesCanon];
  fillSelect(t1a, options, options[1] || "(Sem subontologia)");
  fillSelect(t1b, options, options[2] || options[1] || "(Sem subontologia)");
  fillSelect(t2a, options, options[1] || "(Sem subontologia)");
  fillSelect(t2b, options, options[2] || options[1] || "(Sem subontologia)");
  fillSelect(t3a, options, options[1] || "(Sem subontologia)");
  fillSelect(t3b, options, options[2] || options[1] || "(Sem subontologia)");
  fillSelect(t4a, options, options[1] || "(Sem subontologia)");
  fillSelect(t4b, options, options[2] || options[1] || "(Sem subontologia)");
}

function autoPickPairsByHint(){
  const real = RAW.subontologiesCanon;
  t1a.value = bestMatch(real, TAX[1].aHint) || (real[0]||"(Sem subontologia)");
  t1b.value = bestMatch(real, TAX[1].bHint) || (real[1]||real[0]||"(Sem subontologia)");
  t2a.value = bestMatch(real, TAX[2].aHint) || (real[0]||"(Sem subontologia)");
  t2b.value = bestMatch(real, TAX[2].bHint) || (real[1]||real[0]||"(Sem subontologia)");
  t3a.value = bestMatch(real, TAX[3].aHint) || (real[0]||"(Sem subontologia)");
  t3b.value = bestMatch(real, TAX[3].bHint) || (real[1]||real[0]||"(Sem subontologia)");
  t4a.value = bestMatch(real, TAX[4].aHint) || (real[0]||"(Sem subontologia)");
  t4b.value = bestMatch(real, TAX[4].bHint) || (real[1]||real[0]||"(Sem subontologia)");
}

function getActiveTaxIds(){
  const ids = [];
  if (tax1.checked) ids.push(1);
  if (tax2.checked) ids.push(2);
  if (tax3.checked) ids.push(3);
  if (tax4.checked) ids.push(4);
  return ids;
}

function getPairsByTaxId(id){
  if (id===1) return [t1a.value, t1b.value];
  if (id===2) return [t2a.value, t2b.value];
  if (id===3) return [t3a.value, t3b.value];
  if (id===4) return [t4a.value, t4b.value];
  return [];
}

function applyAll(){
  if (!RAW) return;
  setTaxDotToMixed();
  applyRecorteAndRoot();
}

btnApply.addEventListener("click", applyAll);
btnApplyRoot.addEventListener("click", applyAll);
tax1.addEventListener("change", applyAll);
tax2.addEventListener("change", applyAll);
tax3.addEventListener("change", applyAll);
tax4.addEventListener("change", applyAll);

/* ============================
   10) Recorte (2‚Äì4 taxonomias) + raiz top-down (descendentes)
============================ */
function applyRecorteAndRoot(){
  const activeTaxIds = getActiveTaxIds();
  if (activeTaxIds.length < 2){
    toast("Selecione pelo menos 2 taxonomias.", true);
    return;
  }

  // subontologias ativas = uni√£o de A/B das taxonomias marcadas
  const activeSubontologies = new Set();
  for (const id of activeTaxIds){
    const [a,b] = getPairsByTaxId(id);
    if (a) activeSubontologies.add(a);
    if (b) activeSubontologies.add(b);
  }

  // map: subontologia -> cor (pega a primeira taxonomia ativa que cont√©m essa subontologia)
  const colorOfSubontology = new Map();
  for (const id of activeTaxIds){
    const col = cssVar(TAX[id].colorVar);
    const [a,b] = getPairsByTaxId(id);
    for (const s of [a,b]){
      if (!s) continue;
      if (!colorOfSubontology.has(s)) colorOfSubontology.set(s, col);
    }
  }

  // included nodes: qualquer classe cuja subontologia can√¥nica esteja no conjunto ativo
  const includedNodes = new Set();
  for (const [name, obj] of RAW.nodes.entries()){
    const g = obj.groupCanon || "(Sem subontologia)";
    if (activeSubontologies.has(g)) includedNodes.add(name);
  }

  if (includedNodes.size === 0){
    toast("Nenhuma classe encontrada para o recorte selecionado.", true);
    return;
  }

  // adjacency (top-down): parent -> children, apenas com n√≥s inclu√≠dos
  const childrenOf = new Map();
  const parentOf = new Map(); // child -> parent (para caso de m√∫ltiplos, mantemos o primeiro)
  for (const [child, parent] of RAW.edges){
    if (!includedNodes.has(child) || !includedNodes.has(parent)) continue;
    if (!childrenOf.has(parent)) childrenOf.set(parent, []);
    childrenOf.get(parent).push(child);
    if (!parentOf.has(child)) parentOf.set(child, parent);
  }
  for (const [p, kids] of childrenOf.entries()){
    kids.sort((a,b)=>a.localeCompare(b));
  }

  // Root options: apenas n√≥s inclu√≠dos (para garantir raiz v√°lida)
  const rootOptions = ["(Escolha uma raiz)", ...Array.from(includedNodes).sort((a,b)=>a.localeCompare(b))];
  const prevRoot = rootSelect.value || "(Escolha uma raiz)";
  fillSelect(rootSelect, rootOptions, rootOptions.includes(prevRoot) ? prevRoot : "(Escolha uma raiz)");

  const chosenRoot = rootSelect.value;
  if (!chosenRoot || chosenRoot === "(Escolha uma raiz)"){
    // for√ßa escolher raiz (porque a regra 3 depende disso)
    canvasTitle.textContent = "Escolha uma raiz para gerar a taxonomia Top-Down";
    canvasSubtitle.textContent = `Taxonomias ativas: ${activeTaxIds.join(", ")} ‚Ä¢ Subontologias: ${Array.from(activeSubontologies).join(" | ")}`;
    canvasMeta.textContent = `Classes no recorte: ${includedNodes.size} ‚Ä¢ Rela√ß√µes no recorte: ${countEdgesInSet(childrenOf)}`;
    statsEl.innerHTML = `<strong>Arquivo:</strong> ${RAW.fileName} | <strong>Recorte:</strong> ${includedNodes.size} classes (aguardando raiz)`;
    // limpa svg
    svg.selectAll("*").remove();
    return;
  }

  // Descendentes a partir da raiz (exclui superclasses acima)
  const desc = descendantsSet(childrenOf, chosenRoot);
  if (!desc.has(chosenRoot)){
    toast("A raiz escolhida n√£o est√° no recorte. Selecione uma raiz v√°lida.", true);
    return;
  }

  // construir √°rvore a partir da raiz (apenas descendentes)
  const treeData = buildTreeDataFromRoot(chosenRoot, childrenOf, desc);

  VIEW = {
    activeTaxIds,
    activeSubontologies,
    includedNodes,
    chosenRoot,
    treeData,
    childrenOf,
    colorOfSubontology,
    counts: {
      nodesInRecorte: includedNodes.size,
      nodesInTree: desc.size,
      edgesInRecorte: countEdgesInSet(childrenOf),
      edgesInTree: countEdgesInTree(childrenOf, desc),
    }
  };

  canvasTitle.textContent = `Raiz: ${chosenRoot}`;
  canvasSubtitle.textContent = `Taxonomias ativas: ${activeTaxIds.join(", ")} ‚Ä¢ Subontologias: ${Array.from(activeSubontologies).join(" | ")}`;
  canvasMeta.textContent = `√Årvore: ${desc.size} classes ‚Ä¢ ${VIEW.counts.edgesInTree} rela√ß√µes`;
  statsEl.innerHTML = `<strong>Arquivo:</strong> ${RAW.fileName} | <strong>Recorte:</strong> ${desc.size} classes (a partir da raiz)`;

  renderTopDown(treeData, childrenOf, desc, colorOfSubontology);
  setTaxDotToMixed();
  applySearchHighlight();
}

function countEdgesInSet(childrenOf){
  let c = 0;
  for (const kids of childrenOf.values()) c += kids.length;
  return c;
}
function descendantsSet(childrenOf, root){
  const st = [root];
  const seen = new Set();
  while(st.length){
    const cur = st.pop();
    if (seen.has(cur)) continue;
    seen.add(cur);
    const kids = childrenOf.get(cur) || [];
    for (const k of kids) st.push(k);
  }
  return seen;
}
function countEdgesInTree(childrenOf, nodeSet){
  let c = 0;
  for (const n of nodeSet){
    const kids = childrenOf.get(n) || [];
    for (const k of kids){
      if (nodeSet.has(k)) c++;
    }
  }
  return c;
}
function buildTreeDataFromRoot(root, childrenOf, allowedSet){
  let idCounter = 0;
  const stackGuard = new Set(); // ciclo protection by path
  function build(name, path=new Set()){
    const base = RAW.nodes.get(name) || {name, groupCanon:"(Sem subontologia)", comment:"", obs:""};
    const node = {
      name: base.name,
      group: base.groupCanon || "(Sem subontologia)",
      comment: base.comment || "",
      obs: base.obs || "",
      _id: `N-${++idCounter}`,
      children: []
    };
    if (path.has(name)) return node;
    path.add(name);

    const kids = (childrenOf.get(name) || []).filter(k => allowedSet.has(k));
    for (const k of kids){
      node.children.push(build(k, new Set(path)));
    }
    return node;
  }
  return build(root, new Set());
}

/* ============================
   11) Render top-down (sem colunas)
============================ */
let rootHierarchy = null;
let linkLayer = null;
let nodeLayer = null;
let updateFn = null;
let fitToCanvasFn = null;
let expandAllFn = null;
let collapseAllFn = null;

function renderTopDown(treeData, childrenOf, allowedSet, colorOfSubontology){
  svg.selectAll("*").remove();
  viewport = svg.append("g").attr("id","viewport");
  svg.call(zoom);
  svg.call(zoom.transform, d3.zoomIdentity.translate(18, 18).scale(1));

  linkLayer = viewport.append("g").attr("id","links");
  nodeLayer = viewport.append("g").attr("id","nodes");

  // top-down spacing (x horizontal, y vertical)
  // ‚Üë dx grande para reduzir sobreposi√ß√£o
  const dx = 340;
  const dy = 125;
  const tree = d3.tree().nodeSize([dx, dy]);

  rootHierarchy = d3.hierarchy(treeData);

  // collapse deeper initially
  collapseDeep(rootHierarchy);

  function collapseDeep(r){
    r.children?.forEach(c => c.children?.forEach(cc => collapse(cc)));
  }
  function collapse(d){
    if (d.children){
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  expandAllFn = () => expandAll(rootHierarchy);
  collapseAllFn = () => collapseAll(rootHierarchy);

  function expandAll(d){
    if (d._children){ d.children = d._children; d._children = null; }
    (d.children||[]).forEach(expandAll);
  }
  function collapseAll(d){
    (d.children||[]).forEach(collapseAll);
    if (d.depth >= 2) collapse(d);
  }

  function linkVertical(d){
    return d3.linkVertical().x(p => p.x).y(p => p.y)(d);
  }

  updateFn = () => {
    tree(rootHierarchy);

    const nodes = rootHierarchy.descendants();
    const links = rootHierarchy.links();

    // shift to leave header margin
    for (const n of nodes){
      n.y = n.y + 40;
      n.x = n.x + 20;
    }

    // LINKS
    const linkSel = linkLayer.selectAll("path.link")
      .data(links, d => d.target.data._id);

    linkSel.enter().append("path")
      .attr("class","link")
      .attr("d", d => {
        const o = {x: d.source.x, y: d.source.y};
        return linkVertical({source:o, target:o});
      })
      .merge(linkSel)
      .transition().duration(220)
      .attr("d", d => linkVertical(d));

    linkSel.exit().transition().duration(180).attr("opacity",0).remove();

    // NODES
    const nodeSel = nodeLayer.selectAll("g.node")
      .data(nodes, d => d.data._id);

    const nodeEnter = nodeSel.enter().append("g")
      .attr("class","node")
      .attr("transform", d => `translate(${d.x},${d.y})`)
      .on("click", (_, d) => {
        if (d.children){ d._children = d.children; d.children = null; }
        else { d.children = d._children; d._children = null; }
        updateFn();
        applySearchHighlight();
      })
      .on("mouseenter", (evt, d) => {
        const dd = d.data;
        showTooltip(evt, { name: dd.name, group: dd.group, comment: dd.comment, obs: dd.obs });
      })
      .on("mousemove", (evt) => moveTooltip(evt))
      .on("mouseleave", () => hideTooltip());

    nodeEnter.each(function(d){
      const g = d3.select(this);

      const subo = d.data.group || "(Sem subontologia)";
      const taxColor = colorOfSubontology.get(subo) || "#2563eb";
      const fill = mix(taxColor, "#ffffff", 0.64);
      const text = contrastText(fill);

      const lines = wrapLabel(d.data.name, 28);
      const hasKids = (d.children || d._children);

      const w = 370;
      const h = lines.length === 1 ? 52 : 68;

      // rect
      g.append("rect")
        .attr("x", -w/2).attr("y", 0)
        .attr("width", w).attr("height", h)
        .attr("fill", fill)
        .attr("stroke", taxColor)
        .attr("stroke-width", d.depth === 0 ? 2.6 : 1.5);

      // name (Arial bold)
      const t = g.append("text")
        .attr("class","name")
        .attr("text-anchor","middle")
        .attr("fill", text)
        .attr("x", 0).attr("y", 22);

      if (lines.length === 1){
        t.text(lines[0]);
      } else {
        t.append("tspan").attr("x",0).attr("dy",0).text(lines[0]);
        t.append("tspan").attr("x",0).attr("dy",16).text(lines[1]);
      }

      // group text: s√≥ o nome (sem ‚ÄúSubontologia:‚Äù)
      const groupText = (subo && subo !== "Raiz") ? subo : "";
      g.append("text")
        .attr("class","small")
        .attr("text-anchor","middle")
        .attr("fill", text)
        .attr("x", 0).attr("y", h - 10)
        .text(groupText);

      // chevron
      g.append("text")
        .attr("class","small")
        .attr("fill", text)
        .attr("x", w/2 - 10).attr("y", 18)
        .attr("text-anchor","end")
        .text(hasKids ? (d.children ? "‚ñæ" : "‚ñ∏") : "");
    });

    nodeSel.merge(nodeEnter)
      .transition().duration(220)
      .attr("transform", d => `translate(${d.x},${d.y})`);

    nodeSel.exit().transition().duration(180).attr("opacity",0).remove();
  };

  updateFn();

  fitToCanvasFn = (strong=true) => {
    if (!viewport) return;
    const bounds = viewport.node().getBBox();
    const svgEl = svg.node();
    const w = svgEl.clientWidth || 900;
    const h = svgEl.clientHeight || 600;
    const pad = 50;

    const bw = bounds.width + pad*2;
    const bh = bounds.height + pad*2;
    const scale = Math.min(3.0, Math.max(0.10, Math.min(w/bw, h/bh)));

    const tx = (w - bounds.width*scale)/2 - bounds.x*scale;
    const ty = (h - bounds.height*scale)/2 - bounds.y*scale;

    svg.transition().duration(strong ? 380 : 220).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
  };

  fitToCanvasFn(true);
}

/* ============================
   12) Search highlight
============================ */
searchEl.addEventListener("input", applySearchHighlight);
function applySearchHighlight(){
  const q = norm(searchEl.value);
  svg.selectAll("g.node").classed("node--match", false);
  if (!q) return;

  svg.selectAll("g.node").each(function(d){
    if (!d || !d.data) return;
    if (norm(d.data.name).includes(q)){
      d3.select(this).classed("node--match", true);
    }
  });
}

/* ============================
   13) Expand/Collapse/Fit
============================ */
btnFit.addEventListener("click", () => fitToCanvasFn?.(true));
btnExpandAll.addEventListener("click", () => {
  if (!expandAllFn || !updateFn) return;
  expandAllFn();
  updateFn();
  applySearchHighlight();
  fitToCanvasFn?.(false);
});
btnCollapseAll.addEventListener("click", () => {
  if (!collapseAllFn || !updateFn) return;
  collapseAllFn();
  updateFn();
  applySearchHighlight();
  fitToCanvasFn?.(false);
});

/* ============================
   14) Export SVG/PNG (corrigido)
   - embute CSS essencial
   - garante Arial bold
   - preserva linhas (vector-effect)
============================ */
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=> URL.revokeObjectURL(url), 1000);
}
function getExportName(ext){
  const root = (VIEW?.chosenRoot || "root").replace(/[^\w\-]+/g,"_");
  const taxes = (VIEW?.activeTaxIds || []).join("-");
  return `ONTOHATE_T${taxes}_ROOT_${root}.${ext}`;
}

function buildEmbeddedExportStyle(){
  // CSS enxuto (o suficiente para export consistente)
  return `
    svg { background:#ffffff; font-family: Arial, Helvetica, sans-serif; }
    .link{
      fill:none;
      stroke: rgba(16,24,40,.18);
      stroke-width: 1.25;
      stroke-linecap: round;
      stroke-linejoin: round;
      vector-effect: non-scaling-stroke;
    }
    .node rect{
      stroke: rgba(16,24,40,.18);
      stroke-width: 1.2;
      rx:10; ry:10;
      shape-rendering: geometricPrecision;
    }
    .node .name{
      font-size: 12px;
      font-weight: 700;
      font-family: Arial, Helvetica, sans-serif;
      text-rendering: geometricPrecision;
    }
    .node .small{
      font-size: 10px;
      font-weight: 700;
      font-family: Arial, Helvetica, sans-serif;
    }
  `;
}

function serializeSvgForExport(){
  const svgNode = svg.node();
  const clone = svgNode.cloneNode(true);
  clone.setAttribute("xmlns","http://www.w3.org/2000/svg");

  // remove any foreign event handlers (safety)
  clone.querySelectorAll("*").forEach(el=>{
    [...el.attributes].forEach(a=>{
      if (a.name.startsWith("on")) el.removeAttribute(a.name);
    });
  });

  // add white background + style
  const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
  bg.setAttribute("x","0"); bg.setAttribute("y","0");
  bg.setAttribute("width","100%"); bg.setAttribute("height","100%");
  bg.setAttribute("fill","#ffffff");
  clone.insertBefore(bg, clone.firstChild);

  const style = document.createElementNS("http://www.w3.org/2000/svg","style");
  style.textContent = buildEmbeddedExportStyle();
  clone.insertBefore(style, clone.firstChild.nextSibling);

  // Inline important text attrs (Arial bold) to survive rasterization quirks
  clone.querySelectorAll("text.name").forEach(t=>{
    t.setAttribute("font-family","Arial, Helvetica, sans-serif");
    t.setAttribute("font-weight","700");
  });
  clone.querySelectorAll("text.small").forEach(t=>{
    t.setAttribute("font-family","Arial, Helvetica, sans-serif");
    t.setAttribute("font-weight","700");
  });
  clone.querySelectorAll("path.link").forEach(p=>{
    p.setAttribute("vector-effect","non-scaling-stroke");
    p.setAttribute("stroke-linecap","round");
    p.setAttribute("stroke-linejoin","round");
  });

  // viewBox by bbox of viewport
  const bbox = viewport?.node()?.getBBox?.();
  if (bbox){
    const pad = 40;
    const x = bbox.x - pad, y = bbox.y - pad, w = bbox.width + pad*2, h = bbox.height + pad*2;
    clone.setAttribute("viewBox", `${x} ${y} ${w} ${h}`);
    clone.setAttribute("width", String(Math.round(w)));
    clone.setAttribute("height", String(Math.round(h)));
  }
  return new XMLSerializer().serializeToString(clone);
}

btnSvg.addEventListener("click", () => {
  try{
    const xml = serializeSvgForExport();
    downloadBlob(new Blob([xml], {type:"image/svg+xml;charset=utf-8"}), getExportName("svg"));
  } catch(e){
    toast("Falha ao exportar SVG: " + e.message, true);
  }
});

btnPng.addEventListener("click", async () => {
  try{
    const scale = parseInt(pngScaleSel.value || "3", 10);
    const xml = serializeSvgForExport();
    const svgBlob = new Blob([xml], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(svgBlob);

    const img = new Image();
    img.decoding = "async";
    img.src = url;

    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = () => reject(new Error("N√£o foi poss√≠vel renderizar o SVG para PNG."));
    });

    // infer size from the exported SVG (width/height)
    const tmp = document.createElement("div");
    tmp.style.position="fixed"; tmp.style.left="-9999px"; tmp.innerHTML = xml;
    document.body.appendChild(tmp);
    const s = tmp.querySelector("svg");
    const w = parseFloat(s.getAttribute("width")) || 1600;
    const h = parseFloat(s.getAttribute("height")) || 900;
    tmp.remove();

    const canvas = document.createElement("canvas");
    canvas.width = Math.round(w * scale);
    canvas.height = Math.round(h * scale);
    const ctx = canvas.getContext("2d");

    // white background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw at scaled transform
    ctx.setTransform(scale,0,0,scale,0,0);
    ctx.drawImage(img, 0, 0);

    URL.revokeObjectURL(url);

    canvas.toBlob((blob)=>{
      if (!blob) return toast("Falha ao gerar PNG.", true);
      downloadBlob(blob, getExportName("png"));
    }, "image/png", 1.0);

  } catch(e){
    toast("Falha ao exportar PNG: " + e.message, true);
  }
});

/* ============================
   15) Boot
============================ */
(async function(){
  try{ await loadDefault(); } catch(_) {}
})();
</script>
</body>
</html>
