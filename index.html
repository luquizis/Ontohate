<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Taxonomy Builder ‚Äî Conex√£o Raiz-Copa (Aprimorado)</title>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#ffffff; --panel:#f1f5f9; --text:#0f172a; --muted:#475569; --line:#e2e8f0;
      --accent:#2563eb; --accent2:#1e40af; --warn:#b45309; --danger:#b91c1c; --ok:#166534;
      --shadow: 0 8px 24px rgba(0,0,0,.08);
    }
    [data-theme="dark"]{
      --bg:#000000; --panel:#0f172a; --text:#f1f5f9; --muted:#94a3b8; --line:#1e293b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family: Arial, sans-serif; overflow:hidden; }
    header{
      background:var(--panel); border-bottom:1px solid var(--line);
      padding:10px 16px; display:flex; align-items:center; justify-content:space-between; height:70px; gap:12px;
    }
    .title{ font-weight:800; font-size:14px; letter-spacing:.3px; display:flex; align-items:center; gap:8px; }
    .controls{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .btn{
      background:var(--bg); border:1px solid var(--line); color:var(--text);
      padding:8px 12px; border-radius:10px; cursor:pointer; font-size:11px; font-weight:800; text-transform:uppercase;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn.primary{ background:var(--accent); color:#fff; border-color:transparent; }
    .btn:disabled{ opacity:.45; cursor:not-allowed; }
    .pill{
      font-size:11px; font-weight:800; padding:6px 10px; border-radius:999px; border:1px solid var(--line);
      color:var(--muted); background:rgba(37,99,235,.06);
    }

    #wrap{ display:flex; height:calc(100% - 70px); }
    .sidebar{
      width:380px; min-width:340px; background:var(--panel); border-right:1px solid var(--line);
      overflow-y:auto; padding:16px; font-size:13px; z-index:10;
    }
    .canvas-area{ flex:1; position:relative; background:var(--bg); overflow:hidden; }
    svg{ width:100%; height:100%; }

    .guide-step{
      background: rgba(37, 99, 235, 0.10);
      border-left:4px solid var(--accent);
      padding:10px; margin-bottom:12px; border-radius:8px;
      color:var(--text);
    }

    .section{ margin-top:14px; padding-top:12px; border-top:1px solid var(--line); }
    h3{ margin:8px 0; font-size:12px; letter-spacing:.5px; color:var(--muted); }
    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .field{ width:100%; display:flex; flex-direction:column; gap:6px; margin:8px 0; }
    select, input[type="text"]{
      width:100%; padding:10px 10px; border-radius:10px; border:1px solid var(--line);
      background:var(--bg); color:var(--text); outline:none;
    }
    label.chk{ display:flex; align-items:center; gap:8px; margin:6px 0; color:var(--text); }
    .small{ font-size:12px; color:var(--muted); line-height:1.3; }
    .status{
      margin-top:10px; padding:10px; border-radius:10px; border:1px solid var(--line);
      background: rgba(2,132,199,.06);
      color:var(--text);
    }
    .status.ok{ background: rgba(22,101,52,.10); border-color: rgba(22,101,52,.35); }
    .status.warn{ background: rgba(180,83,9,.10); border-color: rgba(180,83,9,.35); }
    .status.danger{ background: rgba(185,28,28,.10); border-color: rgba(185,28,28,.35); }

    /* D3 */
    .link{ fill:none; stroke:#94a3b8; stroke-width:1.5px; opacity:.65; }
    [data-theme="dark"] .link{ stroke:#64748b; opacity:.7; }

    .node rect{
      stroke-width:1.5px; rx:10; ry:10;
      filter: drop-shadow(0 2px 5px rgba(0,0,0,.10));
    }
    [data-theme="dark"] .node rect{
      filter: drop-shadow(0 4px 10px rgba(0,0,0,.35));
    }
    .node text{
      font-family: Arial, sans-serif; font-weight:800; pointer-events:none;
      font-size:12px;
    }

    .tooltip{
      position:fixed; display:none; z-index:1000; max-width:420px;
      background:var(--panel); color:var(--text);
      border:1px solid var(--line); border-radius:10px; padding:10px;
      box-shadow:var(--shadow);
      font-size:12px; line-height:1.25;
    }
    .tooltip .t-title{ font-weight:900; margin-bottom:6px; }
    .tooltip .kv{ display:grid; grid-template-columns: 140px 1fr; gap:6px 10px; }
    .tooltip .k{ color:var(--muted); font-weight:800; }
    .tooltip .v{ color:var(--text); word-break:break-word; }
    .hint{ color:var(--muted); font-size:12px; margin-top:6px; }
  </style>
</head>

<body data-theme="light">
<header>
  <div class="controls">
    <label class="btn primary" style="cursor:pointer;">
      üìÅ Carregar XLSX
      <input type="file" id="fileInput" accept=".xlsx" style="display:none">
    </label>

    <select id="themeSelect" class="btn" style="text-transform:uppercase; font-weight:900;">
      <option value="light">Modo claro</option>
      <option value="dark">Modo escuro</option>
    </select>

    <span class="pill" id="statsPill">Nenhum arquivo carregado</span>
  </div>

  <div class="title">üõ†Ô∏è Construtor de Taxonomia Conectada (Raiz ‚Üí Copa)</div>

  <div class="controls">
    <button class="btn" id="btnRelayout" disabled>üîÑ Reorganizar</button>
    <button class="btn" id="btnExportA4" disabled>üñºÔ∏è Exportar A4 PNG (300dpi)</button>
    <button class="btn primary" id="btnExportPng" disabled>üíæ Salvar PNG (Auto-fit)</button>
  </div>
</header>

<div id="wrap">
  <div class="sidebar">
    <div class="guide-step">
      <b>1.</b> Carregue um <b>XLSX</b>. O sistema tenta detectar colunas de <b>Classe</b> e <b>Pai</b> automaticamente.
      <div class="hint">Se n√£o detectar, ele te avisa no status.</div>
    </div>

    <div class="section">
      <h3>DIMENS√ïES (planilhas)</h3>
      <div id="dimList" class="small">Aguardando arquivo‚Ä¶</div>
      <div class="small" style="margin-top:6px;">
        Observa√ß√£o: nomes muito parecidos (ex.: ‚ÄúMotiva√ß√£o e consequ√™ncia(s)‚Äù) s√£o unificados automaticamente.
      </div>
    </div>

    <div class="section">
      <div class="guide-step">
        <b>2.</b> Escolha a <b>Raiz</b> (topo) e opcionalmente a <b>Copa</b> (limite). Se definir Copa, ser√° desenhado <b>apenas o caminho</b> Raiz ‚Üí Copa.
      </div>

      <div class="field">
        <h3>Buscar na lista</h3>
        <input type="text" id="filterInput" placeholder="Digite para filtrar op√ß√µes (raiz e copa)‚Ä¶" />
      </div>

      <div class="field">
        <h3>Raiz (apenas n√≥s com filhos)</h3>
        <select id="rootSelect"></select>
        <div class="small">A raiz s√≥ mostra classes que possuem n√≥s (filhos), evitando listas in√∫teis.</div>
      </div>

      <div class="field">
        <h3>Copa (limite)</h3>
        <select id="canopySelect">
          <option value="">Sem limite (exibir toda a √°rvore)</option>
        </select>
        <div class="small">A copa mostra n√≥s alcan√ß√°veis a partir da raiz (quando poss√≠vel).</div>
      </div>

      <div class="row">
        <label class="chk"><input type="checkbox" id="chkDrag" /> Permitir arrastar n√≥s</label>
        <label class="chk"><input type="checkbox" id="chkShowOnlyHighlighted" /> Mostrar somente dimens√µes marcadas</label>
      </div>

      <button class="btn primary" id="btnGenerate" style="width:100%; padding:14px;" disabled>Gerar taxonomia</button>

      <div id="statusBox" class="status" style="margin-top:12px;">
        Carregue um arquivo para come√ßar.
      </div>

      <div class="guide-step" style="margin-top:12px;">
        <b>Dica:</b> use scroll/trackpad para <b>zoom</b> e arraste para <b>pan</b>.
        Para um layout ‚Äúde artigo‚Äù, prefira <b>Reorganizar</b> em vez de arrastar n√≥s.
      </div>
    </div>
  </div>

  <div class="canvas-area">
    <svg id="svg"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
</div>

<script>
/* =========================
   Helpers (string/normalize)
========================= */
function stripAccents(s){
  return (s || "").normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function normKey(s){
  return stripAccents(String(s || "").trim().toLowerCase()).replace(/\s+/g," ");
}

/**
 * Normaliza nomes de dimens√µes para reduzir duplicatas:
 * - remove acentos, lower, espa√ßos
 * - regra espec√≠fica: "motivacao e consequencia" / "motivacao e consequencias"
 * - regra leve de plural: remove 's' final quando fizer sentido
 */
function normalizeDimensionName(dim){
  const base = normKey(dim);
  // Regra espec√≠fica pedida
  if (base === "motivacao e consequencia" || base === "motivacao e consequencias") return "motivacao e consequencia(s)";
  // Regra leve: se terminar com 's' e tiver mais de 4 chars, remove (ajuda "consequencias" -> "consequencia")
  if (base.length > 4 && base.endsWith("s")) return base.slice(0, -1);
  return base;
}

function escapeHtml(str){
  return String(str ?? "").replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[m]));
}

/* =========================
   App State
========================= */
let STORE = null;
let LAST_RENDER = { rootName:"", canopyName:"", activeDims:new Set(), onlyHighlighted:false };

const svg = d3.select("#svg");
const gMain = svg.append("g");

const tooltip = document.getElementById("tooltip");

function setStatus(msg, type=""){
  const el = document.getElementById("statusBox");
  el.className = "status" + (type ? " " + type : "");
  el.innerHTML = msg;
}

function setStatsPill(text){
  document.getElementById("statsPill").textContent = text;
}

function setControlsEnabled(enabled){
  document.getElementById("btnGenerate").disabled = !enabled;
  document.getElementById("btnRelayout").disabled = !enabled;
  document.getElementById("btnExportPng").disabled = !enabled;
  document.getElementById("btnExportA4").disabled = !enabled;
}

/* =========================
   Zoom / Pan
========================= */
const zoom = d3.zoom()
  .scaleExtent([0.08, 4])
  .on("zoom", (e) => gMain.attr("transform", e.transform));

svg.call(zoom);

/* =========================
   Parse XLSX (robusto)
   - detecta colunas de classe e pai
   - suporta pai com m√∫ltiplos valores (separados por ; , |)
   - cria:
       nodes: Map(name -> {name, dimKey, dimLabel, meta})
       childrenMap: Map(parent -> Set(child))
       parentsMap: Map(child -> Set(parent))
       dims: Map(dimKey -> dimLabel)
========================= */
async function handleFile(file){
  try{
    setControlsEnabled(false);
    setStatus("Lendo arquivo‚Ä¶", "");
    setStatsPill("Carregando‚Ä¶");

    const data = await file.arrayBuffer();
    const wb = XLSX.read(data, { type:"array" });

    if(!wb.SheetNames || wb.SheetNames.length === 0){
      throw new Error("O arquivo n√£o cont√©m planilhas.");
    }

    const nodes = new Map();
    const childrenMap = new Map();   // parent -> Set(children)
    const parentsMap = new Map();    // child -> Set(parents)
    const dims = new Map();          // dimKey -> label

    let totalRows = 0;
    let detectedProblems = [];

    for(const sheet of wb.SheetNames){
      const dimLabel = String(sheet || "").trim() || "Sem nome";
      const dimKey = normalizeDimensionName(dimLabel);
      if(!dims.has(dimKey)) dims.set(dimKey, dimLabel);

      const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheet], { defval:"" });
      totalRows += rows.length;

      if(rows.length === 0) continue;

      // Detectar colunas olhando o primeiro row com keys
      const keys = Object.keys(rows[0] || {});
      const nameKey = keys.find(k => /classe|class|item|name|termo|term/i.test(k));
      const parentKey = keys.find(k => /super|pai|parent|broader|mae|m√£e|hierarquia/i.test(k));

      if(!nameKey){
        detectedProblems.push(`Planilha <b>${escapeHtml(dimLabel)}</b>: n√£o detectei coluna de <b>Classe</b> (ex.: "classe", "name", "item").`);
      }

      rows.forEach((row, idx) => {
        const name = String(row[nameKey] ?? "").trim();
        if(!name) return;

        // N√≥
        if(!nodes.has(name)){
          nodes.set(name, { name, dimKey, dimLabel: dims.get(dimKey), meta: row });
        }else{
          // Se j√° existir, preserva o primeiro e apenas complementa meta se estiver vazio
          const prev = nodes.get(name);
          if(prev && (!prev.meta || Object.keys(prev.meta).length === 0)) prev.meta = row;
        }

        // Rela√ß√£o de pai
        const parentRaw = parentKey ? String(row[parentKey] ?? "").trim() : "";
        if(parentRaw && parentRaw !== name){
          const parts = parentRaw.split(/[;,|]/g).map(s => s.trim()).filter(Boolean);
          parts.forEach(parent => {
            if(parent === name) return;

            if(!childrenMap.has(parent)) childrenMap.set(parent, new Set());
            childrenMap.get(parent).add(name);

            if(!parentsMap.has(name)) parentsMap.set(name, new Set());
            parentsMap.get(name).add(parent);

            // garante n√≥ do pai existir (mesmo que n√£o esteja listado como classe em alguma linha)
            if(!nodes.has(parent)){
              nodes.set(parent, { name: parent, dimKey, dimLabel: dims.get(dimKey), meta: { __auto__: true } });
            }
          });
        }
      });
    }

    // Guardar no STORE
    STORE = { nodes, childrenMap, parentsMap, dims };

    // UI
    populateUI(detectedProblems);

    // Stats
    const numNodes = STORE.nodes.size;
    const numEdges = Array.from(STORE.childrenMap.values()).reduce((acc, set) => acc + set.size, 0);
    setStatsPill(`${numNodes} classes ‚Ä¢ ${numEdges} rela√ß√µes ‚Ä¢ ${STORE.dims.size} dimens√µes`);

    // Enable
    setControlsEnabled(true);

    // Status
    if(detectedProblems.length){
      setStatus(
        `<b>Aten√ß√£o:</b> detectei alguns pontos no XLSX:<br>‚Ä¢ ` + detectedProblems.join("<br>‚Ä¢ "),
        "warn"
      );
    }else{
      setStatus("<b>Arquivo carregado.</b> Agora selecione Raiz/Copa e clique em <b>Gerar</b>.", "ok");
    }

  }catch(err){
    console.error(err);
    STORE = null;
    setControlsEnabled(false);
    setStatsPill("Falha ao carregar");
    setStatus(`<b>Erro ao carregar XLSX:</b> ${escapeHtml(err.message || String(err))}`, "danger");
  }
}

/* =========================
   UI population
   - dimens√µes com unifica√ß√£o
   - rootSelect: apenas n√≥s com filhos
   - canopySelect: n√≥s (atualiza ap√≥s escolher raiz)
========================= */
function populateUI(problems){
  // Dimens√µes
  const dimList = d3.select("#dimList").html("");
  const dimEntries = Array.from(STORE.dims.entries()).sort((a,b) => a[1].localeCompare(b[1]));

  dimEntries.forEach(([dimKey, dimLabel]) => {
    const l = dimList.append("label").attr("class","chk");
    l.append("input")
      .attr("type","checkbox")
      .attr("checked", true)
      .attr("value", dimKey);
    l.append("span").text(" " + dimLabel);
  });

  // Root: s√≥ n√≥s que t√™m filhos (childrenMap has key)
  updateRootOptions();

  // Canopy: baseado na raiz atual (alcance)
  updateCanopyOptions();

  // Filtragem
  applyFilterToSelects(document.getElementById("filterInput").value);
}

function updateRootOptions(){
  const rootSelect = d3.select("#rootSelect").html("");
  const roots = Array.from(STORE.childrenMap.keys())
    .filter(n => STORE.nodes.has(n))
    .sort((a,b) => a.localeCompare(b, "pt-BR"));

  if(roots.length === 0){
    rootSelect.append("option").attr("value","").text("Nenhum n√≥ com filhos encontrado");
    setStatus("<b>N√£o encontrei nenhum n√≥ com filhos.</b> Verifique se a planilha tem rela√ß√µes Pai ‚Üí Filho.", "danger");
    setControlsEnabled(false);
    return;
  }

  roots.forEach(n => rootSelect.append("option").attr("value", n).text(n));
}

function reachableFromRoot(rootName){
  const seen = new Set();
  const q = [rootName];
  seen.add(rootName);

  while(q.length){
    const cur = q.shift();
    const kids = STORE.childrenMap.get(cur);
    if(!kids) continue;
    for(const k of kids){
      if(!seen.has(k)){
        seen.add(k);
        q.push(k);
      }
    }
  }
  return seen;
}

function updateCanopyOptions(){
  const canopySelect = d3.select("#canopySelect");
  canopySelect.html('<option value="">Sem limite (exibir toda a √°rvore)</option>');

  const rootName = d3.select("#rootSelect").property("value");
  if(!rootName || !STORE.nodes.has(rootName)) return;

  const reach = reachableFromRoot(rootName);
  const options = Array.from(reach).sort((a,b) => a.localeCompare(b, "pt-BR"));
  options.forEach(n => canopySelect.append("option").attr("value", n).text(n));
}

/* =========================
   Select filter (search)
========================= */
function applyFilterToSelects(q){
  q = normKey(q);
  const selects = [document.getElementById("rootSelect"), document.getElementById("canopySelect")];
  selects.forEach(sel => {
    for(const opt of sel.options){
      // n√£o filtra a op√ß√£o "Sem limite"
      if(opt.value === "" && opt.textContent.toLowerCase().includes("sem limite")) continue;
      const ok = !q || normKey(opt.textContent).includes(q);
      opt.hidden = !ok;
    }
  });
}

/* =========================
   Build "tree" to render
   - constr√≥i uma √°rvore (spanning tree) a partir da raiz via BFS
   - se canopy definido: encontra caminho raiz->canopy e renderiza somente os n√≥s desse caminho
   - se onlyHighlighted: remove n√≥s n√£o destacados (mas mant√©m caminho m√≠nimo se canopy)
========================= */
function getActiveDims(){
  const active = new Set();
  d3.selectAll("#dimList input:checked").each(function(){ active.add(this.value); });
  return active;
}

function buildSpanningTree(rootName){
  // BFS: define parentPtr e depth
  const parentPtr = new Map();
  const depth = new Map();
  const order = [];

  const q = [rootName];
  parentPtr.set(rootName, null);
  depth.set(rootName, 0);

  while(q.length){
    const cur = q.shift();
    order.push(cur);

    const kids = STORE.childrenMap.get(cur);
    if(!kids) continue;

    for(const k of kids){
      if(!parentPtr.has(k)){
        parentPtr.set(k, cur);
        depth.set(k, depth.get(cur) + 1);
        q.push(k);
      }
    }
  }
  return { parentPtr, depth, order };
}

function pathRootToCanopy(rootName, canopyName, parentPtr){
  if(!parentPtr.has(canopyName)) return null;
  const path = [];
  let cur = canopyName;
  while(cur !== null){
    path.push(cur);
    if(cur === rootName) break;
    cur = parentPtr.get(cur);
  }
  if(path[path.length - 1] !== rootName) return null;
  path.reverse();
  return path;
}

function buildHierarchyObject(rootName, canopyName, activeDims, onlyHighlighted){
  const { parentPtr } = buildSpanningTree(rootName);

  // Se canopy: restringe ao caminho
  let allowed = null;
  if(canopyName){
    const path = pathRootToCanopy(rootName, canopyName, parentPtr);
    if(!path){
      return { error: `A copa <b>${escapeHtml(canopyName)}</b> n√£o √© alcan√ß√°vel a partir da raiz <b>${escapeHtml(rootName)}</b>.` };
    }
    allowed = new Set(path);
  }

  // Fun√ß√£o de build recursivo (apenas via childrenMap)
  function buildNode(name, visited){
    if(visited.has(name)) return null;
    visited.add(name);

    const n = STORE.nodes.get(name) || { name, dimKey:"", dimLabel:"", meta:{} };
    const highlighted = activeDims.has(n.dimKey);

    if(onlyHighlighted && !highlighted){
      // se canopy, ainda permite n√≥s do caminho (allowed) para n√£o quebrar o caminho
      if(!(allowed && allowed.has(name))) return null;
    }

    let children = [];
    const kids = STORE.childrenMap.get(name);
    if(kids){
      for(const c of kids){
        if(allowed && !allowed.has(c)) continue; // se canopy, s√≥ caminho
        const built = buildNode(c, new Set(visited));
        if(built) children.push(built);
      }
    }

    // se canopy e name √© canopy, para aqui
    if(canopyName && name === canopyName) children = [];

    return { ...n, highlighted, children };
  }

  const rootObj = buildNode(rootName, new Set());
  if(!rootObj){
    return { error: "N√£o foi poss√≠vel construir a hierarquia com os filtros atuais." };
  }
  return { rootObj, allowed };
}

/* =========================
   Render (layout vertical, node box adapt√°vel, tooltip compacto)
========================= */
function render(){
  if(!STORE) return;

  const rootName = d3.select("#rootSelect").property("value");
  const canopyName = d3.select("#canopySelect").property("value") || "";
  const activeDims = getActiveDims();
  const onlyHighlighted = document.getElementById("chkShowOnlyHighlighted").checked;

  if(!rootName || !STORE.nodes.has(rootName)){
    setStatus("Selecione uma <b>Raiz</b> v√°lida.", "warn");
    return;
  }

  const built = buildHierarchyObject(rootName, canopyName, activeDims, onlyHighlighted);
  if(built.error){
    setStatus(`<b>N√£o deu para gerar:</b> ${built.error}`, "warn");
    return;
  }

  LAST_RENDER = { rootName, canopyName, activeDims, onlyHighlighted };

  gMain.selectAll("*").remove();

  const root = d3.hierarchy(built.rootObj);

  // Layout: vertical, com espa√ßamento generoso e separa√ß√£o entre irm√£os
  const NODE_W = 260;       // largura-alvo para wrap
  const NODE_PAD_X = 14;
  const NODE_PAD_Y = 10;
  const LINE_H = 14;

  const layout = d3.tree()
    .nodeSize([320, 140])
    .separation((a,b) => (a.parent === b.parent ? 1.2 : 1.6));

  layout(root);

  // Links
  const linkGen = d3.linkVertical().x(d => d.x).y(d => d.y);

  const links = gMain.selectAll(".link")
    .data(root.links())
    .enter()
    .append("path")
    .attr("class","link")
    .attr("d", d => linkGen(d));

  // Nodes
  const nodeSel = gMain.selectAll(".node")
    .data(root.descendants())
    .enter()
    .append("g")
    .attr("class","node")
    .attr("transform", d => `translate(${d.x},${d.y})`);

  // Tooltip events
  nodeSel
    .on("mousemove", (event, d) => showTooltip(event, d))
    .on("mouseleave", hideTooltip);

  // Text first (to measure)
  const textSel = nodeSel.append("text")
    .attr("text-anchor","middle")
    .attr("dy", 0)
    .attr("fill", d => d.data.highlighted ? "#ffffff" : (document.body.dataset.theme === "dark" ? "#e2e8f0" : "#0f172a"));

  // Wrap text into tspans
  textSel.each(function(d){
    const label = String(d.data.name || "");
    wrapSvgText(d3.select(this), label, NODE_W - NODE_PAD_X*2, LINE_H);
  });

  // Compute rect sizes based on text bbox per node
  nodeSel.each(function(d){
    const g = d3.select(this);
    const t = g.select("text").node();
    const bb = t.getBBox();
    const w = Math.max(170, Math.min(420, bb.width + NODE_PAD_X*2));
    const h = Math.max(44, bb.height + NODE_PAD_Y*2);

    d.__box = { w, h };
  });

  // Rects (after measurement)
  nodeSel.insert("rect", "text")
    .attr("x", d => -d.__box.w/2)
    .attr("y", d => -d.__box.h/2)
    .attr("width", d => d.__box.w)
    .attr("height", d => d.__box.h)
    .attr("fill", d => d.data.highlighted ? "var(--accent)" : (document.body.dataset.theme === "dark" ? "#111827" : "#cbd5e1"))
    .attr("stroke", d => d.data.highlighted ? "var(--accent2)" : (document.body.dataset.theme === "dark" ? "#334155" : "#94a3b8"));

  // Recolor text after theme
  nodeSel.select("text")
    .attr("fill", d => d.data.highlighted ? "#ffffff" : (document.body.dataset.theme === "dark" ? "#e2e8f0" : "#0f172a"));

  // Optional drag (disabled by default)
  const dragEnabled = document.getElementById("chkDrag").checked;
  if(dragEnabled){
    const drag = d3.drag().on("drag", function(event, d){
      d.x = event.x;
      d.y = event.y;
      d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
      links.attr("d", l => linkGen(l));
    });
    nodeSel.call(drag);
  }

  // Auto-fit
  autofitView(60);

  // Status
  const canopyText = canopyName ? `Copa: <b>${escapeHtml(canopyName)}</b> (modo caminho)` : `Copa: <b>sem limite</b>`;
  setStatus(
    `<b>Gerado.</b> Raiz: <b>${escapeHtml(rootName)}</b> ‚Ä¢ ${canopyText} ‚Ä¢ Dimens√µes ativas: <b>${activeDims.size}</b>`,
    "ok"
  );
}

/* =========================
   Text wrap for SVG <text>
========================= */
function wrapSvgText(textSel, text, maxWidth, lineHeight){
  const words = String(text).split(/\s+/g);
  let line = [];
  let lineNumber = 0;

  textSel.text(null);

  let tspan = textSel.append("tspan")
    .attr("x", 0)
    .attr("dy", "0em");

  for(const w of words){
    line.push(w);
    tspan.text(line.join(" "));
    if(tspan.node().getComputedTextLength() > maxWidth && line.length > 1){
      line.pop();
      tspan.text(line.join(" "));
      line = [w];
      lineNumber += 1;
      tspan = textSel.append("tspan")
        .attr("x", 0)
        .attr("dy", (lineNumber === 1 ? "1.15em" : "1.15em"))
        .text(w);
    }
  }

  // Centralizar bloco verticalmente: move dy do primeiro tspan
  const tspans = textSel.selectAll("tspan").nodes();
  const lines = tspans.length || 1;
  const offset = -((lines - 1) * (lineHeight/2)) / lineHeight; // em "em"
  if(tspans[0]){
    tspans[0].setAttribute("dy", `${offset}em`);
  }
}

/* =========================
   Tooltip
========================= */
function showTooltip(event, d){
  if(!d || !d.data) return;

  const meta = d.data.meta || {};
  const dim = d.data.dimLabel || d.data.dimKey || "";
  const isAuto = meta.__auto__ ? "Sim (criado por rela√ß√£o)" : "N√£o";

  // Escolhe alguns campos √∫teis primeiro (se existirem)
  const preferredKeys = ["classe", "Class", "name", "Name", "termo", "Termo", "descri√ß√£o", "descricao", "Description", "super", "pai", "parent"];
  const entries = [];

  // Dimens√£o
  if(dim) entries.push(["Dimens√£o", dim]);
  entries.push(["Auto-criado", isAuto]);

  // Preferidos
  for(const k of preferredKeys){
    if(meta && Object.prototype.hasOwnProperty.call(meta, k) && String(meta[k]).trim()){
      entries.push([k, String(meta[k])]);
    }
  }

  // Outros (limitado)
  const other = Object.keys(meta || {})
    .filter(k => !preferredKeys.includes(k) && k !== "__auto__")
    .slice(0, 10);

  other.forEach(k => {
    const v = String(meta[k] ?? "").trim();
    if(v) entries.push([k, v]);
  });

  tooltip.style.display = "block";
  tooltip.innerHTML = `
    <div class="t-title">${escapeHtml(d.data.name || "")}</div>
    <div class="kv">
      ${entries.map(([k,v]) => `
        <div class="k">${escapeHtml(k)}:</div>
        <div class="v">${escapeHtml(v)}</div>
      `).join("")}
    </div>
  `;

  // Posicionamento
  const pad = 14;
  const rect = tooltip.getBoundingClientRect();
  let x = event.clientX + pad;
  let y = event.clientY + pad;
  if(x + rect.width > window.innerWidth - 10) x = event.clientX - rect.width - pad;
  if(y + rect.height > window.innerHeight - 10) y = event.clientY - rect.height - pad;
  tooltip.style.left = x + "px";
  tooltip.style.top = y + "px";
}

function hideTooltip(){
  tooltip.style.display = "none";
}

/* =========================
   Auto-fit view
========================= */
function autofitView(topPadding=50){
  const bbox = gMain.node().getBBox();
  const svgRect = svg.node().getBoundingClientRect();

  if(!bbox || bbox.width === 0 || bbox.height === 0){
    return;
  }

  const margin = 60;
  const availableW = Math.max(1, svgRect.width - margin*2);
  const availableH = Math.max(1, svgRect.height - margin*2);

  const scale = Math.min(1.0, availableW / bbox.width, availableH / bbox.height);
  const tx = svgRect.width/2 - (bbox.x + bbox.width/2) * scale;
  const ty = topPadding - bbox.y * scale;

  svg.call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

/* =========================
   Export PNG
   - Auto-fit (igual tela)
   - A4 300dpi (2480x3508), encaixa bbox com margem
========================= */
function serializeSvgWithInlineStyle(svgNode){
  // Clona para n√£o mexer no original
  const clone = svgNode.cloneNode(true);

  // Injeta style b√°sico dentro do SVG para export fiel
  const style = document.createElementNS("http://www.w3.org/2000/svg","style");
  style.textContent = `
    .link{ fill:none; stroke:${document.body.dataset.theme === "dark" ? "#64748b" : "#94a3b8"}; stroke-width:1.5px; opacity:${document.body.dataset.theme === "dark" ? 0.7 : 0.65}; }
    .node text{ font-family: Arial, sans-serif; font-weight:800; font-size:12px; }
    .node rect{ stroke-width:1.5px; rx:10; ry:10; }
  `;
  clone.insertBefore(style, clone.firstChild);

  // Garante xmlns
  clone.setAttribute("xmlns","http://www.w3.org/2000/svg");
  clone.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink");

  return new XMLSerializer().serializeToString(clone);
}

function exportPngAuto(){
  const svgNode = document.getElementById("svg");
  const bbox = gMain.node().getBBox();
  if(!bbox || bbox.width === 0 || bbox.height === 0){
    setStatus("Nada para exportar (bbox vazio). Gere a taxonomia antes.", "warn");
    return;
  }

  const padding = 120;
  const scale = 3; // ‚Äúresolu√ß√£o‚Äù melhor
  const w = (bbox.width + padding*2);
  const h = (bbox.height + padding*2);

  const canvas = document.createElement("canvas");
  canvas.width = Math.ceil(w * scale);
  canvas.height = Math.ceil(h * scale);

  const ctx = canvas.getContext("2d");
  ctx.setTransform(scale, 0, 0, scale, 0, 0);

  ctx.fillStyle = (document.body.dataset.theme === "dark") ? "#000000" : "#ffffff";
  ctx.fillRect(0,0,w,h);

  const svgString = serializeSvgWithInlineStyle(svgNode);
  const img = new Image();
  img.onload = () => {
    ctx.drawImage(img, padding - bbox.x, padding - bbox.y);
    const a = document.createElement("a");
    a.download = "taxonomia_auto.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  };
  img.onerror = () => setStatus("Falha ao exportar: n√£o consegui rasterizar o SVG.", "danger");
  img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgString);
}

function exportPngA4(){
  const svgNode = document.getElementById("svg");
  const bbox = gMain.node().getBBox();
  if(!bbox || bbox.width === 0 || bbox.height === 0){
    setStatus("Nada para exportar (bbox vazio). Gere a taxonomia antes.", "warn");
    return;
  }

  // A4 portrait 300dpi
  const A4_W = 2480;
  const A4_H = 3508;
  const margin = 180;

  const canvas = document.createElement("canvas");
  canvas.width = A4_W;
  canvas.height = A4_H;

  const ctx = canvas.getContext("2d");
  ctx.fillStyle = (document.body.dataset.theme === "dark") ? "#000000" : "#ffffff";
  ctx.fillRect(0,0,A4_W,A4_H);

  // escala para caber no A4 (√°rea √∫til)
  const usableW = A4_W - margin*2;
  const usableH = A4_H - margin*2;

  const s = Math.min(usableW / bbox.width, usableH / bbox.height);
  const tx = margin + (usableW/2) - (bbox.x + bbox.width/2) * s;
  const ty = margin + (usableH/2) - (bbox.y + bbox.height/2) * s;

  const svgString = serializeSvgWithInlineStyle(svgNode);
  const img = new Image();
  img.onload = () => {
    ctx.setTransform(s, 0, 0, s, tx, ty);
    ctx.drawImage(img, 0, 0);
    const a = document.createElement("a");
    a.download = "taxonomia_A4_300dpi.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  };
  img.onerror = () => setStatus("Falha ao exportar A4: n√£o consegui rasterizar o SVG.", "danger");
  img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgString);
}

/* =========================
   Re-layout button
========================= */
function relayout(){
  // S√≥ reaplica render com os mesmos par√¢metros, recalculando o tree layout
  render();
}

/* =========================
   Events
========================= */
document.getElementById("fileInput").addEventListener("change", (e) => {
  const f = e.target.files && e.target.files[0];
  if(f) handleFile(f);
});

document.getElementById("themeSelect").addEventListener("change", function(){
  document.body.dataset.theme = this.value;

  // Re-render para ajustar cores com o tema
  if(STORE){
    render();
  }
});

document.getElementById("btnGenerate").addEventListener("click", render);
document.getElementById("btnRelayout").addEventListener("click", relayout);
document.getElementById("btnExportPng").addEventListener("click", exportPngAuto);
document.getElementById("btnExportA4").addEventListener("click", exportPngA4);

document.getElementById("rootSelect").addEventListener("change", () => {
  updateCanopyOptions();
  applyFilterToSelects(document.getElementById("filterInput").value);
});

document.getElementById("filterInput").addEventListener("input", (e) => {
  applyFilterToSelects(e.target.value);
});

document.getElementById("chkDrag").addEventListener("change", () => {
  // S√≥ re-render se j√° existe render
  if(STORE) render();
});

document.getElementById("chkShowOnlyHighlighted").addEventListener("change", () => {
  if(STORE) render();
});

</script>
</body>
</html>
