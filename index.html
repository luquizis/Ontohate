<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ONTOHATE V2 ‚Äî Taxonomias Top-Down (A | B) + Export</title>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#f6f7f9;
      --text:#101828;
      --muted:#475467;
      --line:#e4e7ec;
      --shadow: 0 10px 24px rgba(16,24,40,.10);
      --radius: 14px;

      --t1:#2563eb; /* azul */
      --t2:#16a34a; /* verde */
      --t3:#f97316; /* laranja */
      --t4:#a855f7; /* roxo */
    }

    html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    header{
      position: sticky; top:0; z-index: 10;
      background: rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
      padding: 12px 14px;
      display:flex; flex-wrap:wrap;
      gap: 10px 12px;
      align-items:center; justify-content: space-between;
    }
    .brand{display:flex; flex-direction:column; gap:4px; min-width: 280px;}
    .brand h1{margin:0; font-size:14px; font-weight:800;}
    .brand .sub{margin:0; font-size:12px; color:var(--muted); max-width: 920px; line-height: 1.25;}

    .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end;}
    .btn,.file,.input,.select,.pill{
      border:1px solid var(--line);
      background: var(--panel);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1;
      display:inline-flex;
      gap:8px;
      align-items:center;
      box-shadow: 0 1px 0 rgba(16,24,40,.04);
    }
    .btn{cursor:pointer; user-select:none;}
    .btn:hover{filter: brightness(.98);}
    .file input[type="file"]{display:none;}
    .input input, .select select{
      border:none; outline:none; background:transparent; color:var(--text); font-size: 12px;
    }
    .input input{width: 220px;}
    .select select{appearance:none;}

    .pill{background:#fff; box-shadow:none;}
    .pill strong{font-weight:700;}
    .dot{width:10px; height:10px; border-radius:999px; display:inline-block; background:var(--t1);
      border: 1px solid rgba(16,24,40,.12);}

    #wrap{
      height: calc(100% - 72px);
      display:grid;
      grid-template-columns: 1fr 420px;
      gap: 14px;
      padding: 14px;
      box-sizing: border-box;
    }
    @media (max-width: 1100px){
      #wrap{grid-template-columns: 1fr; height:auto;}
      body{height:auto;}
    }

    .card{
      background:#fff;
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .canvas{min-height: 720px; display:flex; flex-direction:column;}
    .canvasHeader{
      padding: 10px 12px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .canvasHeader .title{display:flex; flex-direction:column; gap:4px;}
    .canvasHeader .title b{font-size:13px;}
    .canvasHeader .title span{font-size:12px; color:var(--muted);}
    .canvasHeader .meta{font-size:12px; color:var(--muted); text-align:right; white-space:nowrap;}
    .canvasBody{flex:1; overflow:hidden;}
    svg{width:100%; height:100%; display:block; background:#fff;}

    .side{padding: 12px; display:flex; flex-direction:column; gap:10px;}
    .side h2{font-size:13px; margin:0;}
    .side p{margin:0; font-size:12px; color:var(--muted); line-height:1.35;}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .sep{height:1px; background: var(--line); margin: 6px 0;}

    /* SVG styles */
    .divider{stroke: rgba(16,24,40,.10); stroke-width: 2;}
    .colLabel{font-size: 12px; fill: var(--muted); font-weight: 800;}
    .link{fill:none; stroke: rgba(16,24,40,.14); stroke-width: 1.15;}
    .node rect{
      stroke: rgba(16,24,40,.18);
      stroke-width: 1.15;
      rx:10; ry:10;
      shape-rendering: geometricPrecision;
    }
    .node .name{font-size: 12px; font-weight: 700;}
    .node .small{font-size: 10px; opacity:.95;}
    .node--match rect{stroke-width: 2.4; stroke: rgba(249,115,22,.95);}

    /* Tooltip */
    .tooltip{
      position: fixed;
      z-index: 9999;
      display: none;
      max-width: 520px;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 10px 12px;
      font-size: 12px;
      color: var(--text);
      pointer-events: none;
      white-space: pre-wrap;
    }
    .tooltip .tTitle{font-weight: 800; margin-bottom: 6px;}
    .tooltip .tMeta{color: var(--muted); margin-bottom: 8px;}
    .tooltip .tSection{margin-top: 8px;}
    .tooltip .tSection b{display:block; margin-bottom: 4px;}
    .tooltip .tEmpty{color: var(--muted); font-style: italic;}

    .toast{
      position:fixed; left:14px; bottom:14px; z-index:50;
      background:#fff; border:1px solid var(--line);
      padding:10px 12px; border-radius: 12px;
      box-shadow: var(--shadow);
      font-size:12px; color: var(--muted);
      max-width: min(980px, calc(100% - 28px));
      white-space: pre-wrap;
    }
    .toast.bad{border-color: rgba(255,107,107,.55); color:#7a0b0b;}
    .mini{font-size:11px;color:var(--muted)}
  </style>
</head>

<body>
<header>
  <div class="brand">
    <h1>ONTOHATE V2 ‚Äî Top-Down (A | B) + Raiz escolhida + Export</h1>
    <p class="sub">
      Visualiza√ß√£o <b>Top-Down</b> com <b>duas colunas</b>: A (esquerda) e B (direita).
      Tooltip no hover mostra <b>Comments/Observa√ß√µes</b> (se existirem no XLSX).
    </p>
  </div>

  <div class="controls">
    <label class="file btn">
      üìÑ Carregar XLSX
      <input id="fileInput" type="file" accept=".xlsx,.xls" />
    </label>

    <div class="btn" id="btnLoadDefault">‚¨áÔ∏è Carregar Ontohate_V2.xlsx</div>

    <div class="select">
      üß≠
      <select id="taxSelector">
        <option value="1">Taxonomia 1</option>
        <option value="2">Taxonomia 2</option>
        <option value="3">Taxonomia 3</option>
        <option value="4">Taxonomia 4</option>
      </select>
    </div>

    <div class="input">
      üîé <input id="search" placeholder="Buscar classe (A e B)" />
    </div>

    <div class="btn" id="btnFit">‚§¢ Ajustar</div>
    <div class="btn" id="btnExpandAll">‚ûï Expandir</div>
    <div class="btn" id="btnCollapseAll">‚ûñ Recolher</div>

    <div class="btn" id="btnSvg">‚¨áÔ∏é SVG</div>
    <div class="select" title="PNG em alta resolu√ß√£o">
      PNG
      <select id="pngScale">
        <option value="3">3√ó</option>
        <option value="4">4√ó</option>
      </select>
    </div>
    <div class="btn" id="btnPng">‚¨áÔ∏é PNG</div>

    <div class="pill">
      <span class="dot" id="taxDot"></span>
      <span id="stats"><strong>Arquivo:</strong> ‚Äî | <strong>A:</strong> ‚Äî | <strong>B:</strong> ‚Äî</span>
    </div>
  </div>
</header>

<div id="wrap">
  <div class="card canvas">
    <div class="canvasHeader">
      <div class="title">
        <b id="canvasTitle">‚Äî</b>
        <span id="canvasSubtitle">‚Äî</span>
      </div>
      <div class="meta" id="canvasMeta">‚Äî</div>
    </div>
    <div class="canvasBody">
      <svg id="svg"></svg>
    </div>
  </div>

  <div class="card side">
    <h2>Configura√ß√£o</h2>
    <p>Selecione duas subontologias (A e B). Escolha (opcionalmente) uma classe raiz por lado.</p>

    <div class="row">
      <span class="pill"><span class="dot" id="sideDot"></span><b id="pairLabel">‚Äî</b></span>
    </div>

    <div class="row">
      <span class="select">A:
        <select id="pairA"></select>
      </span>
      <span class="select">B:
        <select id="pairB"></select>
      </span>
      <span class="btn" id="btnApplyPair">Aplicar</span>
    </div>

    <div class="sep"></div>

    <h2>Raiz Top-Down</h2>
    <p class="mini">‚Äú(Autom√°tico)‚Äù mant√©m ra√≠zes naturais. O resto aparece em ‚ÄúOutras ra√≠zes‚Äù (nenhuma classe some).</p>

    <div class="row">
      <span class="select">Raiz A:
        <select id="rootASelect"></select>
      </span>
      <span class="select">Raiz B:
        <select id="rootBSelect"></select>
      </span>
      <span class="btn" id="btnApplyRoots">Aplicar ra√≠zes</span>
    </div>

    <div class="sep"></div>

    <p class="mini"><b>Tooltip:</b> o hover mostra Comments/Observa√ß√µes se existirem no XLSX.</p>
  </div>
</div>

<div class="tooltip" id="tooltip"></div>
<div class="toast" id="toast" style="display:none;"></div>

<script>
const TAX_PRESETS = {
  1: { label: "Taxonomia 1", aHint: "naturez", bHint: "manif",   colorVar: "--t1" },
  2: { label: "Taxonomia 2", aHint: "motiv",   bHint: "consequ", colorVar: "--t2" },
  3: { label: "Taxonomia 3", aHint: "context", bHint: "moder",   colorVar: "--t3" },
  4: { label: "Taxonomia 4", aHint: "recurso", bHint: "moder",   colorVar: "--t4" },
};

const svg = d3.select("#svg");
let viewport = null;

const toastEl = document.getElementById("toast");
const tooltipEl = document.getElementById("tooltip");

const statsEl = document.getElementById("stats");
const fileInput = document.getElementById("fileInput");
const searchEl = document.getElementById("search");
const taxSelector = document.getElementById("taxSelector");
const pairA = document.getElementById("pairA");
const pairB = document.getElementById("pairB");
const pairLabel = document.getElementById("pairLabel");
const btnApplyPair = document.getElementById("btnApplyPair");
const canvasTitle = document.getElementById("canvasTitle");
const canvasSubtitle = document.getElementById("canvasSubtitle");
const canvasMeta = document.getElementById("canvasMeta");
const taxDot = document.getElementById("taxDot");
const sideDot = document.getElementById("sideDot");

const rootASelect = document.getElementById("rootASelect");
const rootBSelect = document.getElementById("rootBSelect");
const btnApplyRoots = document.getElementById("btnApplyRoots");

const btnFit = document.getElementById("btnFit");
const btnExpandAll = document.getElementById("btnExpandAll");
const btnCollapseAll = document.getElementById("btnCollapseAll");

const btnSvg = document.getElementById("btnSvg");
const btnPng = document.getElementById("btnPng");
const pngScaleSel = document.getElementById("pngScale");

function toast(msg, bad=false){
  toastEl.textContent = msg;
  toastEl.classList.toggle("bad", !!bad);
  toastEl.style.display = "block";
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(()=> toastEl.style.display="none", 9000);
}
function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
function setDotColor(varName){
  const c = cssVar(varName);
  taxDot.style.background = c;
  sideDot.style.background = c;
}
function norm(s){
  return String(s||"").trim().toLowerCase().normalize("NFD").replace(/\p{Diacritic}/gu,"");
}
function normalizeKey(k){ return norm(k); }
function pick(row, wanted){
  const keys = Object.keys(row || {});
  const map = new Map(keys.map(k => [normalizeKey(k), k]));
  for (const w of wanted){
    const kk = map.get(normalizeKey(w));
    if (kk != null) return row[kk];
  }
  return undefined;
}
function bestMatch(groups, hint){
  const h = norm(hint);
  if (!groups.length) return "";
  const candidates = groups.filter(g => norm(g).includes(h));
  return candidates.length ? candidates[0] : groups[0];
}
function fillSelect(selectEl, options, selected){
  selectEl.innerHTML = "";
  for (const o of options){
    const opt = document.createElement("option");
    opt.value = o;
    opt.textContent = o;
    if (o === selected) opt.selected = true;
    selectEl.appendChild(opt);
  }
}
function wrapLabel(text, maxChars=30){
  const t = String(text||"");
  if (t.length <= maxChars) return [t];
  const parts = t.split(/[_\s-]+/);
  if (parts.length === 1) return [t.slice(0, maxChars) + "‚Ä¶"];
  const lines = [];
  let cur = "";
  for (const p of parts){
    const next = cur ? (cur + " " + p) : p;
    if (next.length > maxChars){
      if (cur) lines.push(cur);
      cur = p;
    } else cur = next;
    if (lines.length >= 2) break;
  }
  if (cur && lines.length < 2) lines.push(cur);
  const joined = parts.join(" ");
  if (joined.length > lines.join(" ").length) lines[lines.length-1] += "‚Ä¶";
  return lines;
}

/* ======= Color helpers ======= */
function hexToRgb(hex){
  const h = hex.replace("#","").trim();
  if (h.length !== 6) return {r:0,g:0,b:0};
  return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
}
function rgbToHex(r,g,b){
  const to = (n)=> n.toString(16).padStart(2,"0");
  return `#${to(r)}${to(g)}${to(b)}`;
}
function mix(hexA, hexB, t){
  const a = hexToRgb(hexA), b = hexToRgb(hexB);
  const r = Math.round(a.r*(1-t) + b.r*t);
  const g = Math.round(a.g*(1-t) + b.g*t);
  const bb = Math.round(a.b*(1-t) + b.b*t);
  return rgbToHex(r,g,bb);
}
function luminance(hex){
  const {r,g,b} = hexToRgb(hex);
  const srgb = [r,g,b].map(v=>{
    const c = v/255;
    return (c<=0.03928)? c/12.92 : Math.pow((c+0.055)/1.055, 2.4);
  });
  return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
}
function contrastText(bgHex){ return luminance(bgHex) > 0.55 ? "#101828" : "#ffffff"; }

/* ======= Tooltip helpers ======= */
function showTooltip(evt, payload){
  const pad = 14;
  const vw = window.innerWidth, vh = window.innerHeight;

  tooltipEl.innerHTML = `
    <div class="tTitle">${escapeHtml(payload.name || "")}</div>
    <div class="tMeta">${escapeHtml(payload.group || "")}</div>
    <div class="tSection">
      <b>Comments</b>
      <div>${payload.comment ? escapeHtml(payload.comment) : '<span class="tEmpty">(sem comments)</span>'}</div>
    </div>
    <div class="tSection">
      <b>Observa√ß√µes</b>
      <div>${payload.obs ? escapeHtml(payload.obs) : '<span class="tEmpty">(sem observa√ß√µes)</span>'}</div>
    </div>
  `;
  tooltipEl.style.display = "block";

  // position near cursor but within viewport
  const rect = tooltipEl.getBoundingClientRect();
  let x = evt.clientX + 14;
  let y = evt.clientY + 14;
  if (x + rect.width + pad > vw) x = evt.clientX - rect.width - 14;
  if (y + rect.height + pad > vh) y = evt.clientY - rect.height - 14;
  x = Math.max(pad, x);
  y = Math.max(pad, y);
  tooltipEl.style.left = x + "px";
  tooltipEl.style.top = y + "px";
}
function moveTooltip(evt){
  if (tooltipEl.style.display !== "block") return;
  const pad = 14;
  const vw = window.innerWidth, vh = window.innerHeight;
  const rect = tooltipEl.getBoundingClientRect();
  let x = evt.clientX + 14;
  let y = evt.clientY + 14;
  if (x + rect.width + pad > vw) x = evt.clientX - rect.width - 14;
  if (y + rect.height + pad > vh) y = evt.clientY - rect.height - 14;
  x = Math.max(pad, x);
  y = Math.max(pad, y);
  tooltipEl.style.left = x + "px";
  tooltipEl.style.top = y + "px";
}
function hideTooltip(){ tooltipEl.style.display = "none"; tooltipEl.innerHTML = ""; }
function escapeHtml(s){
  return String(s||"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/* ======= Zoom ======= */
const zoom = d3.zoom()
  .scaleExtent([0.10, 3.5])
  .on("zoom", (event) => { if (viewport) viewport.attr("transform", event.transform); });

/* ======= State ======= */
let RAW = null; // { nodes, edges, groups, sheetNames, fileName }
let CURRENT = null;

let rootA = null;
let rootB = null;
let nodeLayer = null;
let linkLayer = null;

let updateFn = null;
let fitToCanvasFn = null;
let expandAllFn = null;
let collapseAllFn = null;

/* ======= Load XLSX ======= */
document.getElementById("btnLoadDefault").addEventListener("click", loadDefault);
fileInput.addEventListener("change", async (ev) => {
  const f = ev.target.files?.[0];
  if (!f) return;
  const buf = await f.arrayBuffer();
  await parseAndInit(buf, f.name);
});

async function loadDefault(){
  const url = "Ontohate_V2.xlsx";
  try{
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error(`N√£o encontrei ${url} (HTTP ${res.status}). Verifique o nome exato no repo.`);
    const buf = await res.arrayBuffer();
    await parseAndInit(buf, url);
  } catch(e){
    toast("Erro ao carregar XLSX:\n" + e.message, true);
  }
}

/* ======= Parse XLSX (inclui comment/observa√ß√µes) ======= */
async function parseAndInit(buf, fileName){
  let wb;
  try{ wb = XLSX.read(buf, { type:"array" }); }
  catch(e){ toast("Falha ao ler o XLSX:\n" + e.message, true); return; }

  const sheetNames = wb.SheetNames || [];
  if (!sheetNames.length){ toast("XLSX sem abas.", true); return; }

  const nodes = new Map(); // name -> {name, group, sheet, comment, obs}
  const edges = [];        // [child, parent]
  const groupSet = new Set();

  function ensureNode(name, group="", sheet="", comment="", obs=""){
    const n = String(name||"").trim();
    if (!n) return null;

    if (!nodes.has(n)){
      nodes.set(n, {
        name:n,
        group:String(group||"").trim(),
        sheet:String(sheet||"").trim(),
        comment:String(comment||"").trim(),
        obs:String(obs||"").trim(),
      });
    } else {
      const cur = nodes.get(n);
      if (!cur.group && group) cur.group = String(group).trim();
      if (!cur.sheet && sheet) cur.sheet = String(sheet).trim();

      // acumula comment/obs se aparecerem em outra aba/linha
      const cmt = String(comment||"").trim();
      const ob  = String(obs||"").trim();
      if (cmt && !cur.comment) cur.comment = cmt;
      if (ob && !cur.obs) cur.obs = ob;
    }

    if (nodes.get(n).group) groupSet.add(nodes.get(n).group);
    return n;
  }

  let usedRows = 0;

  for (const sname of sheetNames){
    const ws = wb.Sheets[sname];
    if (!ws) continue;
    const json = XLSX.utils.sheet_to_json(ws, { defval:"" });

    for (const r of json){
      const child = pick(r, ["Classe", "Class", "classe"]);
      const parent = pick(r, ["Superclasse", "Superclass", "superclasse"]);
      const group  = pick(r, ["Subontologia", "Sub-ontologia", "Subontology", "subontologia"]);

      // Comments/Observa√ß√µes (tentamos v√°rios nomes comuns)
      const comment = pick(r, ["Comment", "Comments", "comment", "comments", "rdfs:comment", "RDFS:comment", "Anota√ß√£o", "Anotacao", "anotacao", "anota√ß√£o"]);
      const obs     = pick(r, ["Observa√ß√£o", "Observacao", "observacao", "observa√ß√£o", "Observa√ß√µes", "Observacoes", "observacoes", "notes", "Notes", "nota", "notas"]);

      const c = String(child||"").trim();
      if (!c) continue;

      const p = String(parent||"").trim();
      const g = String(group||"").trim();

      ensureNode(c, g, sname, comment, obs);
      if (p) ensureNode(p, "", "", "", "");

      if (p) edges.push([c,p]);
      usedRows++;
    }
  }

  if (!usedRows || nodes.size === 0){
    toast("N√£o encontrei a coluna 'Classe' na planilha.", true);
    return;
  }

  // dedup edges
  const seen = new Set();
  const edgesUniq = [];
  for (const [c,p] of edges){
    const k = c + "‚Üí" + p;
    if (!seen.has(k)){ seen.add(k); edgesUniq.push([c,p]); }
  }

  const groups = Array.from(groupSet).sort((a,b)=> a.localeCompare(b));
  const GROUP_OPTIONS = ["(Sem subontologia)", ...groups];

  RAW = { nodes, edges: edgesUniq, groups: GROUP_OPTIONS, sheetNames, fileName };

  taxSelector.value = "1";
  syncPairUIFromPreset(1);
  applyTaxonomy();

  toast(`Planilha carregada: ${fileName}\nAbas: ${sheetNames.length}\nClasses totais: ${nodes.size}`);
}

/* ======= Pair selection ======= */
taxSelector.addEventListener("change", () => {
  if (!RAW) return;
  const id = Number(taxSelector.value);
  syncPairUIFromPreset(id);
  applyTaxonomy();
});
btnApplyPair.addEventListener("click", () => { if (RAW) applyTaxonomy(); });
btnApplyRoots.addEventListener("click", () => { if (RAW) applyTaxonomy(); });

function syncPairUIFromPreset(taxId){
  const preset = TAX_PRESETS[taxId];
  pairLabel.textContent = preset.label;
  setDotColor(preset.colorVar);

  const options = RAW?.groups || ["(Sem subontologia)"];
  const real = options.filter(g => g !== "(Sem subontologia)");
  const a = bestMatch(real, preset.aHint) || (real[0] || "(Sem subontologia)");
  const b = bestMatch(real, preset.bHint) || (real[1] || real[0] || "(Sem subontologia)");

  fillSelect(pairA, options, a);
  fillSelect(pairB, options, b);
}

/* ======= Taxonomy build ======= */
function applyTaxonomy(){
  if (!RAW) return;

  const taxId = Number(taxSelector.value);
  const preset = TAX_PRESETS[taxId];
  const taxColor = cssVar(preset.colorVar);
  setDotColor(preset.colorVar);

  const selA = pairA.value;
  const selB = pairB.value;

  const inA = new Set();
  const inB = new Set();

  for (const [name, obj] of RAW.nodes.entries()){
    const g = (obj.group || "").trim();
    const gx = g ? g : "(Sem subontologia)";
    if (gx === selA) inA.add(name);
    if (gx === selB) inB.add(name);
  }

  const optA = ["(Autom√°tico)", ...Array.from(inA).sort((a,b)=>a.localeCompare(b))];
  const optB = ["(Autom√°tico)", ...Array.from(inB).sort((a,b)=>a.localeCompare(b))];

  const prevA = rootASelect.value || "(Autom√°tico)";
  const prevB = rootBSelect.value || "(Autom√°tico)";
  fillSelect(rootASelect, optA, optA.includes(prevA) ? prevA : "(Autom√°tico)");
  fillSelect(rootBSelect, optB, optB.includes(prevB) ? prevB : "(Autom√°tico)");

  const rootPickA = rootASelect.value || "(Autom√°tico)";
  const rootPickB = rootBSelect.value || "(Autom√°tico)";

  function buildSide(sideSet, sideName){
    const childrenOf = new Map();
    const hasParent = new Set();
    let edgesCount = 0;

    for (const [c,p] of RAW.edges){
      if (!sideSet.has(c) || !sideSet.has(p)) continue;
      edgesCount++;
      hasParent.add(c);
      if (!childrenOf.has(p)) childrenOf.set(p, []);
      childrenOf.get(p).push(c);
    }
    for (const [p, kids] of childrenOf.entries()){
      kids.sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));
    }

    const naturalRoots = [];
    for (const n of sideSet){
      if (!hasParent.has(n)) naturalRoots.push(n);
    }
    naturalRoots.sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));

    let idCounter = 0;
    function buildSubtree(name, stack=new Set()){
      const base = RAW.nodes.get(name) || { name, group:"", sheet:"", comment:"", obs:"" };
      const node = {
        name: base.name,
        group: (base.group || "").trim() || "(Sem subontologia)",
        comment: (base.comment || "").trim(),
        obs: (base.obs || "").trim(),
        _id: `${sideName}-${++idCounter}`,
        children: []
      };
      if (stack.has(name)) return node;
      stack.add(name);
      const kids = childrenOf.get(name) || [];
      for (const k of kids) node.children.push(buildSubtree(k, new Set(stack)));
      return node;
    }

    function descendantsSet(rootName){
      const st = [rootName];
      const seen = new Set();
      while(st.length){
        const cur = st.pop();
        if (seen.has(cur)) continue;
        seen.add(cur);
        const kids = childrenOf.get(cur) || [];
        for (const k of kids) st.push(k);
      }
      return seen;
    }

    return { edgesCount, naturalRoots, buildSubtree, descendantsSet, nodesCount: sideSet.size };
  }

  const sideA = buildSide(inA, "A");
  const sideB = buildSide(inB, "B");

  function makeForest(side, label, chosenRoot){
    if (!chosenRoot || chosenRoot === "(Autom√°tico)"){
      return { name: label, group:"Raiz", _id: `${label}-ROOT`, children: side.naturalRoots.map(r=>side.buildSubtree(r)) };
    }
    const subtreeNodes = side.descendantsSet(chosenRoot);
    const otherRoots = side.naturalRoots.filter(r => !subtreeNodes.has(r));
    const children = [ side.buildSubtree(chosenRoot) ];
    if (otherRoots.length){
      children.push({ name:"Outras ra√≠zes", group:"Raiz", _id:`${label}-OTHERS`, children: otherRoots.map(r=>side.buildSubtree(r)) });
    }
    return { name: label, group:"Raiz", _id: `${label}-ROOT`, children };
  }

  const forestA = makeForest(sideA, `A: ${selA}`, rootPickA);
  const forestB = makeForest(sideB, `B: ${selB}`, rootPickB);

  CURRENT = {
    taxId, label: preset.label, selA, selB,
    forestA, forestB,
    countA: sideA.nodesCount, countB: sideB.nodesCount,
    edgesA: sideA.edgesCount, edgesB: sideB.edgesCount,
    taxColor, rootPickA, rootPickB
  };

  canvasTitle.textContent = `${preset.label}: ${selA}  |  ${selB}`;
  canvasSubtitle.textContent = `Top-Down ‚Ä¢ Raiz A: ${rootPickA} ‚Ä¢ Raiz B: ${rootPickB}`;
  canvasMeta.textContent = `A: ${sideA.nodesCount} classes / ${sideA.edgesCount} rela√ß√µes ‚Ä¢ B: ${sideB.nodesCount} classes / ${sideB.edgesCount} rela√ß√µes`;

  statsEl.innerHTML = `<strong>Arquivo:</strong> ${RAW.fileName} | <strong>A:</strong> ${sideA.nodesCount} | <strong>B:</strong> ${sideB.nodesCount}`;

  renderTopDownTwoColumns(forestA, forestB, taxColor);
}

/* ======= Render Top-Down Two Columns ======= */
btnFit.addEventListener("click", () => { if (fitToCanvasFn) fitToCanvasFn(true); });
btnExpandAll.addEventListener("click", () => {
  if (!updateFn || !expandAllFn) return;
  expandAllFn();
  updateFn();
  applySearchHighlight();
  fitToCanvasFn?.(false);
});
btnCollapseAll.addEventListener("click", () => {
  if (!updateFn || !collapseAllFn) return;
  collapseAllFn();
  updateFn();
  applySearchHighlight();
  fitToCanvasFn?.(false);
});
searchEl.addEventListener("input", applySearchHighlight);

function renderTopDownTwoColumns(forestA, forestB, taxColor){
  svg.selectAll("*").remove();
  viewport = svg.append("g").attr("id","viewport");
  svg.call(zoom);
  svg.call(zoom.transform, d3.zoomIdentity.translate(18, 18).scale(1));

  linkLayer = viewport.append("g").attr("id","links");
  nodeLayer = viewport.append("g").attr("id","nodes");

  const svgEl = svg.node();
  const W = svgEl.clientWidth || 1200;
  const H = svgEl.clientHeight || 800;

  const gutter = 90;
  const leftW = Math.max(420, (W - gutter) / 2);
  const leftX0 = 0;
  const rightX0 = leftW + gutter;

  const headerG = viewport.append("g").attr("id","colHeader");
  headerG.append("line").attr("class","divider")
    .attr("x1", leftW + gutter/2).attr("x2", leftW + gutter/2)
    .attr("y1", 0).attr("y2", Math.max(H, 1200));
  headerG.append("text").attr("class","colLabel").attr("x", leftX0 + 10).attr("y", 18).text(forestA.name);
  headerG.append("text").attr("class","colLabel").attr("x", rightX0 + 10).attr("y", 18).text(forestB.name);

  // Top-down spacing (x horizontal, y vertical)
  const dx = 320;
  const dy = 120;
  const tree = d3.tree().nodeSize([dx, dy]);

  rootA = d3.hierarchy(forestA);
  rootB = d3.hierarchy(forestB);

  collapseDeep(rootA);
  collapseDeep(rootB);

  function collapseDeep(r){
    r.children?.forEach(c => c.children?.forEach(cc => collapse(cc)));
  }
  function collapse(d){
    if (d.children){
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  expandAllFn = () => { expandAll(rootA); expandAll(rootB); };
  collapseAllFn = () => { collapseAll(rootA); collapseAll(rootB); };

  function expandAll(d){
    if (d._children){ d.children = d._children; d._children = null; }
    (d.children||[]).forEach(expandAll);
  }
  function collapseAll(d){
    (d.children||[]).forEach(collapseAll);
    if (d.depth >= 2) collapse(d);
  }

  function linkVertical(d){
    return d3.linkVertical().x(p => p.x).y(p => p.y)(d);
  }

  const fillA = mix(taxColor, "#ffffff", 0.72);
  const fillB = mix(taxColor, "#ffffff", 0.60);
  const textA = contrastText(fillA);
  const textB = contrastText(fillB);

  function layoutAndShift(nodeRoot, xOffset){
    tree(nodeRoot);
    const nodes = nodeRoot.descendants();
    const links = nodeRoot.links();
    for (const n of nodes){
      n.x = xOffset + n.x + 20;
      n.y = n.y + 55;
    }
    return { nodes, links };
  }

  updateFn = () => {
    const A = layoutAndShift(rootA, leftX0);
    const B = layoutAndShift(rootB, rightX0);

    const allNodes = [...A.nodes.map(d=>({d, side:"A"})), ...B.nodes.map(d=>({d, side:"B"}))];
    const allLinks = [...A.links.map(l=>({l, side:"A"})), ...B.links.map(l=>({l, side:"B"}))];

    const linkSel = linkLayer.selectAll("path.link")
      .data(allLinks, x => x.l.target.data._id);

    linkSel.enter().append("path")
      .attr("class","link")
      .attr("d", x => {
        const o = {x: x.l.source.x, y: x.l.source.y};
        return linkVertical({source:o, target:o});
      })
      .merge(linkSel)
      .transition().duration(220)
      .attr("d", x => linkVertical(x.l));

    linkSel.exit().transition().duration(180).attr("opacity",0).remove();

    const nodeSel = nodeLayer.selectAll("g.node")
      .data(allNodes, x => x.d.data._id);

    const nodeEnter = nodeSel.enter().append("g")
      .attr("class","node")
      .attr("transform", x => `translate(${x.d.x},${x.d.y})`)
      .on("click", (_, x) => {
        const d = x.d;
        if (d.children){ d._children = d.children; d.children = null; }
        else { d.children = d._children; d._children = null; }
        updateFn();
        applySearchHighlight();
      })
      .on("mouseenter", (evt, x) => {
        const d = x.d.data;
        // agora: sem "Subontologia:" -> tooltip mostra s√≥ o nome do grupo
        showTooltip(evt, { name: d.name, group: (d.group==="Raiz"?"":d.group), comment: d.comment, obs: d.obs });
      })
      .on("mousemove", (evt) => moveTooltip(evt))
      .on("mouseleave", () => hideTooltip());

    nodeEnter.each(function(x){
      const d = x.d;
      const isB = (x.side === "B");
      const g = d3.select(this);

      const lines = wrapLabel(d.data.name, 28);
      const hasKids = (d.children || d._children);

      const w = 360;
      const h = lines.length === 1 ? 50 : 66;

      const bg = isB ? fillB : fillA;
      const fg = isB ? textB : textA;

      g.append("rect")
        .attr("x", -w/2).attr("y", 0)
        .attr("width", w).attr("height", h)
        .attr("fill", bg)
        .attr("stroke", taxColor)
        .attr("stroke-width", d.data.group === "Raiz" ? 2.6 : 1.5);

      const t = g.append("text")
        .attr("class","name")
        .attr("text-anchor","middle")
        .attr("fill", fg)
        .attr("x", 0).attr("y", 22);

      if (lines.length === 1){
        t.text(lines[0]);
      } else {
        t.append("tspan").attr("x",0).attr("dy",0).text(lines[0]);
        t.append("tspan").attr("x",0).attr("dy",16).text(lines[1]);
      }

      // ‚úÖ aqui √© a mudan√ßa: remove "Subontologia:" e deixa s√≥ o nome do grupo
      // (e n√£o mostra nada para "Raiz")
      const groupText = (d.data.group && d.data.group !== "Raiz") ? d.data.group : "";
      g.append("text")
        .attr("class","small")
        .attr("text-anchor","middle")
        .attr("fill", fg)
        .attr("x", 0).attr("y", h - 10)
        .text(groupText);

      g.append("text")
        .attr("class","small")
        .attr("fill", fg)
        .attr("x", w/2 - 10).attr("y", 18)
        .attr("text-anchor","end")
        .text(hasKids ? (d.children ? "‚ñæ" : "‚ñ∏") : "");
    });

    nodeSel.merge(nodeEnter)
      .transition().duration(220)
      .attr("transform", x => `translate(${x.d.x},${x.d.y})`);

    nodeSel.exit().transition().duration(180).attr("opacity",0).remove();
  };

  updateFn();

  fitToCanvasFn = (strong=true) => {
    if (!viewport) return;
    const bounds = viewport.node().getBBox();
    const svgEl2 = svg.node();
    const w = svgEl2.clientWidth || 800;
    const h = svgEl2.clientHeight || 600;
    const pad = 40;

    const bw = bounds.width + pad*2;
    const bh = bounds.height + pad*2;
    const scale = Math.min(3.0, Math.max(0.10, Math.min(w/bw, h/bh)));

    const tx = (w - bounds.width*scale)/2 - bounds.x*scale;
    const ty = (h - bounds.height*scale)/2 - bounds.y*scale;

    svg.transition().duration(strong ? 380 : 220).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
  };

  fitToCanvasFn(true);
  applySearchHighlight();
}

/* ======= Search highlight ======= */
function applySearchHighlight(){
  const q = norm(searchEl.value);
  svg.selectAll("g.node").classed("node--match", false);
  if (!q) return;

  svg.selectAll("g.node").each(function(){
    const datum = d3.select(this).datum();
    if (!datum || !datum.d) return;
    if (norm(datum.d.data.name).includes(q)){
      d3.select(this).classed("node--match", true);
    }
  });
}

/* ======= Export SVG / PNG ======= */
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=> URL.revokeObjectURL(url), 1000);
}
function getExportName(ext){
  const t = CURRENT?.label ? CURRENT.label.replace(/\s+/g,"_") : "Taxonomia";
  const a = (CURRENT?.selA || "A").replace(/[^\w\-]+/g,"_");
  const b = (CURRENT?.selB || "B").replace(/[^\w\-]+/g,"_");
  return `${t}_${a}__${b}.${ext}`;
}
function serializeSvgForExport(){
  const svgNode = svg.node();
  const clone = svgNode.cloneNode(true);

  clone.setAttribute("xmlns","http://www.w3.org/2000/svg");
  const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
  bg.setAttribute("x","0"); bg.setAttribute("y","0");
  bg.setAttribute("width","100%"); bg.setAttribute("height","100%");
  bg.setAttribute("fill","#ffffff");
  clone.insertBefore(bg, clone.firstChild);

  const bbox = viewport?.node()?.getBBox?.();
  if (bbox){
    const pad = 30;
    const x = bbox.x - pad, y = bbox.y - pad, w = bbox.width + pad*2, h = bbox.height + pad*2;
    clone.setAttribute("viewBox", `${x} ${y} ${w} ${h}`);
    clone.setAttribute("width", String(Math.round(w)));
    clone.setAttribute("height", String(Math.round(h)));
  }
  return new XMLSerializer().serializeToString(clone);
}

btnSvg.addEventListener("click", () => {
  try{
    const xml = serializeSvgForExport();
    downloadBlob(new Blob([xml], {type:"image/svg+xml;charset=utf-8"}), getExportName("svg"));
  } catch(e){ toast("Falha ao exportar SVG: " + e.message, true); }
});

btnPng.addEventListener("click", async () => {
  try{
    const scale = parseInt(pngScaleSel.value || "3", 10);
    const xml = serializeSvgForExport();
    const svgBlob = new Blob([xml], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(svgBlob);

    const img = new Image();
    img.decoding = "async";
    img.src = url;

    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = () => reject(new Error("N√£o foi poss√≠vel renderizar o SVG para PNG."));
    });

    // derive export size from bbox
    const bbox = viewport?.node()?.getBBox?.();
    const w = Math.max(1200, (bbox?.width || 1600) + 80);
    const h = Math.max(800,  (bbox?.height || 900) + 80);

    const canvas = document.createElement("canvas");
    canvas.width = Math.round(w * scale);
    canvas.height = Math.round(h * scale);
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.setTransform(scale,0,0,scale,0,0);
    ctx.drawImage(img, 0, 0);

    URL.revokeObjectURL(url);

    canvas.toBlob((blob)=>{
      if (!blob) return toast("Falha ao gerar PNG.", true);
      downloadBlob(blob, getExportName("png"));
    }, "image/png", 1.0);

  } catch(e){
    toast("Falha ao exportar PNG: " + e.message, true);
  }
});

/* ======= Init buttons ======= */
btnApplyPair.addEventListener("click", () => { if (RAW) applyTaxonomy(); });
btnApplyRoots.addEventListener("click", () => { if (RAW) applyTaxonomy(); });

/* ======= Auto-load XLSX ======= */
(async function(){
  try{ await loadDefault(); } catch(_) {}
})();
</script>
</body>
</html>
