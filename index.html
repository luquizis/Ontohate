<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ontohate V2 ‚Äî Taxonomia (XLSX ‚Üí √Årvore)</title>

  <!-- D3 -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

  <!-- SheetJS (xlsx parser) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14; --panel:#111826; --text:#e6edf3; --muted:#9aa4b2; --line:rgba(255,255,255,.10);
      --chip:rgba(255,255,255,.08); --warn:#f7c97a; --bad:#ff6b6b;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    header{
      position:sticky; top:0; z-index:10;
      background:linear-gradient(180deg, rgba(11,15,20,.98), rgba(11,15,20,.85));
      border-bottom:1px solid var(--line);
      padding:12px 14px;
      display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:center;
    }
    .title{display:flex; flex-direction:column; gap:4px;}
    .title h1{margin:0; font-size:14px; font-weight:700;}
    .title .sub{font-size:12px; color:var(--muted);}
    .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end;}
    .btn,.file,.input{
      border:1px solid var(--line); background:var(--panel); color:var(--text);
      border-radius:10px; padding:8px 10px; font-size:12px; line-height:1;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn{cursor:pointer; user-select:none;}
    .btn:hover{border-color:rgba(255,255,255,.22);}
    .file input[type="file"]{display:none;}
    .input input{border:none; outline:none; background:transparent; color:var(--text); width:240px; font-size:12px;}
    .chip{background:var(--chip); border:1px solid var(--line); border-radius:999px; padding:6px 10px; font-size:12px; color:var(--muted); white-space:nowrap;}
    #wrap{height:calc(100% - 66px);}
    svg{width:100%; height:100%; display:block;}

    .link{fill:none; stroke:rgba(255,255,255,.16); stroke-width:1.2;}
    .node rect{fill:rgba(255,255,255,.06); stroke:rgba(255,255,255,.16); stroke-width:1; rx:10; ry:10;}
    .node text{font-size:12px; fill:var(--text); pointer-events:none;}
    .node .small{font-size:10px; fill:var(--muted);}
    .node--match rect{stroke:var(--warn); stroke-width:2;}

    .toast{
      position:fixed; left:14px; bottom:14px; z-index:50;
      background:rgba(17,24,38,.92); border:1px solid var(--line);
      padding:10px 12px; border-radius:12px; font-size:12px; color:var(--muted);
      max-width:min(820px, calc(100% - 28px)); white-space:pre-wrap;
    }
    .toast.bad{border-color:rgba(255,107,107,.55); color:#ffdede;}
    .legend{
      position:fixed; right:14px; bottom:14px; z-index:40;
      background:rgba(17,24,38,.92); border:1px solid var(--line);
      padding:10px 12px; border-radius:12px; font-size:12px; color:var(--muted);
      max-width:520px;
    }
    .legend b{color:var(--text);}
    .swatch{display:inline-block; width:10px; height:10px; border-radius:3px; margin-right:8px; vertical-align:middle; border:1px solid rgba(255,255,255,.18);}
    .legend ul{margin:8px 0 0 0; padding:0; list-style:none; display:grid; grid-template-columns: 1fr; gap:6px;}
    @media(min-width: 880px){ .legend ul{grid-template-columns: 1fr 1fr;} }
    code{color:#cbd5e1}
  </style>
</head>
<body>

<header>
  <div class="title">
    <h1>Ontohate V2 ‚Äî Taxonomia a partir do XLSX</h1>
    <div class="sub">
      Gera a √°rvore usando <code>Classe</code> ‚Üí <code>Superclasse</code> (todas as abas).
      Desconectadas entram como ra√≠zes sob <code>ONTOHATE (Taxonomia)</code>.
    </div>
  </div>

  <div class="controls">
    <label class="file btn" title="Carregar Ontohate_V2.xlsx do computador">
      üìÑ Carregar XLSX
      <input id="fileInput" type="file" accept=".xlsx,.xls" />
    </label>

    <div class="btn" id="btnLoadDefault" title="Carregar Ontohate_V2.xlsx do mesmo diret√≥rio do index.html">
      ‚¨áÔ∏è Carregar Ontohate_V2.xlsx
    </div>

    <div class="input" title="Buscar classe pelo nome">
      üîé <input id="search" placeholder="Buscar (ex.: Discurso_de_√≥dio_online)" />
    </div>

    <div class="btn" id="btnExpandAll">‚ûï Expandir</div>
    <div class="btn" id="btnCollapseAll">‚ûñ Recolher</div>

    <span class="chip" id="stats">Classes: ‚Äî | Rela√ß√µes: ‚Äî | Abas: ‚Äî</span>
  </div>
</header>

<div id="wrap"><svg id="svg"></svg></div>

<div class="legend" id="legend">
  <div><b>Legenda (Subontologia)</b></div>
  <ul id="legendList"></ul>
  <div style="margin-top:8px;">‚Ä¢ Arraste para mover, roda do mouse para zoom. ‚Ä¢ Clique no n√≥ para expandir/recolher.</div>
</div>

<div class="toast" id="toast" style="display:none;"></div>

<script>
  // UI
  const svg = d3.select("#svg");
  const toastEl = document.getElementById("toast");
  const statsEl = document.getElementById("stats");
  const searchEl = document.getElementById("search");
  const fileInput = document.getElementById("fileInput");
  const legendList = document.getElementById("legendList");

  function toast(msg, isBad=false){
    toastEl.textContent = msg;
    toastEl.classList.toggle("bad", !!isBad);
    toastEl.style.display = "block";
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=> toastEl.style.display="none", 9000);
  }

  // Single zoom (stable on GitHub Pages)
  const zoom = d3.zoom()
    .scaleExtent([0.15, 2.5])
    .on("zoom", (event) => {
      svg.select("g#viewport").attr("transform", event.transform);
    });

  let root = null;
  let viewport = null;
  let nodeLayer = null;
  let treeUpdate = null;
  let expandAllFn = null;
  let collapseAllFn = null;

  document.getElementById("btnLoadDefault").addEventListener("click", () => loadDefault());
  fileInput.addEventListener("change", async (ev) => {
    const f = ev.target.files?.[0];
    if (!f) return;
    const buf = await f.arrayBuffer();
    await buildFromXlsxArrayBuffer(buf, f.name);
  });

  document.getElementById("btnExpandAll").addEventListener("click", () => {
    if (!root || !expandAllFn || !treeUpdate) return;
    expandAllFn(root);
    treeUpdate(root);
    applySearchHighlight();
  });

  document.getElementById("btnCollapseAll").addEventListener("click", () => {
    if (!root || !collapseAllFn || !treeUpdate) return;
    collapseAllFn(root);
    treeUpdate(root);
    applySearchHighlight();
  });

  searchEl.addEventListener("input", () => applySearchHighlight());

  // Color palette per Subontologia (deterministic)
  function hashString(str){
    let h = 2166136261;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }
  function colorForGroup(group){
    const g = (group || "Sem subontologia").trim();
    const h = hashString(g);
    const hue = h % 360;
    const sat = 62;
    const light = 58;
    return `hsl(${hue} ${sat}% ${light}%)`;
  }

  async function loadDefault(){
    const url = "Ontohate_V2.xlsx"; // must match exactly on GitHub Pages
    try{
      const res = await fetch(url, { cache:"no-store" });
      if (!res.ok){
        throw new Error(
          `N√£o encontrei ${url} (HTTP ${res.status}).\n` +
          `No GitHub Pages: coloque index.html e Ontohate_V2.xlsx na MESMA pasta publicada (ex.: /docs)\n` +
          `e confira o nome exatamente (mai√∫sculas/min√∫sculas contam).`
        );
      }
      const buf = await res.arrayBuffer();
      await buildFromXlsxArrayBuffer(buf, url);
    } catch(e){
      toast("Erro ao carregar XLSX padr√£o:\n" + e.message, true);
    }
  }

  function normalizeKey(k){
    return String(k || "").trim().toLowerCase();
  }

  function pick(row, wanted){
    // wanted: array of possible header names (case-insensitive)
    const keys = Object.keys(row || {});
    const map = new Map(keys.map(k => [normalizeKey(k), k]));
    for (const w of wanted){
      const k = map.get(normalizeKey(w));
      if (k != null) return row[k];
    }
    return undefined;
  }

  async function buildFromXlsxArrayBuffer(buf, filename){
    let wb;
    try{
      wb = XLSX.read(buf, { type:"array" });
    } catch(e){
      toast("Falha ao ler o XLSX:\n" + e.message, true);
      return;
    }

    const sheetNames = wb.SheetNames || [];
    if (!sheetNames.length){
      toast("XLSX sem abas.", true);
      return;
    }

    // Collect rows from all sheets
    const rows = [];
    for (const sname of sheetNames){
      const ws = wb.Sheets[sname];
      if (!ws) continue;
      const json = XLSX.utils.sheet_to_json(ws, { defval:"" });
      for (const r of json){
        rows.push({ __sheet: sname, ...r });
      }
    }

    // Expect columns: Classe, Superclasse, Subontologia, Descri√ß√£o principal, Complemento, Observa√ß√£o
    // We'll be forgiving with header variants.
    const edges = []; // [child, parent]
    const nodes = new Map(); // name -> {name, group, desc, sheet}
    const groups = new Set();

    function ensureNode(name, data={}){
      const n = String(name || "").trim();
      if (!n) return null;
      if (!nodes.has(n)){
        nodes.set(n, {
          name: n,
          group: data.group || "",
          desc: data.desc || "",
          sheet: data.sheet || ""
        });
      } else {
        // merge only if missing
        const cur = nodes.get(n);
        if (!cur.group && data.group) cur.group = data.group;
        if (!cur.desc && data.desc) cur.desc = data.desc;
        if (!cur.sheet && data.sheet) cur.sheet = data.sheet;
      }
      if (nodes.get(n).group) groups.add(nodes.get(n).group);
      return n;
    }

    let usedRows = 0;
    for (const r of rows){
      const child = pick(r, ["Classe", "Class", "classe"]);
      const parent = pick(r, ["Superclasse", "Superclasse ", "Superclass", "superclasse"]);
      const group  = pick(r, ["Subontologia", "Subontologia ", "Sub-ontologia", "Subontology"]);
      const d1     = pick(r, ["Descri√ß√£o principal", "Descricao principal", "Descri√ß√£o", "Descricao"]);
      const d2     = pick(r, ["Complemento", "Complemento "]);
      const d3     = pick(r, ["Observa√ß√£o", "Observacao"]);

      const c = String(child || "").trim();
      if (!c) continue;

      const p = String(parent || "").trim();
      const g = String(group || "").trim();

      const descParts = [d1, d2, d3].map(x => String(x||"").trim()).filter(Boolean);
      const desc = descParts.join(" ");

      ensureNode(c, { group: g, desc, sheet: r.__sheet });
      if (p) ensureNode(p, { group: "", desc: "", sheet: "" });

      if (p){
        edges.push([c, p]);
      }
      usedRows++;
    }

    if (!usedRows || nodes.size === 0){
      toast(
        "N√£o encontrei linhas com a coluna 'Classe'.\n" +
        "Verifique se a planilha tem cabe√ßalhos como: Classe | Superclasse | Subontologia.",
        true
      );
      return;
    }

    // Remove duplicate edges
    const edgeKey = new Set();
    const edgesUniq = [];
    for (const [c,p] of edges){
      const k = c + "‚Üí" + p;
      if (!edgeKey.has(k)){
        edgeKey.add(k);
        edgesUniq.push([c,p]);
      }
    }

    // parentsOf child -> parent (single parent assumed; if multiple appear, we keep all by cloning)
    const parentsOf = new Map(); // child -> Set(parent)
    for (const [c,p] of edgesUniq){
      if (!parentsOf.has(c)) parentsOf.set(c, new Set());
      parentsOf.get(c).add(p);
    }

    // Build child adjacency: parent -> children
    const childrenOf = new Map();
    for (const [c,p] of edgesUniq){
      if (!childrenOf.has(p)) childrenOf.set(p, []);
      childrenOf.get(p).push(c);
    }
    for (const [p, kids] of childrenOf.entries()){
      kids.sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));
    }

    // Identify roots: nodes that have no parent
    const allNames = Array.from(nodes.keys());
    const hasParent = new Set(Array.from(parentsOf.keys()));
    const roots = [];
    for (const n of allNames){
      const ps = parentsOf.get(n);
      if (!ps || ps.size === 0) roots.push(n);
    }
    roots.sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));

    // Build forest root
    const forest = {
      name: "ONTOHATE (Taxonomia)",
      group: "Raiz",
      desc: "Raiz sint√©tica para organizar todas as classes e garantir cobertura total.",
      children: []
    };

    // clone builder (handles multiple parents safely)
    let idCounter = 0;
    function buildSubtree(name, stack=new Set()){
      const base = nodes.get(name) || { name, group:"", desc:"", sheet:"" };
      const node = {
        name: base.name,
        group: base.group || "",
        desc: base.desc || "",
        sheet: base.sheet || "",
        _id: ++idCounter,
        children: []
      };

      if (stack.has(name)) return node;
      stack.add(name);

      const kids = (childrenOf.get(name) || []);
      for (const k of kids){
        node.children.push(buildSubtree(k, new Set(stack)));
      }
      return node;
    }

    // Attach all roots
    for (const r of roots){
      forest.children.push(buildSubtree(r));
    }

    // Render + legend
    statsEl.textContent = `Classes: ${nodes.size} | Rela√ß√µes: ${edgesUniq.length} | Abas: ${sheetNames.length}`;
    renderLegend(Array.from(groups).sort((a,b)=> a.localeCompare(b)));
    renderTree(forest);

    toast(
      `Carregado: ${filename}\n` +
      `Abas: ${sheetNames.length}\n` +
      `Classes: ${nodes.size}\n` +
      `Rela√ß√µes (Classe‚ÜíSuperclasse): ${edgesUniq.length}\n\n` +
      `Obs.: superclasses sem linha pr√≥pria na planilha tamb√©m viram n√≥s (para n√£o perder nada).`
    );
  }

  function renderLegend(groupList){
    legendList.innerHTML = "";
    // Always include "Sem subontologia" if any node has empty group (common for superclasses criadas)
    const extra = ["Sem subontologia"];
    const finalList = [...groupList];
    if (!finalList.includes("Sem subontologia")) finalList.push("Sem subontologia");
    // Root
    if (!finalList.includes("Raiz")) finalList.unshift("Raiz");

    for (const g of finalList){
      const li = document.createElement("li");
      const sw = document.createElement("span");
      sw.className = "swatch";
      sw.style.background = (g === "Raiz") ? "hsl(210 15% 55%)" : colorForGroup(g);
      li.appendChild(sw);
      const txt = document.createElement("span");
      txt.textContent = g;
      li.appendChild(txt);
      legendList.appendChild(li);
    }
  }

  function renderTree(data){
    svg.selectAll("*").remove();
    viewport = svg.append("g").attr("id","viewport");
    svg.call(zoom);
    svg.call(zoom.transform, d3.zoomIdentity.translate(20, 20).scale(1));

    const tree = d3.tree().nodeSize([34, 240]);
    root = d3.hierarchy(data);
    root.x0 = 0; root.y0 = 0;

    // Collapse deeper than 2 levels initially
    root.children?.forEach(c => c.children?.forEach(cc => collapse(cc)));

    const linkLayer = viewport.append("g");
    nodeLayer = viewport.append("g");

    function collapse(d){
      if (d.children){
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
      }
    }

    expandAllFn = function expandAll(d){
      if (d._children){ d.children = d._children; d._children = null; }
      (d.children||[]).forEach(expandAll);
    };

    collapseAllFn = function collapseAll(d){
      // keep root open, collapse below depth 1
      (d.children||[]).forEach(collapseAll);
      if (d.depth >= 2) collapse(d);
    };

    function diagonal(d){
      return d3.linkHorizontal().x(d=>d.y).y(d=>d.x)(d);
    }

    treeUpdate = function update(source){
      tree(root);
      const nodes = root.descendants();
      const links = root.links();

      // Links
      const link = linkLayer.selectAll("path.link")
        .data(links, d => d.target.data._id);

      link.enter().append("path")
        .attr("class","link")
        .attr("d", d => {
          const o = { x: source.x0, y: source.y0 };
          return diagonal({ source:o, target:o });
        })
        .merge(link)
        .transition().duration(200)
        .attr("d", diagonal);

      link.exit().transition().duration(200).attr("opacity",0).remove();

      // Nodes
      const node = nodeLayer.selectAll("g.node")
        .data(nodes, d => d.data._id);

      const nodeEnter = node.enter().append("g")
        .attr("class","node")
        .attr("transform", `translate(${source.y0},${source.x0})`)
        .on("click", (_, d) => {
          if (d.children){ d._children = d.children; d.children = null; }
          else { d.children = d._children; d._children = null; }
          treeUpdate(d);
          applySearchHighlight();
        });

      nodeEnter.append("rect")
        .attr("x", 0).attr("y", -18)
        .attr("width", 360).attr("height", 36);

      nodeEnter.append("text")
        .attr("x", 12).attr("y", -2)
        .text(d => d.data.name || "(sem nome)");

      nodeEnter.append("text")
        .attr("class","small")
        .attr("x", 12).attr("y", 14)
        .text(d => {
          const g = (d.data.group || "").trim();
          const s = (d.data.sheet || "").trim();
          const left = g ? `Subontologia: ${g}` : "Sem subontologia";
          const right = s ? ` | Aba: ${s}` : "";
          return left + right;
        });

      nodeEnter.append("text")
        .attr("x", 330).attr("y", -2)
        .attr("text-anchor","end")
        .attr("class","small")
        .text(d => (d.children || d._children) ? (d.children ? "‚ñæ" : "‚ñ∏") : "");

      const nodeMerge = nodeEnter.merge(node);

      nodeMerge.transition().duration(200)
        .attr("transform", d => `translate(${d.y},${d.x})`);

      // Color by group
      nodeMerge.select("rect")
        .attr("stroke", d => {
          const g = (d.data.group || "").trim() || "Sem subontologia";
          if (g === "Raiz") return "rgba(255,255,255,.22)";
          return colorForGroup(g);
        })
        .attr("stroke-width", d => (d.data.group || "").trim() ? 2 : 1);

      nodeMerge.select("rect")
        .attr("width", d => Math.min(560, 170 + ((d.data.name||"").length)*7));

      nodeMerge.select("text:nth-of-type(3)")
        .text(d => (d.children || d._children) ? (d.children ? "‚ñæ" : "‚ñ∏") : "");

      node.exit().transition().duration(200).attr("opacity",0).remove();

      nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
    };

    treeUpdate(root);
  }

  function applySearchHighlight(){
    if (!nodeLayer) return;
    const q = (searchEl.value || "").trim().toLowerCase();
    nodeLayer.selectAll("g.node").classed("node--match", false);
    if (!q) return;

    nodeLayer.selectAll("g.node").each(function(d){
      const name = (d.data.name || "").toLowerCase();
      if (name.includes(q)){
        d3.select(this).classed("node--match", true);
      }
    });
  }

  // Auto-load (GitHub Pages)
  (async function(){
    try{ await loadDefault(); } catch(_) {}
  })();
</script>
</body>
</html>
