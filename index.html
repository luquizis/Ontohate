<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Taxonomia do Discurso de Ódio Online</title>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/rdflib@2.2.37/dist/rdflib.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --panel:#121c2f;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --stroke:#24324f;
      --accent:#60a5fa;
      --danger:#fb7185;
      --ok:#34d399;

      --nodeText:#e5e7eb;
      --nodeStroke: rgba(0,0,0,0.35);
      --link:#94a3b8;
    }

    /* Tema CLARO */
    [data-theme="light"]{
      --bg:#ffffff;
      --panel:#f7fafc;
      --panel2:#ffffff;
      --text:#0f172a;
      --muted:#475569;
      --stroke:#e2e8f0;
      --accent:#2563eb;
      --danger:#e11d48;
      --ok:#16a34a;

      --nodeText:#0f172a;
      --nodeStroke: rgba(15,23,42,0.18);
      --link:#334155;
    }

    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    body{background:var(--bg); color:var(--text); overflow:hidden;}
    .app{display:grid; grid-template-columns: 400px 1fr; height:100%;}
    .sidebar{
      background:linear-gradient(180deg, color-mix(in srgb, var(--panel) 88%, transparent), color-mix(in srgb, var(--panel2) 88%, transparent));
      border-right:1px solid var(--stroke);
      padding:14px;
      overflow:auto;
    }
    .main{position:relative;}
    .topbar{
      position:absolute; left:0; right:0; top:0;
      display:flex; gap:10px; align-items:center;
      padding:10px 12px;
      background:color-mix(in srgb, var(--panel2) 80%, transparent);
      backdrop-filter: blur(8px);
      border-bottom:1px solid var(--stroke);
      z-index:10;
      flex-wrap:wrap;
    }
    .card{
      background:color-mix(in srgb, var(--panel) 92%, transparent);
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:12px;
      margin-bottom:12px;
      box-shadow: 0 8px 26px rgba(0,0,0,0.10);
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .col{display:flex; flex-direction:column; gap:6px;}
    label{font-size:12px; color:var(--muted);}
    input[type="text"], select{
      width:100%;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:color-mix(in srgb, var(--bg) 88%, transparent);
      color:var(--text);
      outline:none;
    }
    input[type="color"]{
      width:34px; height:34px; border:none; background:transparent; padding:0;
    }
    input[type="range"]{width:170px}
    button{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:color-mix(in srgb, var(--accent) 12%, transparent);
      color:var(--text);
      cursor:pointer;
    }
    button:hover{border-color:color-mix(in srgb, var(--accent) 55%, var(--stroke))}
    button.primary{background:color-mix(in srgb, var(--accent) 22%, transparent); border-color:color-mix(in srgb, var(--accent) 55%, var(--stroke))}
    button.ghost{background:color-mix(in srgb, var(--bg) 70%, transparent)}
    button.danger{background:color-mix(in srgb, var(--danger) 14%, transparent); border-color:color-mix(in srgb, var(--danger) 55%, var(--stroke))}
    .small{font-size:12px; color:var(--muted); line-height:1.35}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid var(--stroke);
      background:color-mix(in srgb, var(--bg) 75%, transparent);
      padding:8px 10px; border-radius:999px;
    }
    .status{font-size:12px; color:var(--muted);}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:11px; padding:2px 6px; border-radius:8px;
      border:1px solid var(--stroke);
      background:color-mix(in srgb, var(--bg) 70%, transparent);
      color:var(--text);
    }

    .dims{display:flex; flex-direction:column; gap:8px; margin-top:8px;}
    .dimItem{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border:1px solid var(--stroke);
      border-radius:14px;
      background:color-mix(in srgb, var(--bg) 72%, transparent);
    }
    .dimLeft{display:flex; align-items:center; gap:10px; min-width:0;}
    .dimName{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-size:13px;}

    #svgWrap{position:absolute; inset:0; padding-top:70px;}
    svg{width:100%; height:100%; display:block;}

    .node rect{
      rx:10; ry:10;
      stroke: var(--nodeStroke);
      stroke-width:1;
      filter: drop-shadow(0px 6px 14px rgba(0,0,0,0.18));
    }
    [data-theme="light"] .node rect{
      filter: drop-shadow(0px 6px 14px rgba(15,23,42,0.10));
    }

    .node text{
      font-size:12px;
      pointer-events:none;
      fill: var(--nodeText);
    }
    .node.selected rect{
      stroke: color-mix(in srgb, var(--accent) 85%, #ffffff);
      stroke-width:2.2;
      filter: drop-shadow(0px 8px 18px color-mix(in srgb, var(--accent) 25%, transparent));
    }

    .link{
      fill:none;
      stroke: var(--link);
      stroke-width:1.8;
      opacity:0.65;
    }

    .tooltip{
      position:absolute;
      max-width: 420px;
      pointer-events:none;
      background:color-mix(in srgb, var(--panel2) 92%, transparent);
      border:1px solid var(--stroke);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-size:12px;
      line-height:1.35;
      box-shadow: 0 10px 30px rgba(0,0,0,0.18);
      z-index:50;
    }
    .tooltip .tTitle{font-weight:800; font-size:13px;}
    .tooltip .tMeta{color:var(--muted)}
    .tooltip hr{border:none; border-top:1px solid var(--stroke); margin:8px 0;}

    .searchResults{
      margin-top:8px;
      border:1px solid var(--stroke);
      border-radius:14px;
      overflow:hidden;
      background:color-mix(in srgb, var(--bg) 80%, transparent);
    }
    .searchItem{
      padding:8px 10px;
      border-top:1px solid var(--stroke);
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      gap:12px;
    }
    .searchItem:hover{background:color-mix(in srgb, var(--accent) 10%, transparent)}
    .searchItem:first-child{border-top:none}
    .tag{font-size:11px; color:var(--muted); white-space:nowrap;}
  </style>
</head>

<body data-theme="dark">
<div class="app">
  <aside class="sidebar">
    <div class="card">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
        <div>
          <div style="font-weight:900; font-size:16px;">Taxonomia do Discurso de Ódio Online</div>
          <div class="small">
            Ferramenta interativa para explorar dimensões e subclasses, gerando taxonomias personalizadas para análise e documentação.
          </div>
        </div>
        <div class="pill"><span class="status" id="loadStatus">pronto</span></div>
      </div>

      <div class="small" style="margin-top:10px;">
        <b>Como usar (rápido):</b><br/>
        1) Selecione <b>dimensões</b> → a taxonomia se forma automaticamente.<br/>
        2) <span class="kbd">Alt</span> + clique no nó para <b>abrir/fechar</b> subclasses.<br/>
        3) Clique no nó para <b>editar</b> (nome, tamanho, cor).<br/>
        4) Escolha layout (Top-down / L→R / Radial / A4) e exporte (SVG/PNG).
      </div>

      <div class="row" style="margin-top:10px;">
        <div class="pill">
          <span class="status">Tema:</span>
          <button class="ghost" id="btnTheme">Escuro</button>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="col">
        <label>Fonte de dados (arquivo do repositório)</label>
        <input id="dataUrl" type="text" />
        <div class="row">
          <button class="primary" id="btnLoad">Carregar dados</button>
          <button class="ghost" id="btnFit">Ajustar na tela</button>
          <button class="danger" id="btnReset">Reset</button>
        </div>
        <div class="small">
          Dica: mantenha o endereço “raw” do repositório.
        </div>
      </div>
    </div>

    <div class="card">
      <div class="col">
        <label>Busca por termo/classe</label>
        <input id="searchInput" type="text" placeholder="Digite parte do nome (ex.: natureza, ameaça, moderação…)" disabled />
        <div class="row">
          <button id="btnSearchClear" class="ghost" disabled>Limpar</button>
          <button id="btnSearchShowAll" class="ghost" disabled>Ver lista</button>
        </div>
        <div class="small">Clique no resultado para ir direto ao nó (quando ele estiver visível na taxonomia atual).</div>
        <div id="searchResults" class="searchResults" style="display:none;"></div>
      </div>
    </div>

    <div class="card">
      <div class="col">
        <label>Geração da taxonomia</label>

        <div class="row">
          <div class="col" style="flex:1;">
            <label>Modo de visualização do conjunto</label>
            <select id="splitMode" disabled>
              <option value="union">Unir dimensões selecionadas (uma árvore)</option>
              <option value="single">Uma dimensão por vez (quebra por partes)</option>
            </select>
          </div>

          <div class="col" style="flex:1;">
            <label>Dimensão ativa (modo “uma por vez”)</label>
            <select id="activeDim" disabled></select>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div class="col" style="flex:1;">
            <label>Quebra por profundidade (evita árvores gigantes)</label>
            <input id="maxDepth" type="range" min="1" max="12" value="6" disabled />
            <div class="small">Nível máximo atual: <span id="depthLabel">6</span></div>
          </div>
          <div class="col">
            <label>&nbsp;</label>
            <button id="btnMoreDepth" class="ghost" disabled>+1 nível</button>
          </div>
        </div>

        <div class="small" style="margin-top:10px;">
          <b>Quando a taxonomia ficar grande:</b> use “Uma dimensão por vez” e/ou reduza a profundidade.
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="col" style="flex:1;">
          <label>Dimensões (selecione 1+)</label>
          <div class="small">Cada dimensão tem uma cor. Selecione várias para compor a taxonomia.</div>
        </div>
        <div class="row">
          <button id="btnAll" disabled>Todas</button>
          <button id="btnNone" disabled>Nenhuma</button>
        </div>
      </div>
      <div class="dims" id="dimsList"></div>
    </div>

    <div class="card">
      <div class="col">
        <label>Layout e exportação</label>
        <select id="layoutSelect" disabled>
          <option value="topdown">Top-down</option>
          <option value="leftright">Esquerda → Direita</option>
          <option value="radial">Radial</option>
          <option value="a4">A4 (vertical)</option>
        </select>

        <div class="row" style="margin-top:10px;">
          <div class="col">
            <label>Curvatura das arestas</label>
            <input id="edgeCurve" type="range" min="0" max="100" value="25" disabled />
          </div>
          <div class="col">
            <label>Espessura</label>
            <input id="edgeWidth" type="range" min="1" max="6" value="2" disabled />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div class="col">
            <label>Cor das arestas</label>
            <input id="edgeColor" type="color" value="#94a3b8" disabled />
          </div>
          <div class="col">
            <label>Persistir alterações (navegador)</label>
            <select id="persistSelect">
              <option value="on" selected>Ligado</option>
              <option value="off">Desligado</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnExportSVG" disabled>Exportar SVG</button>
          <button id="btnExportPNG" disabled>Exportar PNG</button>
        </div>
      </div>
    </div>

    <div class="card" id="editorCard" style="opacity:0.55;">
      <div class="col">
        <label>Editor do nó selecionado</label>
        <div class="small" id="editorHint">Clique em um nó para editar.</div>

        <label style="margin-top:6px;">Nome (local)</label>
        <input id="edLabel" type="text" disabled />

        <div class="row" style="margin-top:8px;">
          <div class="col">
            <label>Cor (fill)</label>
            <input id="edFill" type="color" value="#64748b" disabled />
          </div>
          <div class="col">
            <label>Borda</label>
            <input id="edStroke" type="color" value="#111827" disabled />
          </div>
          <div class="col">
            <label>Opacidade</label>
            <input id="edOpacity" type="range" min="10" max="100" value="92" disabled />
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <div class="col">
            <label>Largura</label>
            <input id="edW" type="range" min="80" max="520" value="140" disabled />
          </div>
          <div class="col">
            <label>Altura</label>
            <input id="edH" type="range" min="22" max="90" value="30" disabled />
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <div class="col">
            <label>Fonte</label>
            <input id="edFont" type="range" min="10" max="18" value="12" disabled />
          </div>
          <div class="col">
            <label>Raio</label>
            <input id="edRadius" type="range" min="0" max="22" value="10" disabled />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnEditorApply" class="primary" disabled>Aplicar</button>
          <button id="btnEditorReset" class="ghost" disabled>Reset nó</button>
        </div>
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="topbar">
      <div class="pill"><span class="status" id="graphInfo">sem árvore</span></div>
      <div class="pill"><span class="status">Zoom: <span id="zoomInfo">100%</span></span></div>
      <div class="pill"><span class="status">Nós: <span id="nodeCount">0</span> • Arestas: <span id="edgeCount">0</span></span></div>
      <div class="pill"><span class="status">Selecionado: <span id="selInfo">—</span></span></div>
      <div style="margin-left:auto" class="pill">
        <span class="status"><span class="kbd">Alt</span>+clique abre/fecha • arrastar move</span>
      </div>
    </div>

    <div id="svgWrap">
      <svg id="svg"></svg>
      <div id="tooltip" class="tooltip" style="display:none;"></div>
    </div>
  </main>
</div>

<script>
/* =========================
   RDF
========================= */
const RDF  = $rdf.Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
const RDFS = $rdf.Namespace("http://www.w3.org/2000/01/rdf-schema#");
const OWL  = $rdf.Namespace("http://www.w3.org/2002/07/owl#");
const STORE = $rdf.graph();

/* =========================
   UI
========================= */
const ui = {
  btnTheme: document.getElementById("btnTheme"),

  dataUrl: document.getElementById("dataUrl"),
  btnLoad: document.getElementById("btnLoad"),
  btnFit: document.getElementById("btnFit"),
  btnReset: document.getElementById("btnReset"),
  loadStatus: document.getElementById("loadStatus"),

  searchInput: document.getElementById("searchInput"),
  btnSearchClear: document.getElementById("btnSearchClear"),
  btnSearchShowAll: document.getElementById("btnSearchShowAll"),
  searchResults: document.getElementById("searchResults"),

  splitMode: document.getElementById("splitMode"),
  activeDim: document.getElementById("activeDim"),
  maxDepth: document.getElementById("maxDepth"),
  depthLabel: document.getElementById("depthLabel"),
  btnMoreDepth: document.getElementById("btnMoreDepth"),

  dimsList: document.getElementById("dimsList"),
  btnAll: document.getElementById("btnAll"),
  btnNone: document.getElementById("btnNone"),

  layoutSelect: document.getElementById("layoutSelect"),
  edgeCurve: document.getElementById("edgeCurve"),
  edgeWidth: document.getElementById("edgeWidth"),
  edgeColor: document.getElementById("edgeColor"),
  persistSelect: document.getElementById("persistSelect"),

  btnExportSVG: document.getElementById("btnExportSVG"),
  btnExportPNG: document.getElementById("btnExportPNG"),

  editorCard: document.getElementById("editorCard"),
  editorHint: document.getElementById("editorHint"),
  edLabel: document.getElementById("edLabel"),
  edFill: document.getElementById("edFill"),
  edStroke: document.getElementById("edStroke"),
  edOpacity: document.getElementById("edOpacity"),
  edW: document.getElementById("edW"),
  edH: document.getElementById("edH"),
  edFont: document.getElementById("edFont"),
  edRadius: document.getElementById("edRadius"),
  btnEditorApply: document.getElementById("btnEditorApply"),
  btnEditorReset: document.getElementById("btnEditorReset"),

  graphInfo: document.getElementById("graphInfo"),
  zoomInfo: document.getElementById("zoomInfo"),
  nodeCount: document.getElementById("nodeCount"),
  edgeCount: document.getElementById("edgeCount"),
  selInfo: document.getElementById("selInfo"),
  tooltip: document.getElementById("tooltip")
};

const persistedKey = (suffix) => `hate_taxo_${suffix}`;

const defaultDimPalette = [
  "#60a5fa","#34d399","#fbbf24","#fb7185","#a78bfa",
  "#22c55e","#f472b6","#38bdf8","#f97316","#e879f9"
];

let state = {
  loaded:false,

  classNodes: new Map(),
  subclasses: new Map(),
  superclasses: new Map(),

  rootIri: null,
  dimensions: [],
  selectedDims: new Set(),
  collapsed: new Set(),

  customLabels: new Map(),
  nodePositions: new Map(),
  nodeStyles: new Map(),

  selectedIri: null,
  searchIndex: []
};

/* =========================
   SVG
========================= */
const svg = d3.select("#svg");
const wrap = document.getElementById("svgWrap");

const gRoot = svg.append("g").attr("class","gRoot");
const gLinks = gRoot.append("g").attr("class","links");
const gNodes = gRoot.append("g").attr("class","nodes");

let width=1000, height=800;

const zoom = d3.zoom()
  .scaleExtent([0.2, 3.5])
  .on("zoom", (event) => {
    gRoot.attr("transform", event.transform);
    ui.zoomInfo.textContent = Math.round(event.transform.k * 100) + "%";
  });

svg.call(zoom);

/* =========================
   Helpers
========================= */
function setStatus(text, ok=true){
  ui.loadStatus.textContent = text;
  ui.loadStatus.style.color = ok ? "var(--ok)" : "var(--danger)";
}
function persistEnabled(){ return ui.persistSelect.value === "on"; }
function uniq(arr){ return [...new Set(arr)]; }

function escapeHTML(s){
  return String(s)
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}
function shrinkIri(iri){
  try{
    const u = new URL(iri);
    const frag = u.hash ? u.hash.slice(1) : "";
    if (frag) return frag;
    const parts = u.pathname.split("/").filter(Boolean);
    return parts[parts.length-1] || iri;
  }catch(e){
    return iri;
  }
}
function getLiterals(subject, predicate){
  return STORE.each(subject, predicate, null).filter(o => o.termType==="Literal").map(o=>o.value);
}
function getFirstLiteral(subject, predicate){
  const lits = getLiterals(subject, predicate);
  return lits[0] || "";
}
function termLabel(iri){
  if (state.customLabels.has(iri)) return state.customLabels.get(iri);
  const node = state.classNodes.get(iri);
  return node?.label || shrinkIri(iri);
}

/* =========================
   Persist
========================= */
function loadPersisted(){
  if (!persistEnabled()) return;
  try{
    state.customLabels = new Map(Object.entries(JSON.parse(localStorage.getItem(persistedKey("labels")) || "{}")));
    state.collapsed = new Set(JSON.parse(localStorage.getItem(persistedKey("collapsed")) || "[]"));
    state.nodePositions = new Map(Object.entries(JSON.parse(localStorage.getItem(persistedKey("positions")) || "{}")).map(([k,v]) => [k, v]));
    state.nodeStyles = new Map(Object.entries(JSON.parse(localStorage.getItem(persistedKey("styles")) || "{}")).map(([k,v]) => [k, v]));
    const theme = localStorage.getItem(persistedKey("theme"));
    if (theme === "light" || theme === "dark") setTheme(theme, false);
  }catch(e){}
}
function savePersisted(){
  if (!persistEnabled()) return;
  try{
    localStorage.setItem(persistedKey("labels"), JSON.stringify(Object.fromEntries(state.customLabels)));
    localStorage.setItem(persistedKey("collapsed"), JSON.stringify([...state.collapsed]));
    localStorage.setItem(persistedKey("positions"), JSON.stringify(Object.fromEntries(state.nodePositions)));
    localStorage.setItem(persistedKey("styles"), JSON.stringify(Object.fromEntries(state.nodeStyles)));
  }catch(e){}
}
function clearPersisted(){
  localStorage.removeItem(persistedKey("labels"));
  localStorage.removeItem(persistedKey("collapsed"));
  localStorage.removeItem(persistedKey("positions"));
  localStorage.removeItem(persistedKey("styles"));
  localStorage.removeItem(persistedKey("dims"));
  localStorage.removeItem(persistedKey("theme"));
}

/* =========================
   Theme
========================= */
function setTheme(theme, persist=true){
  document.body.setAttribute("data-theme", theme);
  ui.btnTheme.textContent = theme === "dark" ? "Escuro" : "Claro";
  if (persist) localStorage.setItem(persistedKey("theme"), theme);
}
ui.btnTheme.addEventListener("click", () => {
  const cur = document.body.getAttribute("data-theme") || "dark";
  setTheme(cur === "dark" ? "light" : "dark");
  rebuildAndRender();
});

/* =========================
   Enable/disable controls
========================= */
function enableControls(enabled){
  ui.searchInput.disabled = !enabled;
  ui.btnSearchClear.disabled = !enabled;
  ui.btnSearchShowAll.disabled = !enabled;

  ui.splitMode.disabled = !enabled;
  ui.activeDim.disabled = !enabled;
  ui.maxDepth.disabled = !enabled;
  ui.btnMoreDepth.disabled = !enabled;

  ui.btnAll.disabled = !enabled;
  ui.btnNone.disabled = !enabled;

  ui.layoutSelect.disabled = !enabled;
  ui.edgeCurve.disabled = !enabled;
  ui.edgeWidth.disabled = !enabled;
  ui.edgeColor.disabled = !enabled;

  ui.btnExportSVG.disabled = !enabled;
  ui.btnExportPNG.disabled = !enabled;
}

/* =========================
   Load data
========================= */
async function loadData(url){
  setStatus("carregando dados…");
  ui.graphInfo.textContent = "carregando…";
  STORE.statements.length = 0;

  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`Falha HTTP ${res.status}`);
  const data = await res.text();

  const base = url;
  try{
    $rdf.parse(data, STORE, base, "application/rdf+xml");
  }catch(e1){
    try{
      $rdf.parse(data, STORE, base, "text/turtle");
    }catch(e2){
      throw new Error("Não consegui ler o arquivo. Verifique o formato do arquivo no repositório.");
    }
  }

  state.classNodes = new Map();
  state.subclasses = new Map();
  state.superclasses = new Map();
  state.dimensions = [];
  state.selectedDims = new Set();
  state.selectedIri = null;

  // Collect classes
  const classSet = new Set();
  STORE.each(null, RDF("type"), OWL("Class")).forEach(s => classSet.add(s.value));
  STORE.each(null, RDF("type"), RDFS("Class")).forEach(s => classSet.add(s.value));
  STORE.each(null, RDFS("subClassOf"), null).forEach(s => classSet.add(s.value));
  STORE.each(null, RDFS("subClassOf"), null).forEach(o => { if (o.termType === "NamedNode") classSet.add(o.value); });

  for (const iri of classSet){
    const s = $rdf.sym(iri);
    const label = getFirstLiteral(s, RDFS("label")) || getFirstLiteral(s, $rdf.sym("http://www.w3.org/2004/02/skos/core#prefLabel"));
    const comment = getLiterals(s, RDFS("comment"));
    state.classNodes.set(iri, { iri, label, comment });
    if (!state.subclasses.has(iri)) state.subclasses.set(iri, new Set());
    if (!state.superclasses.has(iri)) state.superclasses.set(iri, new Set());
  }

  // Named subclass links
  const subclassTriples = STORE.statementsMatching(null, RDFS("subClassOf"), null);
  for (const st of subclassTriples){
    const child = st.subject;
    const parent = st.object;
    if (child.termType !== "NamedNode") continue;
    const cIri = child.value;
    if (parent.termType === "NamedNode"){
      const pIri = parent.value;
      if (!state.subclasses.has(pIri)) state.subclasses.set(pIri, new Set());
      if (!state.superclasses.has(cIri)) state.superclasses.set(cIri, new Set());
      state.subclasses.get(pIri).add(cIri);
      state.superclasses.get(cIri).add(pIri);
    }
  }

  // Root candidate
  let root = null;
  const roots = [];
  for (const iri of state.classNodes.keys()){
    const supers = [...(state.superclasses.get(iri) || new Set())].filter(x => state.classNodes.has(x));
    if (supers.length === 0) roots.push(iri);
  }
  if (roots.length) root = roots[0];
  if (!root){
    root = [...state.classNodes.keys()].sort((a,b)=>{
      const da = (state.subclasses.get(a)||new Set()).size * 3 + (state.superclasses.get(a)||new Set()).size;
      const db = (state.subclasses.get(b)||new Set()).size * 3 + (state.superclasses.get(b)||new Set()).size;
      return db-da;
    })[0];
  }
  state.rootIri = root;

  buildDimensions();
  buildSearchIndex();

  state.loaded = true;
  enableControls(true);
  setStatus("carregado", true);
  ui.graphInfo.textContent = "taxonomia pronta (selecione dimensões)";
  rebuildAndRender();
}

/* =========================
   Dimensions
========================= */
function buildDimensions(){
  const kids = [...(state.subclasses.get(state.rootIri) || new Set())].filter(iri=>state.classNodes.has(iri));
  let dims = kids.map((iri, idx) => ({
    iri,
    label: termLabel(iri),
    color: defaultDimPalette[idx % defaultDimPalette.length]
  })).sort((a,b)=>a.label.localeCompare(b.label,"pt-BR"));

  // restore colors/selection
  if (persistEnabled()){
    try{
      const saved = JSON.parse(localStorage.getItem(persistedKey("dims")) || "{}");
      for (const d of dims){
        if (saved[d.iri]?.color) d.color = saved[d.iri].color;
      }
      state.selectedDims = new Set(Object.entries(saved).filter(([k,v])=>v.selected).map(([k])=>k));
    }catch(e){
      state.selectedDims = new Set();
    }
  }else{
    state.selectedDims = new Set();
  }

  state.dimensions = dims;

  // active dim selector
  ui.activeDim.innerHTML = "";
  for (const d of dims){
    const opt = document.createElement("option");
    opt.value = d.iri;
    opt.textContent = d.label;
    ui.activeDim.appendChild(opt);
  }
  if (dims.length) ui.activeDim.value = dims[0].iri;

  renderDimsList();
}

function saveDimsPersisted(){
  if (!persistEnabled()) return;
  const obj = {};
  for (const d of state.dimensions){
    obj[d.iri] = { color:d.color, selected: state.selectedDims.has(d.iri) };
  }
  localStorage.setItem(persistedKey("dims"), JSON.stringify(obj));
}

function renderDimsList(){
  ui.dimsList.innerHTML = "";
  if (!state.dimensions.length){
    ui.dimsList.innerHTML = `<div class="small">Nenhuma dimensão detectada.</div>`;
    return;
  }
  for (const dim of state.dimensions){
    const row = document.createElement("div");
    row.className = "dimItem";

    const left = document.createElement("div");
    left.className = "dimLeft";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = state.selectedDims.has(dim.iri);
    cb.addEventListener("change", () => {
      if (cb.checked) state.selectedDims.add(dim.iri);
      else state.selectedDims.delete(dim.iri);

      // se estiver em modo single, garantir apenas 1
      if (ui.splitMode.value === "single" && cb.checked){
        state.selectedDims = new Set([dim.iri]);
        ui.activeDim.value = dim.iri;
      }

      saveDimsPersisted();
      renderDimsList();
      rebuildAndRender();
    });

    const name = document.createElement("div");
    name.className = "dimName";
    name.textContent = dim.label;

    const right = document.createElement("div");
    right.className = "row";

    const color = document.createElement("input");
    color.type = "color";
    color.value = dim.color;
    color.addEventListener("input", () => {
      dim.color = color.value;
      saveDimsPersisted();
      rebuildAndRender();
    });

    left.appendChild(cb);
    left.appendChild(name);
    right.appendChild(color);
    row.appendChild(left);
    row.appendChild(right);
    ui.dimsList.appendChild(row);
  }
}

/* =========================
   Tree build (dedup + fix active dim)
========================= */
function getMaxDepth(){ return +ui.maxDepth.value; }

function buildSubtree(iri, depth, maxDepth, visited){
  if (visited.has(iri)) return null;  // DEDUP
  visited.add(iri);

  const kids = [...(state.subclasses.get(iri) || new Set())].filter(x=>state.classNodes.has(x));

  const isCollapsed = state.collapsed.has(iri);
  const hitDepthLimit = depth >= maxDepth;

  let children = [];
  if (!isCollapsed && !hitDepthLimit) {
    children = kids
      .map(k => buildSubtree(k, depth+1, maxDepth, visited))
      .filter(Boolean);
  }

  return { iri, depth, _hitDepthLimit: hitDepthLimit, children };
}

function buildTree(){
  const maxDepth = getMaxDepth();
  const selected = [...state.selectedDims];
  const mode = ui.splitMode.value;

  if (!selected.length){
    return { iri: state.rootIri, depth:0, children: [] };
  }

  if (mode === "single"){
    const dimIri = ui.activeDim.value && state.selectedDims.has(ui.activeDim.value)
      ? ui.activeDim.value
      : selected[0];

    const visitedSingle = new Set([state.rootIri]);
    const child = buildSubtree(dimIri, 1, maxDepth, visitedSingle);
    return { iri: state.rootIri, depth:0, children: child ? [child] : [] };
  }

  // union with global dedup
  const visited = new Set([state.rootIri]);
  const children = [];
  for (const dimIri of selected){
    const sub = buildSubtree(dimIri, 1, maxDepth, visited);
    if (sub) children.push(sub);
  }
  return { iri: state.rootIri, depth:0, children };
}

function flatten(tree){
  const nodes=[], links=[];
  function rec(n, parent=null){
    nodes.push(n);
    if (parent) links.push({source: parent, target: n});
    for (const ch of (n.children||[])) rec(ch, n);
  }
  rec(tree);
  return {nodes, links};
}

/* =========================
   Tooltip (mantido)
========================= */
function tooltipHTML(classIri){
  const s = $rdf.sym(classIri);

  const label = termLabel(classIri);
  const comments = uniq(getLiterals(s, RDFS("comment")));
  const supers = uniq([...(state.superclasses.get(classIri)||new Set())]).map(termLabel).sort();
  const subs = uniq([...(state.subclasses.get(classIri)||new Set())]).map(termLabel).sort();

  const objProps = STORE.each(null, RDF("type"), OWL("ObjectProperty")).map(x=>x.value);
  const dtProps  = STORE.each(null, RDF("type"), OWL("DatatypeProperty")).map(x=>x.value);

  const asDomainObj=[], asRangeObj=[], asDomainDt=[], asRangeDt=[];
  for (const pIri of objProps){
    const p = $rdf.sym(pIri);
    const domains = STORE.each(p, RDFS("domain"), null).filter(x=>x.termType==="NamedNode").map(x=>x.value);
    const ranges  = STORE.each(p, RDFS("range"), null).filter(x=>x.termType==="NamedNode").map(x=>x.value);
    if (domains.includes(classIri)) asDomainObj.push(pIri);
    if (ranges.includes(classIri)) asRangeObj.push(pIri);
  }
  for (const pIri of dtProps){
    const p = $rdf.sym(pIri);
    const domains = STORE.each(p, RDFS("domain"), null).filter(x=>x.termType==="NamedNode").map(x=>x.value);
    const ranges  = STORE.each(p, RDFS("range"), null).map(x=>x.value);
    if (domains.includes(classIri)) asDomainDt.push(pIri);
    if (ranges.includes(classIri)) asRangeDt.push(pIri);
  }

  function propLine(pIri){
    const p = $rdf.sym(pIri);
    const plabel = getFirstLiteral(p, RDFS("label")) || shrinkIri(pIri);
    return `${escapeHTML(plabel)} <span class="tMeta">(${escapeHTML(shrinkIri(pIri))})</span>`;
  }

  const parts = [];
  parts.push(`<div class="tTitle">${escapeHTML(label)}</div>`);
  parts.push(`<div class="tMeta">${escapeHTML(shrinkIri(classIri))}</div>`);

  const section = (title, items) => {
    if (!items?.length) return;
    parts.push(`<hr/>`);
    parts.push(`<div><b>${escapeHTML(title)}</b></div>`);
    parts.push(items.slice(0, 18).map(it => `<div>• ${it}</div>`).join(""));
    if (items.length > 18) parts.push(`<div class="tMeta">(+ ${items.length-18} itens)</div>`);
  };

  if (comments.length){
    parts.push(`<hr/><div><b>Descrição</b></div>`);
    parts.push(comments.slice(0,3).map(c=>`<div>${escapeHTML(c)}</div>`).join(""));
  }

  section("Termos acima (superclasses)", supers.map(x=>escapeHTML(x)));
  section("Termos abaixo (subclasses diretas)", subs.map(x=>escapeHTML(x)));

  section("Relações (ObjectProperties) onde este termo é Domain", asDomainObj.map(propLine));
  section("Relações (ObjectProperties) onde este termo é Range", asRangeObj.map(propLine));
  section("Atributos (DatatypeProperties) onde este termo é Domain", asDomainDt.map(propLine));
  section("Atributos (DatatypeProperties) onde este termo é Range", asRangeDt.map(propLine));

  return parts.join("");
}

/* =========================
   Node size (compact)
========================= */
const measurer = document.createElement("canvas").getContext("2d");
function measureTextWidth(text, fontPx){
  measurer.font = `${fontPx}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
  return measurer.measureText(text).width;
}
function computeAutoNodeSize(iri, baseMinW=86, baseMinH=24){
  const style = state.nodeStyles.get(iri) || {};
  if (style.w && style.h) return {w: style.w, h: style.h};

  const font = style.font ?? 12;
  const label = termLabel(iri);

  const maxLineW = 140;
  const padX = 16;
  const padY = 10;
  const lineH = Math.round(font * 1.25);

  let words = label.split(/\s+/).filter(Boolean);
  let line1 = "", line2 = "";
  for (const w of words){
    const cand = (line1 ? line1 + " " : "") + w;
    if (measureTextWidth(cand, font) <= maxLineW) line1 = cand;
    else line2 = (line2 ? line2 + " " : "") + w;
  }
  if (!line1) line1 = label;

  const w1 = measureTextWidth(line1, font);
  const w2 = line2 ? measureTextWidth(line2, font) : 0;
  const w = Math.max(baseMinW, Math.ceil(Math.max(w1, w2) + padX));
  const lines = line2 ? 2 : 1;
  const h = Math.max(baseMinH, Math.ceil(lines * lineH + padY));

  return {w: style.w ?? w, h: style.h ?? h};
}

/* =========================
   Render
========================= */
function resize(){
  const r = wrap.getBoundingClientRect();
  width = r.width; height = r.height;
  svg.attr("viewBox", `0 0 ${width} ${height}`);
}
window.addEventListener("resize", () => { resize(); if (state.loaded) rebuildAndRender(); });

function linkPath(a, b, c){
  const x1=a.x, y1=a.y, x2=b.x, y2=b.y;
  const cx1 = x1 + (x2-x1)*c;
  const cy1 = y1 + (y2-y1)*(1-c);
  const cx2 = x1 + (x2-x1)*(1-c);
  const cy2 = y1 + (y2-y1)*c;
  return `M${x1},${y1} C${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`;
}

function rebuildAndRender(){
  if (!state.loaded) return;

  ui.depthLabel.textContent = String(getMaxDepth());

  const tree = buildTree();
  const flat = flatten(tree);

  ui.nodeCount.textContent = flat.nodes.length;
  ui.edgeCount.textContent = flat.links.length;

  // dim color map
  const dimMap = new Map();
  for (const dim of state.dimensions){
    if (!state.selectedDims.has(dim.iri)) continue;
    (function dfs(i){
      if (dimMap.has(i)) return;
      dimMap.set(i, dim.color);
      for (const k of (state.subclasses.get(i) || new Set())){
        if (!state.classNodes.has(k)) continue;
        dfs(k);
      }
    })(dim.iri);
  }
  dimMap.set(state.rootIri, "#64748b");

  resize();

  const sample = flat.nodes.slice(0, Math.min(60, flat.nodes.length)).map(n => computeAutoNodeSize(n.iri));
  const avgW = sample.length ? sample.reduce((a,b)=>a+b.w,0)/sample.length : 140;
  const avgH = sample.length ? sample.reduce((a,b)=>a+b.h,0)/sample.length : 28;

  let dx = Math.max(44, avgH + 16);
  let dy = Math.max(170, avgW + 80);
  if (ui.layoutSelect.value === "a4"){
    dx = Math.max(40, avgH + 12);
    dy = Math.max(220, avgW + 120);
  }

  const root = d3.hierarchy(tree, d=>d.children);
  const padTop = 30;
  const centerX = width/2, centerY = (height+padTop)/2;

  if (ui.layoutSelect.value === "radial"){
    const layout = d3.tree().size([2*Math.PI, Math.min(width,height)/2 - 100]);
    layout(root);
    root.descendants().forEach(d=>{
      const r=d.y, a=d.x;
      d.x = centerX + r*Math.cos(a - Math.PI/2);
      d.y = centerY + r*Math.sin(a - Math.PI/2);
    });
  } else if (ui.layoutSelect.value === "leftright"){
    const layout = d3.tree().nodeSize([dx, dy]);
    layout(root);
    root.descendants().forEach(d=>{
      d.x = (height/2) + d.x;
      d.y = padTop + d.y;
    });
  } else {
    const layout = d3.tree().nodeSize([dx, dy]);
    layout(root);
    root.descendants().forEach(d=>{
      d.x = centerX + d.x;
      d.y = padTop + d.y;
    });
  }

  // apply manual positions
  const lk = ui.layoutSelect.value;
  root.descendants().forEach(d=>{
    const key = `${lk}|${d.data.iri}`;
    if (state.nodePositions.has(key)){
      const p = state.nodePositions.get(key);
      d.x = p.x; d.y = p.y;
    }
  });

  // links
  const curve = +ui.edgeCurve.value / 100;
  const strokeW = +ui.edgeWidth.value;
  const edgeCol = ui.edgeColor.value;

  const linkSel = gLinks.selectAll("path.link")
    .data(root.links(), d => d.target.data.iri);

  linkSel.exit().remove();

  linkSel.enter().append("path")
    .attr("class","link")
    .merge(linkSel)
    .attr("stroke", edgeCol)
    .attr("stroke-width", strokeW)
    .attr("d", d => linkPath(d.source, d.target, curve));

  // nodes
  const nodeSel = gNodes.selectAll("g.node")
    .data(root.descendants(), d => d.data.iri);

  nodeSel.exit().remove();

  const nodeEnter = nodeSel.enter()
    .append("g")
    .attr("class","node")
    .style("cursor","pointer")
    .on("mousemove", (event, d) => showTooltip(event, d.data.iri))
    .on("mouseleave", hideTooltip)
    .on("click", (event, d) => {
      event.stopPropagation();
      const iri = d.data.iri;
      if (event.altKey) toggleCollapse(iri);
      else selectNode(iri);
    })
    .call(d3.drag()
      .on("start", (event) => event.sourceEvent?.stopPropagation())
      .on("drag", (event, d) => {
        d.x = event.x; d.y = event.y;
        const key = `${ui.layoutSelect.value}|${d.data.iri}`;
        state.nodePositions.set(key, {x:d.x, y:d.y});
        savePersisted();
        gNodes.selectAll("g.node")
          .filter(n => n.data.iri === d.data.iri)
          .attr("transform", `translate(${d.x},${d.y})`);
        gLinks.selectAll("path.link")
          .attr("d", l => linkPath(l.source, l.target, curve));
      })
    );

  nodeEnter.append("rect");
  nodeEnter.append("text")
    .attr("text-anchor","middle")
    .attr("dominant-baseline","middle");

  const nodeMerge = nodeEnter.merge(nodeSel)
    .attr("transform", d => `translate(${d.x},${d.y})`)
    .classed("selected", d => d.data.iri === state.selectedIri);

  nodeMerge.select("rect")
    .each(function(d){
      const iri = d.data.iri;
      const style = state.nodeStyles.get(iri) || {};
      const auto = computeAutoNodeSize(iri);

      const w = style.w ?? auto.w;
      const h = style.h ?? auto.h;
      const r = style.radius ?? 10;

      d3.select(this)
        .attr("width", w)
        .attr("height", h)
        .attr("x", -w/2)
        .attr("y", -h/2)
        .attr("rx", r).attr("ry", r)
        .attr("fill", style.fill ?? (dimMap.get(iri) || "#64748b"))
        .attr("opacity", iri === state.rootIri ? 0.45 : ((style.opacity ?? 92)/100))
        .attr("stroke", style.stroke ?? getComputedStyle(document.body).getPropertyValue("--nodeStroke"));
    });

  nodeMerge.select("text")
    .each(function(d){
      const iri = d.data.iri;
      const style = state.nodeStyles.get(iri) || {};
      const font = style.font ?? 12;
      const label = termLabel(iri);

      const text = d3.select(this).style("font-size", font + "px");
      const auto = computeAutoNodeSize(iri);

      const maxLineW = Math.max(110, (style.w ?? auto.w) - 18);
      const words = label.split(/\s+/).filter(Boolean);
      let line1="", line2="";
      for (const w of words){
        const cand = (line1 ? line1+" " : "") + w;
        if (measureTextWidth(cand, font) <= maxLineW) line1 = cand;
        else line2 = (line2 ? line2+" " : "") + w;
      }
      if (!line1) line1 = label;

      text.text(null);
      if (!line2){
        text.append("tspan").attr("x",0).attr("dy","0em").text(line1);
      }else{
        while (line2.length>0 && measureTextWidth(line2+"…", font) > maxLineW) line2 = line2.slice(0,-1);
        line2 = line2.trim() + "…";
        text.append("tspan").attr("x",0).attr("dy","-0.2em").text(line1);
        text.append("tspan").attr("x",0).attr("dy","1.2em").text(line2);
      }
    });

  ui.selInfo.textContent = state.selectedIri ? termLabel(state.selectedIri) : "—";

  if (!rebuildAndRender._didFit){
    fitToView();
    rebuildAndRender._didFit = true;
  }
}

function showTooltip(evt, iri){
  ui.tooltip.style.display = "block";
  ui.tooltip.innerHTML = tooltipHTML(iri);
  const pad = 14;
  const rect = wrap.getBoundingClientRect();
  ui.tooltip.style.left = (evt.clientX - rect.left + pad) + "px";
  ui.tooltip.style.top  = (evt.clientY - rect.top + pad) + "px";
}
function hideTooltip(){ ui.tooltip.style.display = "none"; }

/* =========================
   Collapse / Select / Editor
========================= */
function toggleCollapse(iri){
  if (state.collapsed.has(iri)) state.collapsed.delete(iri);
  else state.collapsed.add(iri);
  savePersisted();
  rebuildAndRender();
}

function selectNode(iri){
  state.selectedIri = iri;
  openEditorFor(iri);
  rebuildAndRender();
}

function openEditorFor(iri){
  ui.editorCard.style.opacity = "1";
  ui.editorHint.textContent = shrinkIri(iri);

  ui.edLabel.disabled = false;
  ui.edFill.disabled = false;
  ui.edStroke.disabled = false;
  ui.edOpacity.disabled = false;
  ui.edW.disabled = false;
  ui.edH.disabled = false;
  ui.edFont.disabled = false;
  ui.edRadius.disabled = false;
  ui.btnEditorApply.disabled = false;
  ui.btnEditorReset.disabled = false;

  const style = state.nodeStyles.get(iri) || {};
  const auto = computeAutoNodeSize(iri);

  ui.edLabel.value = state.customLabels.get(iri) || (state.classNodes.get(iri)?.label || shrinkIri(iri));
  ui.edFill.value = style.fill || "#64748b";
  ui.edStroke.value = (style.stroke && style.stroke.startsWith("#")) ? style.stroke : "#111827";
  ui.edOpacity.value = style.opacity ?? 92;
  ui.edW.value = style.w ?? auto.w;
  ui.edH.value = style.h ?? auto.h;
  ui.edFont.value = style.font ?? 12;
  ui.edRadius.value = style.radius ?? 10;
}

ui.btnEditorApply.addEventListener("click", () => {
  const iri = state.selectedIri;
  if (!iri) return;

  const newLabel = ui.edLabel.value.trim();
  if (newLabel) state.customLabels.set(iri, newLabel);
  else state.customLabels.delete(iri);

  state.nodeStyles.set(iri, {
    fill: ui.edFill.value,
    stroke: ui.edStroke.value,
    opacity: +ui.edOpacity.value,
    w: +ui.edW.value,
    h: +ui.edH.value,
    font: +ui.edFont.value,
    radius: +ui.edRadius.value
  });

  savePersisted();
  rebuildAndRender();
});

ui.btnEditorReset.addEventListener("click", () => {
  const iri = state.selectedIri;
  if (!iri) return;
  state.customLabels.delete(iri);
  state.nodeStyles.delete(iri);
  savePersisted();
  openEditorFor(iri);
  rebuildAndRender();
});

/* =========================
   Fit / Reset
========================= */
function fitToView(){
  const nodes = gNodes.selectAll("g.node").nodes();
  if (!nodes.length) return;

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  nodes.forEach(n=>{
    const box = n.getBBox();
    const tr = n.getCTM();
    const x = tr.e + box.x, y = tr.f + box.y;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + box.width);
    maxY = Math.max(maxY, y + box.height);
  });

  const w = maxX-minX, h = maxY-minY;
  if (!isFinite(w) || !isFinite(h) || w<=0 || h<=0) return;

  const scale = Math.min(0.95, Math.max(0.2, Math.min(width/(w+100), height/(h+120))));
  const tx = (width/2) - scale * (minX + w/2);
  const ty = (height/2) - scale * (minY + h/2);

  svg.transition().duration(320).call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(scale));
}

function resetAll(){
  clearPersisted();
  state.customLabels.clear();
  state.collapsed.clear();
  state.nodePositions.clear();
  state.nodeStyles.clear();
  state.selectedIri = null;
  ui.selInfo.textContent = "—";
  ui.editorCard.style.opacity = "0.55";
  ui.editorHint.textContent = "Clique em um nó para editar.";
  rebuildAndRender._didFit = false;
  buildDimensions();
  rebuildAndRender();
}

/* =========================
   Search
========================= */
function buildSearchIndex(){
  state.searchIndex = [...state.classNodes.keys()].map(iri => ({
    iri,
    label: termLabel(iri),
    iriShort: shrinkIri(iri)
  })).sort((a,b)=>a.label.localeCompare(b.label,"pt-BR"));
}

function renderSearchResults(items){
  const box = ui.searchResults;
  box.innerHTML = "";
  if (!items.length){
    box.innerHTML = `<div class="searchItem"><div class="small">Nenhum resultado</div></div>`;
    box.style.display = "block";
    return;
  }
  for (const it of items.slice(0, 30)){
    const row = document.createElement("div");
    row.className = "searchItem";
    row.innerHTML = `<div>${escapeHTML(it.label)}</div><div class="tag">${escapeHTML(it.iriShort)}</div>`;
    row.addEventListener("click", () => {
      selectNode(it.iri);
      zoomToNode(it.iri);
    });
    box.appendChild(row);
  }
  box.style.display = "block";
}

function zoomToNode(iri){
  const node = gNodes.selectAll("g.node").filter(d => d.data.iri === iri).node();
  if (!node) return;

  const box = node.getBBox();
  const tr = node.getCTM();
  const x = tr.e + box.x + box.width/2;
  const y = tr.f + box.y + box.height/2;

  const scale = Math.max(0.7, Math.min(2.2, d3.zoomTransform(svg.node()).k));
  const tx = (width/2) - scale * x;
  const ty = (height/2) - scale * y;

  svg.transition().duration(320).call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(scale));
}

/* =========================
   Export
========================= */
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

function exportSVG(){
  const svgNode = svg.node().cloneNode(true);
  svgNode.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  svgNode.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");

  const vb = svgNode.getAttribute("viewBox") || `0 0 ${width} ${height}`;
  const [x,y,w,h] = vb.split(" ").map(Number);
  const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  bg.setAttribute("x", x); bg.setAttribute("y", y);
  bg.setAttribute("width", w); bg.setAttribute("height", h);
  bg.setAttribute("fill", getComputedStyle(document.body).getPropertyValue("--bg").trim());
  svgNode.insertBefore(bg, svgNode.firstChild);

  const serializer = new XMLSerializer();
  const text = serializer.serializeToString(svgNode);
  downloadBlob(new Blob([text], {type:"image/svg+xml;charset=utf-8"}), `taxonomia_${ui.layoutSelect.value}.svg`);
}

function exportPNG(){
  const serializer = new XMLSerializer();
  const vb = svg.attr("viewBox");
  const [vx, vy, vw, vh] = vb.split(" ").map(Number);

  const cloned = svg.node().cloneNode(true);
  cloned.setAttribute("xmlns", "http://www.w3.org/2000/svg");

  const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  bg.setAttribute("x", vx); bg.setAttribute("y", vy);
  bg.setAttribute("width", vw); bg.setAttribute("height", vh);
  bg.setAttribute("fill", getComputedStyle(document.body).getPropertyValue("--bg").trim());
  cloned.insertBefore(bg, cloned.firstChild);

  const svgText = serializer.serializeToString(cloned);
  const svgBlob = new Blob([svgText], {type:"image/svg+xml;charset=utf-8"});
  const url = URL.createObjectURL(svgBlob);

  const img = new Image();
  img.onload = () => {
    const canvas = document.createElement("canvas");
    const scale = 2;
    canvas.width = Math.floor(vw * scale);
    canvas.height = Math.floor(vh * scale);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    ctx.drawImage(img, 0, 0);
    canvas.toBlob((pngBlob) => {
      downloadBlob(pngBlob, `taxonomia_${ui.layoutSelect.value}.png`);
      URL.revokeObjectURL(url);
    }, "image/png");
  };
  img.onerror = () => { URL.revokeObjectURL(url); alert("Falha ao exportar PNG. Use SVG."); };
  img.src = url;
}

/* =========================
   UI events
========================= */
ui.btnLoad.addEventListener("click", async () => {
  try{
    loadPersisted();
    await loadData(ui.dataUrl.value.trim());
  }catch(e){
    setStatus("erro", false);
    ui.graphInfo.textContent = "erro";
    alert(e.message || String(e));
  }
});

ui.btnFit.addEventListener("click", fitToView);
ui.btnReset.addEventListener("click", resetAll);

ui.btnAll.addEventListener("click", () => {
  state.dimensions.forEach(d => state.selectedDims.add(d.iri));
  saveDimsPersisted();
  renderDimsList();
  rebuildAndRender();
});
ui.btnNone.addEventListener("click", () => {
  state.selectedDims.clear();
  saveDimsPersisted();
  renderDimsList();
  rebuildAndRender();
});

// FIX: ao mudar splitMode para single, garantir só 1 dimensão selecionada (a ativa)
ui.splitMode.addEventListener("change", () => {
  if (ui.splitMode.value === "single") {
    const iri = ui.activeDim.value;
    if (iri) {
      state.selectedDims = new Set([iri]);
      saveDimsPersisted();
      renderDimsList();
    }
  }
  rebuildAndRender();
});

// FIX: activeDim agora funciona e não volta para "UFO"
ui.activeDim.addEventListener("change", () => {
  const iri = ui.activeDim.value;
  if (!iri) return;

  // garante que a dimensão ativa está selecionada
  state.selectedDims.add(iri);

  // se estiver em single, fica somente ela
  if (ui.splitMode.value === "single") {
    state.selectedDims = new Set([iri]);
  }

  saveDimsPersisted();
  renderDimsList();
  rebuildAndRender();
});

ui.maxDepth.addEventListener("input", rebuildAndRender);
ui.btnMoreDepth.addEventListener("click", () => {
  ui.maxDepth.value = String(Math.min(+ui.maxDepth.max, +ui.maxDepth.value + 1));
  rebuildAndRender();
});

ui.layoutSelect.addEventListener("change", rebuildAndRender);
ui.edgeCurve.addEventListener("input", rebuildAndRender);
ui.edgeWidth.addEventListener("input", rebuildAndRender);
ui.edgeColor.addEventListener("input", rebuildAndRender);

ui.btnExportSVG.addEventListener("click", exportSVG);
ui.btnExportPNG.addEventListener("click", exportPNG);

ui.persistSelect.addEventListener("change", () => {
  if (!persistEnabled()) clearPersisted();
  else savePersisted();
});

// Search
ui.searchInput.addEventListener("input", () => {
  const q = ui.searchInput.value.trim().toLowerCase();
  if (!q){ ui.searchResults.style.display = "none"; return; }
  const hits = state.searchIndex.filter(it =>
    it.label.toLowerCase().includes(q) || it.iriShort.toLowerCase().includes(q)
  );
  renderSearchResults(hits);
});
ui.btnSearchClear.addEventListener("click", () => {
  ui.searchInput.value = "";
  ui.searchResults.style.display = "none";
});
ui.btnSearchShowAll.addEventListener("click", () => renderSearchResults(state.searchIndex));

// background click unselect
svg.on("click", () => {
  state.selectedIri = null;
  ui.selInfo.textContent = "—";
  ui.editorCard.style.opacity = "0.55";
  ui.editorHint.textContent = "Clique em um nó para editar.";
  rebuildAndRender();
  hideTooltip();
});

/* =========================
   Init
========================= */
function init(){
  resize();
  enableControls(false);
  ui.dataUrl.value = "https://raw.githubusercontent.com/luquizis/Ontohate/main/ontohate_.owl";

  const theme = localStorage.getItem(persistedKey("theme"));
  if (theme === "light" || theme === "dark") setTheme(theme, false);

  // enable export/layout after load
  ui.btnExportSVG.disabled = true;
  ui.btnExportPNG.disabled = true;
}
init();
</script>
</body>
</html>
