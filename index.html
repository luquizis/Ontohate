<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ONTOHATE V2 ‚Äî 4 Taxonomias (Seletor)</title>

  <!-- D3 (render √°rvore) -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

  <!-- SheetJS (ler .xlsx no browser) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14; --panel:#111826; --text:#e6edf3; --muted:#9aa4b2; --line:rgba(255,255,255,.10);
      --chip:rgba(255,255,255,.08); --warn:#f7c97a; --bad:#ff6b6b;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    header{
      position:sticky; top:0; z-index:10;
      background:linear-gradient(180deg, rgba(11,15,20,.98), rgba(11,15,20,.85));
      border-bottom:1px solid var(--line);
      padding:12px 14px;
      display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:center;
    }
    .title{display:flex; flex-direction:column; gap:4px;}
    .title h1{margin:0; font-size:14px; font-weight:700;}
    .title .sub{font-size:12px; color:var(--muted);}
    .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end;}
    .btn,.file,.input,.select{
      border:1px solid var(--line); background:var(--panel); color:var(--text);
      border-radius:10px; padding:8px 10px; font-size:12px; line-height:1;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn{cursor:pointer; user-select:none;}
    .btn:hover{border-color:rgba(255,255,255,.22);}
    .file input[type="file"]{display:none;}
    .input input{
      border:none; outline:none; background:transparent; color:var(--text);
      width:240px; font-size:12px;
    }
    .select select{
      border:none; outline:none; background:transparent; color:var(--text);
      font-size:12px; appearance:none;
    }
    .chip{background:var(--chip); border:1px solid var(--line); border-radius:999px; padding:6px 10px; font-size:12px; color:var(--muted); white-space:nowrap;}
    #wrap{height:calc(100% - 66px);}
    svg{width:100%; height:100%; display:block;}

    .link{fill:none; stroke:rgba(255,255,255,.16); stroke-width:1.2;}
    .node rect{fill:rgba(255,255,255,.06); stroke:rgba(255,255,255,.16); stroke-width:1; rx:10; ry:10;}
    .node text{font-size:12px; fill:var(--text); pointer-events:none;}
    .node .small{font-size:10px; fill:var(--muted);}
    .node--match rect{stroke:var(--warn); stroke-width:2;}

    .toast{
      position:fixed; left:14px; bottom:14px; z-index:50;
      background:rgba(17,24,38,.92); border:1px solid var(--line);
      padding:10px 12px; border-radius:12px; font-size:12px; color:var(--muted);
      max-width:min(880px, calc(100% - 28px)); white-space:pre-wrap;
    }
    .toast.bad{border-color:rgba(255,107,107,.55); color:#ffdede;}

    .side{
      position:fixed; right:14px; bottom:14px; z-index:40;
      background:rgba(17,24,38,.92); border:1px solid var(--line);
      padding:10px 12px; border-radius:12px; font-size:12px; color:var(--muted);
      max-width:560px;
    }
    .side b{color:var(--text);}
    .hint{margin-top:8px; color:var(--muted);}
    code{color:#cbd5e1}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:8px;}
  </style>
</head>
<body>

<header>
  <div class="title">
    <h1>ONTOHATE V2 ‚Äî 1 HTML com seletor (Taxonomia 1‚Äì4)</h1>
    <div class="sub">
      Cada taxonomia = <b>duas subontologias</b> (somente elas). Se uma classe ficar sem superclasse dentro do recorte,
      ela √© anexada √† raiz da taxonomia (para n√£o perder nenhuma classe).
    </div>
  </div>

  <div class="controls">
    <label class="file btn" title="Carregar Ontohate_V2.xlsx do computador">
      üìÑ Carregar XLSX
      <input id="fileInput" type="file" accept=".xlsx,.xls" />
    </label>

    <div class="btn" id="btnLoadDefault" title="Carregar Ontohate_V2.xlsx do mesmo diret√≥rio do index.html">
      ‚¨áÔ∏è Carregar Ontohate_V2.xlsx
    </div>

    <div class="select" title="Escolha a taxonomia (1‚Äì4)">
      üß≠
      <select id="taxSelector">
        <option value="1">Taxonomia 1</option>
        <option value="2">Taxonomia 2</option>
        <option value="3">Taxonomia 3</option>
        <option value="4">Taxonomia 4</option>
      </select>
    </div>

    <div class="input" title="Buscar classe pelo nome">
      üîé <input id="search" placeholder="Buscar classe (nome)" />
    </div>

    <div class="btn" id="btnExpandAll">‚ûï Expandir</div>
    <div class="btn" id="btnCollapseAll">‚ûñ Recolher</div>

    <span class="chip" id="stats">Arquivo: ‚Äî | Classes: ‚Äî | Rela√ß√µes: ‚Äî</span>
  </div>
</header>

<div id="wrap"><svg id="svg"></svg></div>

<div class="side">
  <div><b>Pares de subontologias (edit√°veis)</b></div>
  <div class="hint">Se os nomes na planilha forem diferentes (ex.: ‚ÄúRecursos‚Äù vs ‚ÄúRecursos t√©cnicos e estrat√©gias‚Äù), ajuste aqui.</div>

  <div class="row">
    <span class="chip" id="pairLabel">Taxonomia ‚Äî</span>
    <span class="select">A:
      <select id="pairA"></select>
    </span>
    <span class="select">B:
      <select id="pairB"></select>
    </span>
    <span class="btn" id="btnApplyPair">Aplicar</span>
  </div>

  <div class="hint" style="margin-top:10px;">
    <b>Regra do recorte:</b> entram todas as classes cuja <code>Subontologia</code> seja A ou B.
    Mant√©m-se <code>Classe ‚Üí Superclasse</code> apenas quando a superclasse tamb√©m est√° no recorte.
    Caso contr√°rio, a classe vira raiz dentro da taxonomia (n√£o some).
  </div>
</div>

<div class="toast" id="toast" style="display:none;"></div>

<script>
  // ---------- UI helpers ----------
  const svg = d3.select("#svg");
  const toastEl = document.getElementById("toast");
  const statsEl = document.getElementById("stats");
  const searchEl = document.getElementById("search");
  const fileInput = document.getElementById("fileInput");
  const taxSelector = document.getElementById("taxSelector");
  const pairLabel = document.getElementById("pairLabel");
  const pairA = document.getElementById("pairA");
  const pairB = document.getElementById("pairB");
  const btnApplyPair = document.getElementById("btnApplyPair");

  function toast(msg, isBad=false){
    toastEl.textContent = msg;
    toastEl.classList.toggle("bad", !!isBad);
    toastEl.style.display = "block";
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=> toastEl.style.display="none", 9000);
  }

  // Single zoom (stable)
  const zoom = d3.zoom()
    .scaleExtent([0.15, 2.5])
    .on("zoom", (event) => svg.select("g#viewport").attr("transform", event.transform));

  // ---------- State ----------
  let RAW = null;               // { nodes: Map, edges: Array, groups: Array, sheetNames: Array, fileName: string }
  let CURRENT = null;           // { forest, includedSet, edgesInScopeCount, includedCount }
  let root = null;
  let viewport = null;
  let nodeLayer = null;
  let updateFn = null;
  let expandAllFn = null;
  let collapseAllFn = null;

  // Default pair presets (we auto-map to actual group names using fuzzy match)
  const TAX_PRESETS = {
    1: { label: "Taxonomia 1", aHint: "naturez", bHint: "manif" },      // Natureza + Manifesta√ß√£o
    2: { label: "Taxonomia 2", aHint: "motiv",   bHint: "consequ" },    // Motiva√ß√£o + Consequ√™ncias
    3: { label: "Taxonomia 3", aHint: "context", bHint: "moder" },      // Contexto + Modera√ß√£o/Governan√ßa
    4: { label: "Taxonomia 4", aHint: "recurso", bHint: "moder" },      // Recursos/Estrat√©gias + Modera√ß√£o/Governan√ßa
  };

  function norm(s){
    return String(s||"")
      .trim()
      .toLowerCase()
      .normalize("NFD").replace(/\p{Diacritic}/gu,""); // remove acentos
  }

  function bestMatch(groups, hint){
    const h = norm(hint);
    if (!groups.length) return "";
    // exact contains
    let candidates = groups.filter(g => norm(g).includes(h));
    if (candidates.length) return candidates[0];
    // token overlap
    const htoks = new Set(h.split(/\s+/).filter(Boolean));
    let best = groups[0], bestScore = -1;
    for (const g of groups){
      const gtoks = norm(g).split(/\s+/).filter(Boolean);
      let score = 0;
      for (const t of gtoks) if (htoks.has(t)) score++;
      if (score > bestScore){ bestScore = score; best = g; }
    }
    return best;
  }

  function fillSelect(selectEl, options, selected){
    selectEl.innerHTML = "";
    for (const o of options){
      const opt = document.createElement("option");
      opt.value = o;
      opt.textContent = o;
      if (o === selected) opt.selected = true;
      selectEl.appendChild(opt);
    }
  }

  // ---------- XLSX parsing ----------
  document.getElementById("btnLoadDefault").addEventListener("click", () => loadDefault());
  fileInput.addEventListener("change", async (ev) => {
    const f = ev.target.files?.[0];
    if (!f) return;
    const buf = await f.arrayBuffer();
    await parseAndInit(buf, f.name);
  });

  async function loadDefault(){
    const url = "Ontohate_V2.xlsx";
    try{
      const res = await fetch(url, { cache:"no-store" });
      if (!res.ok){
        throw new Error(
          `N√£o encontrei ${url} (HTTP ${res.status}).\n` +
          `No GitHub Pages, deixe index.html e Ontohate_V2.xlsx na MESMA pasta publicada (ex.: /docs) e com o nome igual.`
        );
      }
      const buf = await res.arrayBuffer();
      await parseAndInit(buf, url);
    } catch(e){
      toast("Erro ao carregar XLSX:\n" + e.message, true);
    }
  }

  function normalizeKey(k){ return norm(k); }

  function pick(row, wanted){
    const keys = Object.keys(row || {});
    const map = new Map(keys.map(k => [normalizeKey(k), k]));
    for (const w of wanted){
      const kk = map.get(normalizeKey(w));
      if (kk != null) return row[kk];
    }
    return undefined;
  }

  async function parseAndInit(buf, fileName){
    let wb;
    try{
      wb = XLSX.read(buf, { type:"array" });
    } catch(e){
      toast("Falha ao ler o XLSX:\n" + e.message, true);
      return;
    }

    const sheetNames = wb.SheetNames || [];
    if (!sheetNames.length){
      toast("XLSX sem abas.", true);
      return;
    }

    // Node model
    const nodes = new Map(); // name -> {name, group, sheet}
    const edges = [];        // [child, parent]
    const groupSet = new Set();

    function ensureNode(name, group="", sheet=""){
      const n = String(name||"").trim();
      if (!n) return null;
      if (!nodes.has(n)) nodes.set(n, { name:n, group:String(group||"").trim(), sheet:String(sheet||"").trim() });
      else {
        const cur = nodes.get(n);
        if (!cur.group && group) cur.group = String(group).trim();
        if (!cur.sheet && sheet) cur.sheet = String(sheet).trim();
      }
      const g = nodes.get(n).group;
      if (g) groupSet.add(g);
      return n;
    }

    let usedRows = 0;
    for (const sname of sheetNames){
      const ws = wb.Sheets[sname];
      if (!ws) continue;
      const json = XLSX.utils.sheet_to_json(ws, { defval:"" });

      for (const r of json){
        const child = pick(r, ["Classe", "Class", "classe"]);
        const parent = pick(r, ["Superclasse", "Superclass", "superclasse"]);
        const group  = pick(r, ["Subontologia", "Sub-ontologia", "Subontology", "subontologia"]);

        const c = String(child||"").trim();
        if (!c) continue;

        const p = String(parent||"").trim();
        const g = String(group||"").trim();

        ensureNode(c, g, sname);
        if (p) ensureNode(p, "", "");

        if (p) edges.push([c,p]);
        usedRows++;
      }
    }

    if (!usedRows || nodes.size === 0){
      toast("N√£o encontrei a coluna 'Classe' na planilha.", true);
      return;
    }

    // Dedup edges
    const seen = new Set();
    const edgesUniq = [];
    for (const [c,p] of edges){
      const k = c + "‚Üí" + p;
      if (!seen.has(k)){ seen.add(k); edgesUniq.push([c,p]); }
    }

    const groups = Array.from(groupSet).sort((a,b)=> a.localeCompare(b));
    // Include a visible option for empty groups (superclasses criadas)
    const ALL_GROUP_OPTIONS = ["(Sem subontologia)", ...groups];

    RAW = { nodes, edges: edgesUniq, groups: ALL_GROUP_OPTIONS, sheetNames, fileName };

    // Init selector + default pairs
    taxSelector.value = "1";
    syncPairUIFromPreset(1);

    // Render first
    applyTaxonomy();

    toast(
      `Planilha carregada: ${fileName}\n` +
      `Abas: ${sheetNames.length}\n` +
      `Subontologias detectadas: ${groups.length} (+ sem subontologia)`,
      false
    );
  }

  function syncPairUIFromPreset(taxId){
    const preset = TAX_PRESETS[taxId];
    pairLabel.textContent = preset.label;

    const groups = RAW?.groups || ["(Sem subontologia)"];
    // pick best matches among real groups (ignoring "(Sem subontologia)" for matching)
    const real = groups.filter(g => g !== "(Sem subontologia)");
    const a = bestMatch(real, preset.aHint) || (real[0] || "(Sem subontologia)");
    const b = bestMatch(real, preset.bHint) || (real[1] || real[0] || "(Sem subontologia)");

    fillSelect(pairA, groups, a);
    fillSelect(pairB, groups, b);
  }

  taxSelector.addEventListener("change", () => {
    if (!RAW) return;
    const id = Number(taxSelector.value);
    syncPairUIFromPreset(id);
    applyTaxonomy();
  });

  btnApplyPair.addEventListener("click", () => {
    if (!RAW) return;
    applyTaxonomy();
  });

  // ---------- Build taxonomy = two subontologies ----------
  function applyTaxonomy(){
    if (!RAW) return;

    const taxId = Number(taxSelector.value);
    const label = TAX_PRESETS[taxId]?.label || `Taxonomia ${taxId}`;
    pairLabel.textContent = label;

    const selA = pairA.value;
    const selB = pairB.value;

    // Build included set: nodes whose group is A or B.
    // "(Sem subontologia)" means group empty string.
    const included = new Set();
    for (const [name, obj] of RAW.nodes.entries()){
      const g = (obj.group || "").trim();
      const gx = g ? g : "(Sem subontologia)";
      if (gx === selA || gx === selB) included.add(name);
    }

    // Ensure "nenhuma classe fica de fora" dentro do recorte:
    // - if included is empty, warn and stop
    if (included.size === 0){
      toast(
        `Nenhuma classe encontrada para o par:\nA = ${selA}\nB = ${selB}\n\n` +
        `Dica: ajuste os selects para os nomes exatos das subontologias na planilha.`,
        true
      );
      return;
    }

    // Edges in scope only if both ends are included
    const edgesInScope = [];
    const childrenOf = new Map(); // parent -> [child]
    const parentSet = new Set();  // children that have parent inside scope

    for (const [c,p] of RAW.edges){
      if (!included.has(c)) continue;
      if (!included.has(p)) continue;
      edgesInScope.push([c,p]);
      parentSet.add(c);
      if (!childrenOf.has(p)) childrenOf.set(p, []);
      childrenOf.get(p).push(c);
    }
    for (const [p, kids] of childrenOf.entries()){
      kids.sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));
    }

    // Roots inside scope: included nodes that do NOT have a parent inside scope
    const roots = [];
    for (const n of included){
      if (!parentSet.has(n)) roots.push(n);
    }
    roots.sort((a,b)=> a.toLowerCase().localeCompare(b.toLowerCase()));

    // Build tree (clone-safe)
    let idCounter = 0;
    function buildSubtree(name, stack=new Set()){
      const base = RAW.nodes.get(name) || { name, group:"", sheet:"" };
      const g = (base.group || "").trim();
      const node = {
        name: base.name,
        group: g ? g : "(Sem subontologia)",
        sheet: base.sheet || "",
        _id: ++idCounter,
        children: []
      };
      if (stack.has(name)) return node;
      stack.add(name);

      const kids = childrenOf.get(name) || [];
      for (const k of kids){
        node.children.push(buildSubtree(k, new Set(stack)));
      }
      return node;
    }

    const forest = {
      name: `${label}: ${selA} + ${selB}`,
      group: "Raiz",
      sheet: "",
      children: roots.map(r => buildSubtree(r))
    };

    CURRENT = {
      forest,
      includedSet: included,
      edgesInScopeCount: edgesInScope.length,
      includedCount: included.size,
      selA, selB,
      label
    };

    statsEl.textContent = `Arquivo: ${RAW.fileName} | Classes no recorte: ${included.size} | Rela√ß√µes no recorte: ${edgesInScope.length}`;

    renderTree(forest);
    toast(
      `${label} aplicada.\n` +
      `Subontologias: ${selA} + ${selB}\n` +
      `Classes (somente A/B): ${included.size}\n` +
      `Rela√ß√µes internas (A/B): ${edgesInScope.length}`,
      false
    );
  }

  // ---------- Render tree ----------
  function renderTree(data){
    svg.selectAll("*").remove();
    viewport = svg.append("g").attr("id","viewport");
    svg.call(zoom);
    svg.call(zoom.transform, d3.zoomIdentity.translate(20, 20).scale(1));

    const tree = d3.tree().nodeSize([34, 240]);
    root = d3.hierarchy(data);
    root.x0 = 0; root.y0 = 0;

    // initial collapse deeper than 2 levels
    root.children?.forEach(c => c.children?.forEach(cc => collapse(cc)));

    const linkLayer = viewport.append("g");
    nodeLayer = viewport.append("g");

    function collapse(d){
      if (d.children){
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
      }
    }

    expandAllFn = function expandAll(d){
      if (d._children){ d.children = d._children; d._children = null; }
      (d.children||[]).forEach(expandAll);
    };
    collapseAllFn = function collapseAll(d){
      (d.children||[]).forEach(collapseAll);
      if (d.depth >= 2) collapse(d);
    };

    function diagonal(d){
      return d3.linkHorizontal().x(d=>d.y).y(d=>d.x)(d);
    }

    function strokeForGroup(group){
      const g = String(group||"").trim();
      if (!g || g === "(Sem subontologia)") return "rgba(255,255,255,.18)";
      if (g === "Raiz") return "rgba(255,255,255,.22)";
      // deterministic-ish color
      const s = norm(g);
      let h = 2166136261;
      for (let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
      const hue = (h >>> 0) % 360;
      return `hsl(${hue} 62% 58%)`;
    }

    updateFn = function update(source){
      tree(root);
      const nodes = root.descendants();
      const links = root.links();

      const link = linkLayer.selectAll("path.link")
        .data(links, d => d.target.data._id);

      link.enter().append("path")
        .attr("class","link")
        .attr("d", d => {
          const o = { x: source.x0, y: source.y0 };
          return diagonal({ source:o, target:o });
        })
        .merge(link)
        .transition().duration(200)
        .attr("d", diagonal);

      link.exit().transition().duration(200).attr("opacity",0).remove();

      const node = nodeLayer.selectAll("g.node")
        .data(nodes, d => d.data._id);

      const nodeEnter = node.enter().append("g")
        .attr("class","node")
        .attr("transform", `translate(${source.y0},${source.x0})`)
        .on("click", (_, d) => {
          if (d.children){ d._children = d.children; d.children = null; }
          else { d.children = d._children; d._children = null; }
          updateFn(d);
          applySearchHighlight();
        });

      nodeEnter.append("rect")
        .attr("x", 0).attr("y", -18)
        .attr("width", 360).attr("height", 36);

      nodeEnter.append("text")
        .attr("x", 12).attr("y", -2)
        .text(d => d.data.name || "(sem nome)");

      nodeEnter.append("text")
        .attr("class","small")
        .attr("x", 12).attr("y", 14)
        .text(d => {
          const g = d.data.group || "";
          const s = d.data.sheet ? ` | Aba: ${d.data.sheet}` : "";
          return `Subontologia: ${g}${s}`;
        });

      nodeEnter.append("text")
        .attr("x", 330).attr("y", -2)
        .attr("text-anchor","end")
        .attr("class","small")
        .text(d => (d.children || d._children) ? (d.children ? "‚ñæ" : "‚ñ∏") : "");

      const nodeMerge = nodeEnter.merge(node);

      nodeMerge.transition().duration(200)
        .attr("transform", d => `translate(${d.y},${d.x})`);

      nodeMerge.select("rect")
        .attr("stroke", d => strokeForGroup(d.data.group))
        .attr("stroke-width", d => (d.data.group && d.data.group !== "(Sem subontologia)" && d.data.group !== "Raiz") ? 2 : 1);

      nodeMerge.select("rect")
        .attr("width", d => Math.min(620, 170 + ((d.data.name||"").length)*7));

      nodeMerge.select("text:nth-of-type(3)")
        .text(d => (d.children || d._children) ? (d.children ? "‚ñæ" : "‚ñ∏") : "");

      node.exit().transition().duration(200).attr("opacity",0).remove();

      nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
    };

    updateFn(root);
    applySearchHighlight();
  }

  // ---------- Search highlight ----------
  document.getElementById("btnExpandAll").addEventListener("click", () => {
    if (!root || !expandAllFn || !updateFn) return;
    expandAllFn(root);
    updateFn(root);
    applySearchHighlight();
  });
  document.getElementById("btnCollapseAll").addEventListener("click", () => {
    if (!root || !collapseAllFn || !updateFn) return;
    collapseAllFn(root);
    updateFn(root);
    applySearchHighlight();
  });
  searchEl.addEventListener("input", () => applySearchHighlight());

  function applySearchHighlight(){
    if (!nodeLayer) return;
    const q = norm(searchEl.value);
    nodeLayer.selectAll("g.node").classed("node--match", false);
    if (!q) return;

    nodeLayer.selectAll("g.node").each(function(d){
      const name = norm(d.data.name);
      if (name.includes(q)){
        d3.select(this).classed("node--match", true);
      }
    });
  }

  // ---------- Auto-load default XLSX (GitHub Pages) ----------
  (async function(){
    try{ await loadDefault(); } catch(_) {}
  })();
</script>
</body>
</html>
