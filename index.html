<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OntoHate â€” Taxonomia do Discurso de Ã“dio Online</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=DM+Mono:ital,wght@0,400;0,500;1,400&family=Syne:wght@400;600;700;800&display=swap" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/rdflib@2.2.37/dist/rdflib.min.js"></script>

  <style>
    /* ===== DESIGN TOKENS ===== */
    :root{
      --bg:          #07090f;
      --bg2:         #0d1117;
      --panel:       #111827;
      --panel2:      #0d1117;
      --border:      #1e2d45;
      --border2:     #253347;
      --text:        #e2e8f0;
      --muted:       #64748b;
      --muted2:      #94a3b8;
      --accent:      #38bdf8;
      --accent2:     #0ea5e9;
      --danger:      #f43f5e;
      --ok:          #10b981;
      --warn:        #f59e0b;

      --node-text:   #f1f5f9;
      --node-stroke: rgba(0,0,0,0.5);
      --link-col:    #1e3a5f;

      --font-display: 'Syne', sans-serif;
      --font-mono:    'DM Mono', monospace;

      --sidebar-w: 380px;
      --topbar-h:  52px;
      --radius:    10px;
      --radius-sm: 6px;
    }

    [data-theme="light"]{
      --bg:          #f8fafc;
      --bg2:         #ffffff;
      --panel:       #ffffff;
      --panel2:      #f1f5f9;
      --border:      #e2e8f0;
      --border2:     #cbd5e1;
      --text:        #0f172a;
      --muted:       #64748b;
      --muted2:      #475569;
      --accent:      #0284c7;
      --accent2:     #0369a1;
      --danger:      #e11d48;
      --ok:          #059669;
      --warn:        #d97706;

      --node-text:   #0f172a;
      --node-stroke: rgba(15,23,42,0.15);
      --link-col:    #94a3b8;
    }

    /* ===== RESET ===== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: var(--font-display);
      font-size: 13px;
      line-height: 1.5;
    }

    /* ===== LAYOUT ===== */
    .app {
      display: grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      height: 100vh;
    }

    /* ===== SIDEBAR ===== */
    .sidebar {
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .sidebar-title {
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.01em;
      color: var(--text);
      margin-bottom: 4px;
    }

    .sidebar-subtitle {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.4;
    }

    .sidebar-body {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sidebar-body::-webkit-scrollbar { width: 4px; }
    .sidebar-body::-webkit-scrollbar-track { background: transparent; }
    .sidebar-body::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 4px; }

    /* ===== CARDS ===== */
    .card {
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
    }

    .card-header:hover { background: color-mix(in srgb, var(--accent) 5%, transparent); }

    .card-title {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted2);
    }

    .card-toggle {
      font-size: 10px;
      color: var(--muted);
      transition: transform 0.2s;
    }

    .card-body {
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .card.collapsed .card-body { display: none; }
    .card.collapsed .card-toggle { transform: rotate(-90deg); }

    /* ===== FORM ELEMENTS ===== */
    label {
      display: block;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--muted);
      margin-bottom: 4px;
    }

    input[type="text"], input[type="url"], select, textarea {
      width: 100%;
      padding: 7px 10px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border2);
      background: var(--bg);
      color: var(--text);
      font-family: var(--font-mono);
      font-size: 12px;
      outline: none;
      transition: border-color 0.15s;
    }
    input[type="text"]:focus,
    input[type="url"]:focus,
    select:focus { border-color: var(--accent); }

    input[type="color"] {
      width: 30px; height: 30px;
      border: 1px solid var(--border2);
      border-radius: var(--radius-sm);
      background: transparent;
      padding: 2px;
      cursor: pointer;
    }

    input[type="range"] {
      -webkit-appearance: none;
      width: 100%; height: 4px;
      background: var(--border2);
      border-radius: 4px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px; height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid var(--bg);
    }

    .field { display: flex; flex-direction: column; gap: 4px; }
    .row   { display: flex; gap: 8px; align-items: flex-end; flex-wrap: wrap; }
    .row .field { flex: 1; min-width: 80px; }

    /* ===== BUTTONS ===== */
    button {
      display: inline-flex; align-items: center; justify-content: center; gap: 5px;
      padding: 6px 11px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border2);
      background: var(--panel);
      color: var(--text);
      font-family: var(--font-display);
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
      letter-spacing: 0.03em;
    }
    button:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); }
    button:disabled { opacity: 0.38; cursor: not-allowed; }

    button.primary {
      background: color-mix(in srgb, var(--accent) 15%, transparent);
      border-color: color-mix(in srgb, var(--accent) 50%, var(--border2));
      color: var(--accent);
    }
    button.primary:hover:not(:disabled) {
      background: color-mix(in srgb, var(--accent) 25%, transparent);
    }
    button.danger {
      background: color-mix(in srgb, var(--danger) 10%, transparent);
      border-color: color-mix(in srgb, var(--danger) 45%, var(--border2));
      color: var(--danger);
    }
    button.danger:hover:not(:disabled) {
      background: color-mix(in srgb, var(--danger) 22%, transparent);
    }
    button.icon { padding: 5px 7px; }

    .btn-group { display: flex; gap: 6px; flex-wrap: wrap; }

    /* ===== TOPBAR ===== */
    .topbar {
      position: absolute; left: 0; right: 0; top: 0;
      height: var(--topbar-h);
      display: flex; align-items: center; gap: 8px;
      padding: 0 14px;
      background: color-mix(in srgb, var(--panel) 85%, transparent);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      z-index: 20;
      overflow: hidden;
    }

    .stat-pill {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 4px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: color-mix(in srgb, var(--bg) 60%, transparent);
      font-size: 11px;
      color: var(--muted2);
      white-space: nowrap;
    }
    .stat-pill .val { color: var(--text); font-weight: 600; }
    .stat-pill .dot {
      width: 6px; height: 6px; border-radius: 50%;
      background: var(--ok);
      flex-shrink: 0;
    }
    .stat-pill .dot.loading { background: var(--warn); animation: pulse 1s infinite; }
    .stat-pill .dot.error   { background: var(--danger); }
    .stat-pill .dot.idle    { background: var(--border2); }

    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }

    .topbar-spacer { flex: 1; }

    .kbd {
      font-family: var(--font-mono);
      font-size: 10px;
      padding: 2px 5px;
      border-radius: 4px;
      border: 1px solid var(--border2);
      background: color-mix(in srgb, var(--bg) 70%, transparent);
      color: var(--muted2);
    }

    /* ===== MAIN ===== */
    .main { position: relative; overflow: hidden; }

    #svgWrap {
      position: absolute;
      inset: 0;
      padding-top: var(--topbar-h);
    }

    svg { width: 100%; height: 100%; display: block; }

    /* ===== NODE STYLES ===== */
    .node rect {
      stroke: var(--node-stroke);
      stroke-width: 1px;
      transition: filter 0.15s;
      filter: drop-shadow(0 4px 12px rgba(0,0,0,0.25));
    }
    [data-theme="light"] .node rect {
      filter: drop-shadow(0 2px 8px rgba(15,23,42,0.12));
    }
    .node text { pointer-events: none; fill: var(--node-text); }
    .node.selected rect {
      stroke: var(--accent) !important;
      stroke-width: 2px !important;
      filter: drop-shadow(0 0 12px color-mix(in srgb, var(--accent) 40%, transparent));
    }

    .link {
      fill: none;
      stroke: var(--link-col);
      stroke-width: 1.6;
      opacity: 0.7;
      pointer-events: none;
    }

    /* ===== TOOLTIP ===== */
    .tooltip {
      position: absolute;
      max-width: 340px;
      pointer-events: none;
      background: var(--panel);
      border: 1px solid var(--border2);
      border-radius: var(--radius);
      padding: 10px 12px;
      font-size: 11.5px;
      line-height: 1.45;
      box-shadow: 0 16px 40px rgba(0,0,0,0.3);
      z-index: 50;
      transition: opacity 0.1s;
    }
    .tooltip .t-title { font-size: 13px; font-weight: 700; margin-bottom: 3px; }
    .tooltip .t-iri   { font-family: var(--font-mono); font-size: 10px; color: var(--muted); }
    .tooltip hr       { border: none; border-top: 1px solid var(--border); margin: 7px 0; }
    .tooltip .t-sec   { font-size: 10px; font-weight: 700; text-transform: uppercase;
                        letter-spacing: 0.06em; color: var(--muted); margin-bottom: 3px; }
    .tooltip .t-item  { padding: 1px 0 1px 10px; position: relative; }
    .tooltip .t-item::before { content: 'Â·'; position: absolute; left: 2px; color: var(--muted); }

    /* ===== SEARCH RESULTS ===== */
    .search-results {
      border: 1px solid var(--border2);
      border-radius: var(--radius-sm);
      overflow: hidden;
      background: var(--bg);
      max-height: 220px;
      overflow-y: auto;
    }
    .search-results::-webkit-scrollbar { width: 3px; }
    .search-results::-webkit-scrollbar-thumb { background: var(--border2); }

    .search-item {
      display: flex; align-items: center; justify-content: space-between; gap: 8px;
      padding: 7px 10px;
      border-top: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.1s;
    }
    .search-item:first-child { border-top: none; }
    .search-item:hover { background: color-mix(in srgb, var(--accent) 8%, transparent); }
    .search-item .s-label { font-size: 12px; }
    .search-item .s-tag   { font-family: var(--font-mono); font-size: 10px; color: var(--muted); white-space: nowrap; }

    /* ===== DIMS LIST ===== */
    .dims-list { display: flex; flex-direction: column; gap: 4px; }
    .dim-item {
      display: flex; align-items: center; gap: 8px;
      padding: 7px 9px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg);
      transition: border-color 0.15s;
    }
    .dim-item:hover { border-color: var(--border2); }
    .dim-item.active { border-color: color-mix(in srgb, var(--accent) 40%, var(--border)); }
    .dim-name { flex: 1; font-size: 12px; font-weight: 600; min-width: 0;
                overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .dim-count { font-family: var(--font-mono); font-size: 10px; color: var(--muted); }

    input[type="checkbox"] {
      width: 14px; height: 14px; accent-color: var(--accent);
      cursor: pointer; flex-shrink: 0;
    }

    /* ===== RANGE WITH VALUE ===== */
    .range-group { display: flex; flex-direction: column; gap: 4px; }
    .range-row { display: flex; align-items: center; gap: 8px; }
    .range-val {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--muted2);
      min-width: 24px;
      text-align: right;
    }

    /* ===== EDITOR ===== */
    #editorCard { transition: opacity 0.2s; }
    #editorCard.locked { opacity: 0.45; pointer-events: none; }

    /* ===== EMPTY STATE ===== */
    .empty-svg {
      position: absolute; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      gap: 12px; pointer-events: none;
      padding-top: var(--topbar-h);
    }
    .empty-icon { font-size: 40px; opacity: 0.18; }
    .empty-text { font-size: 13px; color: var(--muted); text-align: center; max-width: 240px; line-height: 1.5; }
    .empty-hint { font-family: var(--font-mono); font-size: 11px; color: var(--muted); opacity: 0.6; }

    /* ===== LOADING OVERLAY ===== */
    .loading-bar {
      position: absolute; top: var(--topbar-h); left: 0; right: 0;
      height: 2px; background: transparent; z-index: 30; overflow: hidden;
    }
    .loading-bar::after {
      content: '';
      display: block; height: 100%;
      background: var(--accent);
      animation: loading 1.2s ease-in-out infinite;
    }
    .loading-bar.hidden { display: none; }

    @keyframes loading {
      0%   { transform: translateX(-100%); }
      100% { transform: translateX(200%); }
    }
  </style>
</head>

<body data-theme="dark">
<div class="app">

  <!-- ===== SIDEBAR ===== -->
  <aside class="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">OntoHate</div>
      <div class="sidebar-subtitle">Taxonomia interativa do discurso de Ã³dio online. Carregue uma ontologia OWL/Turtle e explore a hierarquia de classes.</div>

      <div style="display:flex; gap:6px; margin-top:10px; flex-wrap:wrap;">
        <button class="icon" id="btnTheme" title="Alternar tema">â˜€</button>
        <button class="primary" id="btnFit">Ajustar tela</button>
        <button class="danger" id="btnReset">Reset</button>
      </div>
    </div>

    <div class="sidebar-body">

      <!-- Fonte de dados -->
      <div class="card">
        <div class="card-header" data-card="source">
          <span class="card-title">Fonte de dados</span>
          <span class="card-toggle">â–¾</span>
        </div>
        <div class="card-body">
          <div class="field">
            <label>URL (raw do repositÃ³rio)</label>
            <input id="dataUrl" type="text" placeholder="https://raw.githubusercontent.com/â€¦" />
          </div>
          <div class="btn-group">
            <button class="primary" id="btnLoad">Carregar</button>
          </div>
          <div style="font-size:11px; color:var(--muted);">
            Use o link "raw" do arquivo. Formatos aceitos: RDF/XML e Turtle.
          </div>
        </div>
      </div>

      <!-- Busca -->
      <div class="card">
        <div class="card-header" data-card="search">
          <span class="card-title">Busca</span>
          <span class="card-toggle">â–¾</span>
        </div>
        <div class="card-body">
          <div class="field">
            <input id="searchInput" type="text" placeholder="Digite parte do nome ou classeâ€¦" disabled />
          </div>
          <div class="btn-group">
            <button id="btnSearchClear" disabled>Limpar</button>
            <button id="btnSearchShowAll" disabled>Ver todos</button>
          </div>
          <div id="searchResults" class="search-results" style="display:none;"></div>
        </div>
      </div>

      <!-- Taxonomia -->
      <div class="card">
        <div class="card-header" data-card="taxonomy">
          <span class="card-title">Taxonomia</span>
          <span class="card-toggle">â–¾</span>
        </div>
        <div class="card-body">
          <div class="row">
            <div class="field">
              <label>Modo</label>
              <select id="splitMode" disabled>
                <option value="union">Unir dimensÃµes</option>
                <option value="single">Uma por vez</option>
              </select>
            </div>
            <div class="field">
              <label>DimensÃ£o ativa</label>
              <select id="activeDim" disabled></select>
            </div>
          </div>

          <div class="range-group">
            <label>Profundidade mÃ¡xima</label>
            <div class="range-row">
              <input id="maxDepth" type="range" min="1" max="16" value="7" disabled />
              <span class="range-val" id="depthLabel">7</span>
              <button id="btnMoreDepth" class="icon" disabled title="+1 nÃ­vel">+</button>
            </div>
          </div>

          <div class="range-group">
            <label>CompactaÃ§Ã£o</label>
            <div class="range-row">
              <input id="compact" type="range" min="0" max="100" value="70" disabled />
              <span class="range-val" id="compactLabel">70</span>
            </div>
          </div>
        </div>
      </div>

      <!-- DimensÃµes -->
      <div class="card">
        <div class="card-header" data-card="dims">
          <span class="card-title">DimensÃµes</span>
          <span class="card-toggle">â–¾</span>
        </div>
        <div class="card-body">
          <div class="btn-group">
            <button id="btnAll" disabled>Todas</button>
            <button id="btnNone" disabled>Nenhuma</button>
          </div>
          <div class="dims-list" id="dimsList">
            <div style="font-size:11px; color:var(--muted);">Carregue uma ontologia para ver as dimensÃµes.</div>
          </div>
        </div>
      </div>

      <!-- Layout e exportaÃ§Ã£o -->
      <div class="card">
        <div class="card-header" data-card="layout">
          <span class="card-title">Layout e exportaÃ§Ã£o</span>
          <span class="card-toggle">â–¾</span>
        </div>
        <div class="card-body">
          <div class="field">
            <label>Layout</label>
            <select id="layoutSelect" disabled>
              <option value="topdown">Top-down</option>
              <option value="leftright">Esquerda â†’ Direita</option>
              <option value="radial">Radial</option>
              <option value="a4">A4 (vertical)</option>
            </select>
          </div>

          <div class="row">
            <div class="range-group" style="flex:1;">
              <label>Curvatura das arestas</label>
              <div class="range-row">
                <input id="edgeCurve" type="range" min="0" max="100" value="18" disabled />
                <span class="range-val" id="curveLabel">18</span>
              </div>
            </div>
            <div class="range-group" style="flex:1;">
              <label>Espessura</label>
              <div class="range-row">
                <input id="edgeWidth" type="range" min="1" max="6" value="2" disabled />
                <span class="range-val" id="widthLabel">2</span>
              </div>
            </div>
          </div>

          <div class="row">
            <div class="field">
              <label>Cor das arestas</label>
              <input id="edgeColor" type="color" value="#1e3a5f" disabled />
            </div>
            <div class="field">
              <label>PersistÃªncia</label>
              <select id="persistSelect">
                <option value="on">Ligada</option>
                <option value="off">Desligada</option>
              </select>
            </div>
          </div>

          <div class="btn-group">
            <button id="btnExportSVG" disabled>Exportar SVG</button>
            <button id="btnExportPNG" disabled>Exportar PNG</button>
          </div>
        </div>
      </div>

      <!-- Editor do nÃ³ -->
      <div class="card" id="editorCard">
        <div class="card-header" data-card="editor">
          <span class="card-title">Editor do nÃ³</span>
          <span class="card-toggle">â–¾</span>
        </div>
        <div class="card-body" id="editorBody">
          <div id="editorHint" style="font-size:11px; color:var(--muted);">Clique em um nÃ³ para editar.</div>

          <div class="field" style="display:none;" id="editorFields">
            <label>Nome (local)</label>
            <input id="edLabel" type="text" />

            <div class="row" style="margin-top:8px;">
              <div class="field">
                <label>Cor (fill)</label>
                <input id="edFill" type="color" value="#334155" />
              </div>
              <div class="field">
                <label>Borda</label>
                <input id="edStroke" type="color" value="#111827" />
              </div>
              <div class="field">
                <label>Opacidade</label>
                <input id="edOpacity" type="range" min="10" max="100" value="92" />
              </div>
            </div>

            <div class="row" style="margin-top:6px;">
              <div class="range-group" style="flex:1;">
                <label>Largura</label>
                <div class="range-row">
                  <input id="edW" type="range" min="70" max="520" value="140" />
                  <span class="range-val" id="edWVal">140</span>
                </div>
              </div>
              <div class="range-group" style="flex:1;">
                <label>Altura</label>
                <div class="range-row">
                  <input id="edH" type="range" min="20" max="100" value="30" />
                  <span class="range-val" id="edHVal">30</span>
                </div>
              </div>
            </div>

            <div class="row" style="margin-top:6px;">
              <div class="range-group" style="flex:1;">
                <label>Fonte (px)</label>
                <div class="range-row">
                  <input id="edFont" type="range" min="10" max="18" value="12" />
                  <span class="range-val" id="edFontVal">12</span>
                </div>
              </div>
              <div class="range-group" style="flex:1;">
                <label>Raio</label>
                <div class="range-row">
                  <input id="edRadius" type="range" min="0" max="22" value="10" />
                  <span class="range-val" id="edRadiusVal">10</span>
                </div>
              </div>
            </div>

            <div class="btn-group" style="margin-top:8px;">
              <button class="primary" id="btnEditorApply">Aplicar</button>
              <button id="btnEditorReset">Reset nÃ³</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Atalhos -->
      <div class="card">
        <div class="card-header" data-card="help">
          <span class="card-title">Atalhos</span>
          <span class="card-toggle">â–¾</span>
        </div>
        <div class="card-body" style="font-size:11px; color:var(--muted); line-height:1.7;">
          <kbd class="kbd">Alt</kbd> + clique â€” abrir/fechar subclasses<br>
          Clique simples â€” selecionar e editar nÃ³<br>
          Arrastar nÃ³ â€” reposicionar<br>
          Scroll â€” zoom<br>
          Arrastar fundo â€” pan
        </div>
      </div>

    </div><!-- /sidebar-body -->
  </aside>

  <!-- ===== MAIN ===== -->
  <main class="main">
    <div class="topbar">
      <div class="stat-pill">
        <div class="dot idle" id="statusDot"></div>
        <span id="loadStatus">pronto</span>
      </div>
      <div class="stat-pill">Zoom <span class="val" id="zoomInfo">100%</span></div>
      <div class="stat-pill">NÃ³s <span class="val" id="nodeCount">0</span></div>
      <div class="stat-pill">Arestas <span class="val" id="edgeCount">0</span></div>
      <div class="stat-pill" id="selPill" style="display:none;">
        Sel: <span class="val" id="selInfo">â€”</span>
      </div>
      <div class="topbar-spacer"></div>
      <div class="stat-pill">
        <kbd class="kbd">Alt</kbd>+clique abre/fecha
      </div>
    </div>

    <div class="loading-bar hidden" id="loadingBar"></div>

    <div id="svgWrap">
      <!-- Empty state -->
      <div class="empty-svg" id="emptyState">
        <div class="empty-icon">ðŸ•¸</div>
        <div class="empty-text">Cole a URL da ontologia OWL/Turtle e clique em <strong>Carregar</strong>.</div>
        <div class="empty-hint">RDF/XML ou Turtle â€¢ subClassOf â€¢ rdfs:label</div>
      </div>

      <svg id="svg"></svg>
      <div id="tooltip" class="tooltip" style="display:none;"></div>
    </div>
  </main>
</div>

<script>
/* =========================================================
   RDF NAMESPACES
========================================================= */
const RDF  = $rdf.Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
const RDFS = $rdf.Namespace("http://www.w3.org/2000/01/rdf-schema#");
const OWL  = $rdf.Namespace("http://www.w3.org/2002/07/owl#");
const SKOS = $rdf.Namespace("http://www.w3.org/2004/02/skos/core#");
const STORE = $rdf.graph();

/* =========================================================
   UI REFS
========================================================= */
const ui = {
  btnTheme:        document.getElementById("btnTheme"),
  dataUrl:         document.getElementById("dataUrl"),
  btnLoad:         document.getElementById("btnLoad"),
  btnFit:          document.getElementById("btnFit"),
  btnReset:        document.getElementById("btnReset"),
  loadStatus:      document.getElementById("loadStatus"),
  statusDot:       document.getElementById("statusDot"),
  loadingBar:      document.getElementById("loadingBar"),
  emptyState:      document.getElementById("emptyState"),
  searchInput:     document.getElementById("searchInput"),
  btnSearchClear:  document.getElementById("btnSearchClear"),
  btnSearchShowAll:document.getElementById("btnSearchShowAll"),
  searchResults:   document.getElementById("searchResults"),
  splitMode:       document.getElementById("splitMode"),
  activeDim:       document.getElementById("activeDim"),
  maxDepth:        document.getElementById("maxDepth"),
  depthLabel:      document.getElementById("depthLabel"),
  btnMoreDepth:    document.getElementById("btnMoreDepth"),
  compact:         document.getElementById("compact"),
  compactLabel:    document.getElementById("compactLabel"),
  dimsList:        document.getElementById("dimsList"),
  btnAll:          document.getElementById("btnAll"),
  btnNone:         document.getElementById("btnNone"),
  layoutSelect:    document.getElementById("layoutSelect"),
  edgeCurve:       document.getElementById("edgeCurve"),
  curveLabel:      document.getElementById("curveLabel"),
  edgeWidth:       document.getElementById("edgeWidth"),
  widthLabel:      document.getElementById("widthLabel"),
  edgeColor:       document.getElementById("edgeColor"),
  persistSelect:   document.getElementById("persistSelect"),
  btnExportSVG:    document.getElementById("btnExportSVG"),
  btnExportPNG:    document.getElementById("btnExportPNG"),
  editorCard:      document.getElementById("editorCard"),
  editorHint:      document.getElementById("editorHint"),
  editorFields:    document.getElementById("editorFields"),
  edLabel:         document.getElementById("edLabel"),
  edFill:          document.getElementById("edFill"),
  edStroke:        document.getElementById("edStroke"),
  edOpacity:       document.getElementById("edOpacity"),
  edW:             document.getElementById("edW"),
  edWVal:          document.getElementById("edWVal"),
  edH:             document.getElementById("edH"),
  edHVal:          document.getElementById("edHVal"),
  edFont:          document.getElementById("edFont"),
  edFontVal:       document.getElementById("edFontVal"),
  edRadius:        document.getElementById("edRadius"),
  edRadiusVal:     document.getElementById("edRadiusVal"),
  btnEditorApply:  document.getElementById("btnEditorApply"),
  btnEditorReset:  document.getElementById("btnEditorReset"),
  zoomInfo:        document.getElementById("zoomInfo"),
  nodeCount:       document.getElementById("nodeCount"),
  edgeCount:       document.getElementById("edgeCount"),
  selInfo:         document.getElementById("selInfo"),
  selPill:         document.getElementById("selPill"),
  tooltip:         document.getElementById("tooltip"),
  svgWrap:         document.getElementById("svgWrap"),
};

/* =========================================================
   STATE â€” centralizado, sem anti-padrÃµes
========================================================= */
const state = {
  loaded: false,
  didFit: false,           // FIX: era rebuildAndRender._didFit
  classNodes:   new Map(),
  subclasses:   new Map(),
  superclasses: new Map(),
  rootIris:     [],   // OPÃ‡ÃƒO B: todas as raÃ­zes reais (nÃ³s sem superclasse)
  dimensions:   [],
  selectedDims: new Set(),
  collapsed:    new Set(),
  customLabels:  new Map(),
  nodePositions: new Map(),
  nodeStyles:    new Map(),
  selectedIri:   null,
  searchIndex:   [],
  labelCount:    new Map(),
  tooltipCache:  new Map(), // FIX: memoizaÃ§Ã£o de tooltips por IRI
};

const DIM_PALETTE = [
  "#38bdf8","#34d399","#fbbf24","#f87171",
  "#a78bfa","#22d3ee","#fb923c","#e879f9",
  "#86efac","#67e8f9","#fca5a5","#c4b5fd"
];
const P = (s) => "hate_taxo_" + s;

/* =========================================================
   HELPERS
========================================================= */
const uniq = arr => [...new Set(arr)];
const escapeHTML = s => String(s)
  .replaceAll("&","&amp;").replaceAll("<","&lt;")
  .replaceAll(">","&gt;").replaceAll('"',"&quot;");

function shrinkIri(iri){
  try{
    const u = new URL(iri);
    const frag = u.hash ? u.hash.slice(1) : "";
    if (frag) return frag;
    const parts = u.pathname.split("/").filter(Boolean);
    return parts[parts.length-1] || iri;
  }catch{ return iri; }
}
function getLiterals(s,p){ return STORE.each(s,p,null).filter(o=>o.termType==="Literal").map(o=>o.value); }
function getFirstLiteral(s,p){ return getLiterals(s,p)[0]||""; }
function termLabel(iri){
  if(iri==="__multi_root__") return ""; // nÃ³ raiz virtual â€” sem label
  if (state.customLabels.has(iri)) return state.customLabels.get(iri);
  const n = state.classNodes.get(iri);
  const base = n?.label || shrinkIri(iri);
  return (state.labelCount.get(base)||0) > 1 ? `${base} Â· ${shrinkIri(iri)}` : base;
}
function persistEnabled(){ return ui.persistSelect.value==="on"; }

/* =========================================================
   THEME
========================================================= */
function setTheme(theme, persist=true){
  document.body.setAttribute("data-theme", theme);
  ui.btnTheme.textContent = theme==="dark" ? "â˜€" : "â˜¾";
  if (persist) localStorage.setItem(P("theme"), theme);
}
ui.btnTheme.addEventListener("click", ()=>{
  const cur = document.body.getAttribute("data-theme")||"dark";
  setTheme(cur==="dark"?"light":"dark");
  state.tooltipCache.clear();
  renderGraph(_lastD3Root);
});

/* =========================================================
   STATUS / LOADING
========================================================= */
function setStatus(text, mode="ok"){
  ui.loadStatus.textContent = text;
  ui.statusDot.className = "dot " + (mode==="ok"?"":mode==="loading"?"loading":"error");
}
function setLoading(on){
  ui.loadingBar.classList.toggle("hidden",!on);
  if(on) setStatus("carregandoâ€¦","loading");
}

const CONTROLS = [
  "searchInput","btnSearchClear","btnSearchShowAll",
  "splitMode","activeDim","maxDepth","btnMoreDepth","compact",
  "btnAll","btnNone","layoutSelect","edgeCurve","edgeWidth","edgeColor",
  "btnExportSVG","btnExportPNG"
];
function enableControls(on){ CONTROLS.forEach(id=>{ ui[id].disabled=!on; }); }

/* =========================================================
   PERSISTENCE
========================================================= */
function loadPersisted(){
  if (!persistEnabled()) return;
  try{
    state.customLabels  = new Map(Object.entries(JSON.parse(localStorage.getItem(P("labels"))||"{}")));
    state.collapsed     = new Set(JSON.parse(localStorage.getItem(P("collapsed"))||"[]"));
    state.nodePositions = new Map(Object.entries(JSON.parse(localStorage.getItem(P("positions"))||"{}")));
    state.nodeStyles    = new Map(Object.entries(JSON.parse(localStorage.getItem(P("styles"))||"{}")));
    const t = localStorage.getItem(P("theme"));
    if (t==="light"||t==="dark") setTheme(t,false);
  }catch(e){ console.warn("Persist load failed:",e); }
}
function savePersisted(){
  if (!persistEnabled()) return;
  try{
    localStorage.setItem(P("labels"),    JSON.stringify(Object.fromEntries(state.customLabels)));
    localStorage.setItem(P("collapsed"), JSON.stringify([...state.collapsed]));
    localStorage.setItem(P("positions"), JSON.stringify(Object.fromEntries(state.nodePositions)));
    localStorage.setItem(P("styles"),    JSON.stringify(Object.fromEntries(state.nodeStyles)));
  }catch(e){}
}
function saveDimsPersisted(){
  if (!persistEnabled()) return;
  const obj={};
  state.dimensions.forEach(d=>{ obj[d.iri]={color:d.color, selected:state.selectedDims.has(d.iri)}; });
  localStorage.setItem(P("dims"), JSON.stringify(obj));
}
function clearPersisted(){
  ["labels","collapsed","positions","styles","dims","theme"].forEach(k=>localStorage.removeItem(P(k)));
}

/* =========================================================
   COLLAPSIBLE CARDS
========================================================= */
document.querySelectorAll(".card-header").forEach(h=>{
  h.addEventListener("click", ()=>h.closest(".card").classList.toggle("collapsed"));
});

/* =========================================================
   RANGE LIVE VALUES
========================================================= */
[["maxDepth","depthLabel"],["compact","compactLabel"],
 ["edgeCurve","curveLabel"],["edgeWidth","widthLabel"],
 ["edW","edWVal"],["edH","edHVal"],["edFont","edFontVal"],["edRadius","edRadiusVal"],
].forEach(([inp,lbl])=>{
  const i=document.getElementById(inp), l=document.getElementById(lbl);
  if(i&&l) i.addEventListener("input",()=>l.textContent=i.value);
});

/* =========================================================
   SVG + ZOOM
========================================================= */
const svg   = d3.select("#svg");
const svgEl = document.getElementById("svg");
const wrap  = ui.svgWrap;
const gRoot  = svg.append("g").attr("class","gRoot");
const gLinks = gRoot.append("g").attr("class","links");
const gNodes = gRoot.append("g").attr("class","nodes");
let viewW=1000, viewH=800;
let _lastD3Root = null; // guarda o Ãºltimo root para re-render sem rebuild

const zoom = d3.zoom().scaleExtent([0.12,5]).on("zoom",(e)=>{
  gRoot.attr("transform",e.transform);
  ui.zoomInfo.textContent = Math.round(e.transform.k*100)+"%";
});
svg.call(zoom);

function resize(){
  const r=wrap.getBoundingClientRect();
  viewW=r.width||1000; viewH=r.height||800;
  svg.attr("viewBox",`0 0 ${viewW} ${viewH}`);
}
window.addEventListener("resize",()=>{ resize(); if(state.loaded) rebuildAndRender(); });

/* =========================================================
   TEXT MEASUREMENT â€” com font correta e cache
   FIX: font resetada antes de cada batch de mediÃ§Ãµes
========================================================= */
const _mCtx  = document.createElement("canvas").getContext("2d");
const _mCache = new Map();
function measureTextWidth(text, fontPx){
  const key=`${fontPx}|${text}`;
  if(_mCache.has(key)) return _mCache.get(key);
  // FIX: define a fonte explicitamente, sem depender de estado anterior do canvas
  _mCtx.font = `600 ${fontPx}px Syne, ui-sans-serif, sans-serif`;
  const w=_mCtx.measureText(text).width;
  _mCache.set(key,w);
  return w;
}
function computeAutoNodeSize(iri){
  const st=state.nodeStyles.get(iri)||{};
  if(st.w&&st.h) return {w:st.w,h:st.h};
  const font=st.font??12, label=termLabel(iri);
  const maxLW=140, padX=16, padY=10, lineH=Math.round(font*1.25);
  const words=label.split(/\s+/).filter(Boolean);
  let l1="",l2="";
  for(const w of words){
    const c=(l1?l1+" ":"")+w;
    if(measureTextWidth(c,font)<=maxLW) l1=c; else l2=(l2?l2+" ":"")+w;
  }
  if(!l1) l1=label;
  const w=Math.max(80,Math.ceil(Math.max(measureTextWidth(l1,font),l2?measureTextWidth(l2,font):0)+padX));
  const h=Math.max(24,Math.ceil((l2?2:1)*lineH+padY));
  return {w,h};
}

/* =========================================================
   RDF LOADING
========================================================= */
async function loadData(url){
  setLoading(true);
  ui.emptyState.style.display="none";
  while(STORE.statements.length) STORE.statements.pop();

  const res=await fetch(url,{cache:"no-store"});
  if(!res.ok) throw new Error(`HTTP ${res.status} ao buscar ${url}`);
  const data=await res.text();

  let parsed=false;
  for(const fmt of ["application/rdf+xml","text/turtle"]){
    try{ $rdf.parse(data,STORE,url,fmt); parsed=true; break; }catch{}
  }
  if(!parsed) throw new Error("Formato nÃ£o reconhecido. Use RDF/XML ou Turtle.");

  state.classNodes.clear(); state.subclasses.clear();
  state.superclasses.clear(); state.labelCount.clear(); state.tooltipCache.clear();

  const classSet=new Set();
  STORE.each(null,RDF("type"),OWL("Class")).forEach(s=>classSet.add(s.value));
  STORE.each(null,RDF("type"),RDFS("Class")).forEach(s=>classSet.add(s.value));
  STORE.statementsMatching(null,RDFS("subClassOf"),null).forEach(st=>{
    classSet.add(st.subject.value);
    if(st.object.termType==="NamedNode") classSet.add(st.object.value);
  });

  for(const iri of classSet){
    const s=$rdf.sym(iri);
    const label=getFirstLiteral(s,RDFS("label"))||getFirstLiteral(s,SKOS("prefLabel"))||"";
    state.classNodes.set(iri,{iri,label,comment:getLiterals(s,RDFS("comment"))});
    state.subclasses.set(iri,new Set());
    state.superclasses.set(iri,new Set());
    const key=label||shrinkIri(iri);
    state.labelCount.set(key,(state.labelCount.get(key)||0)+1);
  }

  STORE.statementsMatching(null,RDFS("subClassOf"),null).forEach(st=>{
    if(st.subject.termType!=="NamedNode"||st.object.termType!=="NamedNode") return;
    const c=st.subject.value, p=st.object.value;
    if(!state.classNodes.has(c)||!state.classNodes.has(p)) return;
    state.subclasses.get(p).add(c);
    state.superclasses.get(c).add(p);
  });

  // OPÃ‡ÃƒO B: coleta TODAS as raÃ­zes (nÃ³s sem nenhuma superclasse conhecida).
  // Cada raiz vira uma dimensÃ£o de topo independente â€” nenhuma Ã© descartada.
  state.rootIris = [];
  for(const iri of state.classNodes.keys()){
    const supers=[...(state.superclasses.get(iri)||new Set())].filter(x=>state.classNodes.has(x));
    if(!supers.length) state.rootIris.push(iri);
  }
  if(!state.rootIris.length) throw new Error("Nenhuma classe encontrada.");

  buildDimensions(); buildSearchIndex();
  state.loaded=true; state.didFit=false;
  enableControls(true);
  setStatus(`${state.classNodes.size} classes`,"ok");
  setLoading(false);
  rebuildAndRender();
}

/* =========================================================
   DIMENSIONS
========================================================= */
function countDescendants(iri){
  let n=0; const q=[...(state.subclasses.get(iri)||new Set())], vis=new Set([iri]);
  while(q.length){ const x=q.shift(); if(vis.has(x)) continue; vis.add(x); n++;
    (state.subclasses.get(x)||new Set()).forEach(c=>q.push(c)); }
  return n;
}

function buildDimensions(){
  let saved={};
  if(persistEnabled()){ try{ saved=JSON.parse(localStorage.getItem(P("dims"))||"{}"); }catch{} }

  // OPÃ‡ÃƒO B: dimensÃµes = filhos diretos de TODAS as raÃ­zes detectadas.
  // RaÃ­zes sem filhos entram elas mesmas como dimensÃ£o.
  // Assim hierarquias paralelas (ex: UFO + domÃ­nio) ficam todas acessÃ­veis.
  const dimSet = new Set();
  for(const rootIri of state.rootIris){
    const kids=[...(state.subclasses.get(rootIri)||new Set())].filter(i=>state.classNodes.has(i));
    if(kids.length > 0){
      // Raiz com filhos: os filhos directos sÃ£o as dimensÃµes
      kids.forEach(k=>dimSet.add(k));
    } else {
      // Raiz folha ou isolada: ela mesma Ã© uma dimensÃ£o
      dimSet.add(rootIri);
    }
    // A raiz em si tambÃ©m entra como dimensÃ£o de topo (para navegaÃ§Ã£o)
    dimSet.add(rootIri);
  }
  state.dimensions=[...dimSet].filter(i=>state.classNodes.has(i)).map((iri,idx)=>({
    iri, label:termLabel(iri),
    color:saved[iri]?.color||DIM_PALETTE[idx%DIM_PALETTE.length],
    count:countDescendants(iri),
  })).sort((a,b)=>a.label.localeCompare(b.label,"pt-BR"));

  state.selectedDims=Object.keys(saved).length
    ? new Set(Object.entries(saved).filter(([,v])=>v.selected).map(([k])=>k))
    : new Set();

  ui.activeDim.innerHTML="";
  state.dimensions.forEach(d=>{
    const opt=document.createElement("option");
    opt.value=d.iri; opt.textContent=d.label;
    ui.activeDim.appendChild(opt);
  });
  if(state.dimensions.length){
    const fs=[...state.selectedDims][0];
    ui.activeDim.value=(fs&&state.dimensions.some(x=>x.iri===fs))?fs:state.dimensions[0].iri;
  }
  renderDimsList();
}

function renderDimsList(){
  ui.dimsList.innerHTML="";
  if(!state.dimensions.length){
    ui.dimsList.innerHTML=`<div style="font-size:11px;color:var(--muted)">Nenhuma dimensÃ£o.</div>`; return;
  }
  state.dimensions.forEach(dim=>{
    const isOn=state.selectedDims.has(dim.iri);
    const row=document.createElement("div"); row.className="dim-item"+(isOn?" active":"");
    const cb=document.createElement("input"); cb.type="checkbox"; cb.checked=isOn;
    cb.addEventListener("change",()=>{
      if(cb.checked) state.selectedDims.add(dim.iri); else state.selectedDims.delete(dim.iri);
      if(ui.splitMode.value==="single"&&cb.checked) ui.activeDim.value=dim.iri;
      saveDimsPersisted(); renderDimsList(); rebuildAndRender();
    });
    const sw=document.createElement("input"); sw.type="color"; sw.value=dim.color;
    sw.style.cssText="width:20px;height:20px;padding:1px;border-radius:4px;border:1px solid var(--border2);";
    sw.addEventListener("input",()=>{ dim.color=sw.value; saveDimsPersisted(); state.tooltipCache.clear(); rebuildAndRender(); });
    const nm=document.createElement("div"); nm.className="dim-name"; nm.textContent=dim.label;
    const ct=document.createElement("div"); ct.className="dim-count"; ct.textContent=dim.count;
    row.append(cb,sw,nm,ct); ui.dimsList.appendChild(row);
  });
}

/* =========================================================
   TREE BUILD â€” iterativo (FIX: sem recursÃ£o profunda)
========================================================= */
function buildTreeData(){
  const maxDepth=+ui.maxDepth.value, mode=ui.splitMode.value;
  const dimRoots=mode==="single"
    ? (ui.activeDim.value?[ui.activeDim.value]:[])
    : [...state.selectedDims];

  // FIX: BFS iterativo em vez de recursÃ£o â€” evita stack overflow em ontologias profundas
  function buildSubBFS(startIri, startDepth, globalVisited){
    const rootNode={iri:startIri,depth:startDepth,children:[]};
    const queue=[{iri:startIri,depth:startDepth,node:rootNode}];
    globalVisited.add(startIri);
    while(queue.length){
      const {iri,depth,node}=queue.shift();
      if(state.collapsed.has(iri)||depth>=maxDepth) continue;
      const kids=[...(state.subclasses.get(iri)||new Set())]
        .filter(k=>state.classNodes.has(k)&&!globalVisited.has(k));
      for(const kid of kids){
        globalVisited.add(kid);
        const childNode={iri:kid,depth:depth+1,children:[]};
        node.children.push(childNode);
        queue.push({iri:kid,depth:depth+1,node:childNode});
      }
    }
    return rootNode;
  }

  // OPÃ‡ÃƒO B: visited comeÃ§a com TODAS as raÃ­zes para evitar duplicaÃ§Ã£o entre hierarquias.
  // Um nÃ³ virtual "__root__" agrega todas as dimensÃµes selecionadas como filhos de nÃ­vel 0.
  const VIRTUAL_ROOT = "__multi_root__";
  const visited = new Set(state.rootIris); // bloqueia todas as raÃ­zes reais da deduplicaÃ§Ã£o
  const children = [];
  for(const dimIri of dimRoots){
    if(!state.classNodes.has(dimIri)) continue;
    // Se a prÃ³pria raiz Ã© uma das dimensÃµes, comeÃ§a dela (depth=0 relativo)
    const isRoot = state.rootIris.includes(dimIri);
    if(isRoot){
      // Raiz real: seus filhos entram como filhos diretos do nÃ³ virtual
      const rootKids = [...(state.subclasses.get(dimIri)||new Set())]
        .filter(k=>state.classNodes.has(k)&&!visited.has(k));
      // Adiciona a raiz em si como nÃ³ de profundidade 1 (com seus filhos)
      if(!visited.has(dimIri)){
        visited.add(dimIri);
        children.push(buildSubBFS(dimIri, 1, visited));
      }
    } else {
      if(visited.has(dimIri)) continue;
      children.push(buildSubBFS(dimIri, 1, visited));
    }
  }
  return {iri:VIRTUAL_ROOT, label:"(raiz)", depth:0, children};
}

/* =========================================================
   DIM COLOR MAP
========================================================= */
function buildDimColorMap(){
  const map=new Map(), mode=ui.splitMode.value;
  for(const dim of state.dimensions){
    if(mode==="union"&&!state.selectedDims.has(dim.iri)) continue;
    if(mode==="single"&&dim.iri!==ui.activeDim.value) continue;
    const q=[dim.iri];
    while(q.length){ const i=q.shift(); if(map.has(i)) continue; map.set(i,dim.color);
      (state.subclasses.get(i)||new Set()).forEach(c=>{ if(state.classNodes.has(c)) q.push(c); }); }
  }
  // OPÃ‡ÃƒO B: o nÃ³ virtual nÃ£o aparece no mapa de cores; raÃ­zes reais ganham cor prÃ³pria via dimensÃµes
  state.rootIris.forEach(r => { if(!map.has(r)) map.set(r, "#475569"); });
  return map;
}

/* =========================================================
   LAYOUT COMPUTATION â€” funÃ§Ã£o pura, separada do render
========================================================= */
function computeLayout(treeData){
  const layout=ui.layoutSelect.value;
  const compact=+ui.compact.value/100;
  const gapX=Math.round(40-28*compact), gapY=Math.round(60-38*compact);
  const root=d3.hierarchy(treeData,d=>d.children);
  const sample=root.descendants().slice(0,Math.min(60,root.descendants().length))
    .map(d=>computeAutoNodeSize(d.data.iri));
  const avgW=sample.length?sample.reduce((a,b)=>a+b.w,0)/sample.length:120;
  const avgH=sample.length?sample.reduce((a,b)=>a+b.h,0)/sample.length:28;
  let sepX=Math.max(70,Math.round(avgW+gapX));
  let sepY=Math.max(60,Math.round(avgH+gapY));
  if(layout==="a4"){ sepX+=10; sepY+=14; }

  if(layout==="radial"){
    const radius=Math.min(viewW,viewH)/2-80;
    d3.tree().size([2*Math.PI,Math.max(120,radius)])(root);
    const cx=viewW/2,cy=viewH/2;
    root.descendants().forEach(d=>{ const r=d.y,a=d.x; d.x=cx+r*Math.cos(a-Math.PI/2); d.y=cy+r*Math.sin(a-Math.PI/2); });
  } else {
    d3.tree().nodeSize([sepX,sepY])(root);
    const cx=viewW/2,cy=viewH/2;
    root.descendants().forEach(d=>{
      if(layout==="leftright"){ const tx=d.x; d.x=40+d.y; d.y=cy+tx; }
      else { d.x=cx+d.x; d.y=40+d.y; }
    });
  }

  // PosiÃ§Ãµes manuais (drag)
  root.descendants().forEach(d=>{
    const key=`${layout}|${d.data.iri}`;
    if(state.nodePositions.has(key)){ const p=state.nodePositions.get(key); d.x=p.x; d.y=p.y; }
  });
  return root;
}

/* =========================================================
   TOOLTIP â€” memoizado por IRI
   FIX: recalcula apenas na primeira chamada, invalida ao editar/mudar tema
========================================================= */
function getTooltipHTML(iri){
  if(iri==="__multi_root__") return "";
  if(state.tooltipCache.has(iri)) return state.tooltipCache.get(iri);
  const s=$rdf.sym(iri);
  const label=termLabel(iri);
  const comments=uniq(getLiterals(s,RDFS("comment")));
  const supers=uniq([...(state.superclasses.get(iri)||new Set())]).map(termLabel).sort();
  const subs=uniq([...(state.subclasses.get(iri)||new Set())]).map(termLabel).sort();
  const objProps=STORE.each(null,RDF("type"),OWL("ObjectProperty")).map(x=>x.value);
  const dtProps =STORE.each(null,RDF("type"),OWL("DatatypeProperty")).map(x=>x.value);
  function getConn(props){ const dom=[],rng=[];
    props.forEach(pIri=>{ const p=$rdf.sym(pIri);
      STORE.each(p,RDFS("domain"),null).filter(x=>x.termType==="NamedNode").map(x=>x.value).forEach(v=>{ if(v===iri) dom.push(pIri); });
      STORE.each(p,RDFS("range"),null).filter(x=>x.termType==="NamedNode").map(x=>x.value).forEach(v=>{ if(v===iri) rng.push(pIri); });
    }); return {dom,rng}; }
  const {dom:dObj,rng:rObj}=getConn(objProps);
  const {dom:dDt}=getConn(dtProps);
  function pLine(pIri){ const p=$rdf.sym(pIri); const pl=getFirstLiteral(p,RDFS("label"))||shrinkIri(pIri);
    return `<div class="t-item">${escapeHTML(pl)}</div>`; }
  const parts=[`<div class="t-title">${escapeHTML(label)}</div>`,`<div class="t-iri">${escapeHTML(shrinkIri(iri))}</div>`];
  const sec=(title,items)=>{ if(!items?.length) return; parts.push(`<hr/><div class="t-sec">${escapeHTML(title)}</div>`);
    items.slice(0,12).forEach(it=>parts.push(it));
    if(items.length>12) parts.push(`<div style="color:var(--muted);font-size:10px">+${items.length-12}</div>`); };
  if(comments.length){ parts.push(`<hr/><div class="t-sec">DescriÃ§Ã£o</div>`);
    comments.slice(0,2).forEach(c=>parts.push(`<div style="font-size:11px">${escapeHTML(c)}</div>`)); }
  sec("Superclasses",supers.map(x=>`<div class="t-item">${escapeHTML(x)}</div>`));
  sec("Subclasses",subs.map(x=>`<div class="t-item">${escapeHTML(x)}</div>`));
  sec("ObjectProp Â· Domain",dObj.map(pLine)); sec("ObjectProp Â· Range",rObj.map(pLine));
  sec("DatatypeProp Â· Domain",dDt.map(pLine));
  const html=parts.join(""); state.tooltipCache.set(iri,html); return html;
}

/* =========================================================
   RENDER â€” recebe d3Root prÃ©-calculado
========================================================= */
function renderGraph(d3Root){
  if(!d3Root) return;
  _lastD3Root=d3Root;
  const layout=ui.layoutSelect.value;
  const curve=+ui.edgeCurve.value/100, strokeW=+ui.edgeWidth.value, edgeCol=ui.edgeColor.value;
  const dimMap=buildDimColorMap();
  const allNodes=d3Root.descendants(), allLinks=d3Root.links();
  ui.nodeCount.textContent=allNodes.length; ui.edgeCount.textContent=allLinks.length;

  function lp(s,t){ const dx=t.x-s.x,dy=t.y-s.y;
    return `M${s.x},${s.y} C${s.x+dx*curve},${s.y+dy*(1-curve)} ${s.x+dx*(1-curve)},${s.y+dy*curve} ${t.x},${t.y}`; }

  // LINKS
  // OPÃ‡ÃƒO B: esconde arestas que partem do nÃ³ virtual (raiz oculta)
  const visibleLinks = allLinks.filter(l=>l.source.data.iri!=="__multi_root__");
  const linkSel=gLinks.selectAll("path.link").data(visibleLinks,d=>d.target.data.iri);
  linkSel.exit().remove();
  linkSel.enter().append("path").attr("class","link").merge(linkSel)
    .attr("stroke",edgeCol).attr("stroke-width",strokeW).attr("d",d=>lp(d.source,d.target));

  // NODES
  const nodeSel=gNodes.selectAll("g.node").data(allNodes,d=>d.data.iri);
  nodeSel.exit().remove();
  const nodeEnter=nodeSel.enter().append("g").attr("class","node").style("cursor","pointer")
    .on("mousemove",(event,d)=>{
      if(d.data.iri==="__multi_root__") return;
      const r=wrap.getBoundingClientRect();
      ui.tooltip.innerHTML=getTooltipHTML(d.data.iri); // FIX: memoizado
      ui.tooltip.style.cssText=`display:block;left:${event.clientX-r.left+14}px;top:${event.clientY-r.top+14}px;`;
    })
    .on("mouseleave",()=>{ ui.tooltip.style.display="none"; })
    .on("click",(event,d)=>{ event.stopPropagation(); if(d.data.iri==="__multi_root__") return; if(event.altKey) toggleCollapse(d.data.iri); else selectNode(d.data.iri); })
    .call(d3.drag()
      .on("start",e=>e.sourceEvent?.stopPropagation())
      .on("drag",(event,d)=>{
        d.x=event.x; d.y=event.y;
        state.nodePositions.set(`${layout}|${d.data.iri}`,{x:d.x,y:d.y}); savePersisted();
        d3.select(event.sourceEvent.target.closest("g.node")).attr("transform",`translate(${d.x},${d.y})`);
        gLinks.selectAll("path.link").attr("d",l=>lp(l.source,l.target));
      }));
  nodeEnter.append("rect"); nodeEnter.append("text").attr("text-anchor","middle");

  const nm=nodeEnter.merge(nodeSel)
    .attr("transform",d=>`translate(${d.x},${d.y})`)
    .classed("selected",d=>d.data.iri===state.selectedIri);

  nm.select("rect").each(function(d){
    const iri=d.data.iri;
    // OPÃ‡ÃƒO B: nÃ³ raiz virtual Ã© invisÃ­vel â€” serve sÃ³ como Ã¢ncora de layout
    if(iri==="__multi_root__"){ d3.select(this).attr("width",0).attr("height",0).attr("opacity",0); return; }
    const st=state.nodeStyles.get(iri)||{}, auto=computeAutoNodeSize(iri);
    const w=st.w??auto.w, h=st.h??auto.h, r=st.radius??8;
    d3.select(this).attr("width",w).attr("height",h).attr("x",-w/2).attr("y",-h/2)
      .attr("rx",r).attr("ry",r).attr("fill",st.fill??(dimMap.get(iri)||"#475569"))
      .attr("opacity",state.rootIris.includes(iri)?0.55:((st.opacity??92)/100))
      .attr("stroke",st.stroke||"var(--node-stroke)");
  });

  // FIX: limpa tspans antes de renderizar
  nm.select("text").each(function(d){
    const iri=d.data.iri, st=state.nodeStyles.get(iri)||{};
    const font=st.font??12, auto=computeAutoNodeSize(iri);
    const maxLW=Math.max(90,(st.w??auto.w)-16), label=termLabel(iri);
    const text=d3.select(this);
    text.selectAll("*").remove(); // FIX: limpa antes de re-render
    text.style("font-size",font+"px").style("font-family","var(--font-display)");
    const words=label.split(/\s+/).filter(Boolean); let l1="",l2="";
    for(const w of words){ const c=(l1?l1+" ":"")+w; if(measureTextWidth(c,font)<=maxLW) l1=c; else l2=(l2?l2+" ":"")+w; }
    if(!l1) l1=label;
    if(l2&&measureTextWidth(l2,font)>maxLW){ while(l2.length&&measureTextWidth(l2+"â€¦",font)>maxLW) l2=l2.slice(0,-1); l2=l2.trim()+"â€¦"; }
    text.attr("dominant-baseline","middle");
    if(!l2){ text.append("tspan").attr("x",0).attr("dy","0em").text(l1); }
    else { text.append("tspan").attr("x",0).attr("dy","-0.3em").text(l1);
           text.append("tspan").attr("x",0).attr("dy","1.35em").text(l2); }
  });
}

/* =========================================================
   REBUILD AND RENDER â€” orquestra as 3 fases
========================================================= */
function rebuildAndRender(){
  if(!state.loaded) return;
  ui.depthLabel.textContent=ui.maxDepth.value;
  const treeData=buildTreeData();        // Fase 1: dados
  const d3Root=computeLayout(treeData);  // Fase 2: layout
  renderGraph(d3Root);                   // Fase 3: DOM
  // FIX: state.didFit em vez de _didFit na funÃ§Ã£o
  if(!state.didFit){ fitToView(); state.didFit=true; }
}

/* =========================================================
   FIT / RESET
========================================================= */
function getContentBBox(){
  try{ const b=gRoot.node().getBBox(); return {x:b.x,y:b.y,w:b.width,h:b.height}; }
  catch{ return {x:0,y:0,w:viewW,h:viewH}; }
}
function fitToView(){
  const bb=getContentBBox(); if(!isFinite(bb.w)||bb.w<=0) return;
  const pad=60, s=Math.min(0.95,Math.max(0.12,Math.min(viewW/(bb.w+pad),(viewH-52)/(bb.h+pad))));
  svg.transition().duration(300).call(zoom.transform,d3.zoomIdentity
    .translate(viewW/2-s*(bb.x+bb.w/2),viewH/2-s*(bb.y+bb.h/2)).scale(s));
}
function resetAll(){
  clearPersisted();
  state.customLabels.clear(); state.collapsed.clear();
  state.nodePositions.clear(); state.nodeStyles.clear();
  state.tooltipCache.clear(); state.selectedIri=null; state.didFit=false;
  ui.selPill.style.display="none";
  ui.editorCard.classList.add("locked"); ui.editorFields.style.display="none";
  ui.editorHint.textContent="Clique em um nÃ³ para editar.";
  buildDimensions(); rebuildAndRender();
}

/* =========================================================
   COLLAPSE / SELECT / EDITOR
========================================================= */
function toggleCollapse(iri){ if(state.collapsed.has(iri)) state.collapsed.delete(iri); else state.collapsed.add(iri); savePersisted(); rebuildAndRender(); }
function selectNode(iri){ state.selectedIri=iri; ui.selPill.style.display=""; ui.selInfo.textContent=termLabel(iri); openEditorFor(iri); rebuildAndRender(); }
function openEditorFor(iri){
  ui.editorCard.classList.remove("locked");
  ui.editorHint.textContent=shrinkIri(iri);
  ui.editorFields.style.display="flex"; ui.editorFields.style.flexDirection="column"; ui.editorFields.style.gap="6px";
  const st=state.nodeStyles.get(iri)||{}, auto=computeAutoNodeSize(iri);
  ui.edLabel.value=state.customLabels.get(iri)||state.classNodes.get(iri)?.label||shrinkIri(iri);
  ui.edFill.value=st.fill||"#334155";
  ui.edStroke.value=(st.stroke&&st.stroke.startsWith("#"))?st.stroke:"#111827";
  ui.edOpacity.value=st.opacity??92;
  ui.edW.value=st.w??auto.w; ui.edWVal.textContent=ui.edW.value;
  ui.edH.value=st.h??auto.h; ui.edHVal.textContent=ui.edH.value;
  ui.edFont.value=st.font??12; ui.edFontVal.textContent=ui.edFont.value;
  ui.edRadius.value=st.radius??8; ui.edRadiusVal.textContent=ui.edRadius.value;
}
ui.btnEditorApply.addEventListener("click",()=>{
  const iri=state.selectedIri; if(!iri) return;
  const lbl=ui.edLabel.value.trim(); if(lbl) state.customLabels.set(iri,lbl); else state.customLabels.delete(iri);
  state.nodeStyles.set(iri,{fill:ui.edFill.value,stroke:ui.edStroke.value,opacity:+ui.edOpacity.value,w:+ui.edW.value,h:+ui.edH.value,font:+ui.edFont.value,radius:+ui.edRadius.value});
  state.tooltipCache.delete(iri); _mCache.clear(); // invalida cache de mediÃ§Ã£o ao mudar font
  savePersisted(); rebuildAndRender();
});
ui.btnEditorReset.addEventListener("click",()=>{
  const iri=state.selectedIri; if(!iri) return;
  state.customLabels.delete(iri); state.nodeStyles.delete(iri); state.tooltipCache.delete(iri);
  savePersisted(); openEditorFor(iri); rebuildAndRender();
});

/* =========================================================
   SEARCH
========================================================= */
function buildSearchIndex(){ state.searchIndex=[...state.classNodes.keys()]
  .map(iri=>({iri,label:termLabel(iri),iriShort:shrinkIri(iri)}))
  .sort((a,b)=>a.label.localeCompare(b.label,"pt-BR")); }

function renderSearchResults(items){
  const box=ui.searchResults; box.innerHTML="";
  if(!items.length){ box.innerHTML=`<div class="search-item"><span class="s-label" style="color:var(--muted)">Nenhum resultado</span></div>`; }
  else { items.slice(0,40).forEach(it=>{
    const r=document.createElement("div"); r.className="search-item";
    r.innerHTML=`<span class="s-label">${escapeHTML(it.label)}</span><span class="s-tag">${escapeHTML(it.iriShort)}</span>`;
    r.addEventListener("click",()=>{ selectNode(it.iri); zoomToNode(it.iri); }); box.appendChild(r); }); }
  box.style.display="block";
}
function zoomToNode(iri){
  const node=gNodes.selectAll("g.node").filter(d=>d.data.iri===iri).node(); if(!node) return;
  const tr=node.getCTM(), bb=node.getBBox();
  const x=tr.e+bb.x+bb.width/2, y=tr.f+bb.y+bb.height/2;
  const k=Math.max(0.8,Math.min(2.5,d3.zoomTransform(svgEl).k));
  svg.transition().duration(300).call(zoom.transform,d3.zoomIdentity.translate(viewW/2-k*x,viewH/2-k*y).scale(k));
}

/* =========================================================
   EXPORT â€” FIX: PX_RATIO como constante configurÃ¡vel
========================================================= */
const EXPORT_PX_RATIO = 2; // Mude para 3-4 para qualidade de impressÃ£o

function downloadBlob(blob,filename){ const url=URL.createObjectURL(blob),a=document.createElement("a");
  a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }

function buildExportClone(){
  const bb=getContentBBox(), m=48;
  const w=Math.max(10,bb.w+m*2), h=Math.max(10,bb.h+m*2);
  const clone=svgEl.cloneNode(true);
  clone.setAttribute("xmlns","http://www.w3.org/2000/svg");
  clone.setAttribute("viewBox",`0 0 ${w} ${h}`);
  const bg=document.createElementNS("http://www.w3.org/2000/svg","rect");
  bg.setAttribute("x",0); bg.setAttribute("y",0); bg.setAttribute("width",w); bg.setAttribute("height",h);
  bg.setAttribute("fill",getComputedStyle(document.body).getPropertyValue("--bg").trim()||"#07090f");
  clone.insertBefore(bg,clone.firstChild);
  const g=clone.querySelector("g.gRoot"); if(g) g.setAttribute("transform",`translate(${m-bb.x},${m-bb.y})`);
  return {clone,w,h};
}
function exportSVG(){ const {clone}=buildExportClone();
  downloadBlob(new Blob([new XMLSerializer().serializeToString(clone)],{type:"image/svg+xml;charset=utf-8"}),`ontohate_${ui.layoutSelect.value}.svg`); }
function exportPNG(){
  const {clone,w,h}=buildExportClone();
  const url=URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(clone)],{type:"image/svg+xml;charset=utf-8"}));
  const img=new Image();
  img.onload=()=>{
    const c=document.createElement("canvas"); c.width=Math.ceil(w*EXPORT_PX_RATIO); c.height=Math.ceil(h*EXPORT_PX_RATIO);
    const ctx=c.getContext("2d"); ctx.setTransform(EXPORT_PX_RATIO,0,0,EXPORT_PX_RATIO,0,0); ctx.drawImage(img,0,0);
    c.toBlob(b=>{ downloadBlob(b,`ontohate_${ui.layoutSelect.value}.png`); URL.revokeObjectURL(url); },"image/png");
  };
  img.onerror=()=>{ URL.revokeObjectURL(url); alert("Falha ao exportar PNG. Tente SVG."); };
  img.src=url;
}

/* =========================================================
   EVENT BINDINGS
========================================================= */
ui.btnLoad.addEventListener("click",async()=>{
  try{ loadPersisted(); await loadData(ui.dataUrl.value.trim()); }
  catch(e){ setStatus("erro","error"); setLoading(false); alert(e.message||String(e)); }
});
ui.btnFit.addEventListener("click",fitToView);
ui.btnReset.addEventListener("click",resetAll);
ui.btnAll.addEventListener("click",()=>{ state.dimensions.forEach(d=>state.selectedDims.add(d.iri)); saveDimsPersisted(); renderDimsList(); rebuildAndRender(); });
ui.btnNone.addEventListener("click",()=>{ state.selectedDims.clear(); saveDimsPersisted(); renderDimsList(); rebuildAndRender(); });
ui.splitMode.addEventListener("change",rebuildAndRender);
ui.activeDim.addEventListener("change",()=>{
  if(ui.splitMode.value==="single"){ state.selectedDims.add(ui.activeDim.value); saveDimsPersisted(); renderDimsList(); }
  rebuildAndRender();
});
ui.maxDepth.addEventListener("input",rebuildAndRender);
ui.btnMoreDepth.addEventListener("click",()=>{ ui.maxDepth.value=String(Math.min(+ui.maxDepth.max,+ui.maxDepth.value+1)); rebuildAndRender(); });
ui.compact.addEventListener("input",rebuildAndRender);
ui.layoutSelect.addEventListener("change",()=>{ state.didFit=false; rebuildAndRender(); });
ui.edgeCurve.addEventListener("input",rebuildAndRender);
ui.edgeWidth.addEventListener("input",rebuildAndRender);
ui.edgeColor.addEventListener("input",rebuildAndRender);
ui.btnExportSVG.addEventListener("click",exportSVG);
ui.btnExportPNG.addEventListener("click",exportPNG);
ui.persistSelect.addEventListener("change",()=>{ if(!persistEnabled()) clearPersisted(); else savePersisted(); });
ui.searchInput.addEventListener("input",()=>{
  const q=ui.searchInput.value.trim().toLowerCase();
  if(!q){ ui.searchResults.style.display="none"; return; }
  renderSearchResults(state.searchIndex.filter(it=>it.label.toLowerCase().includes(q)||it.iriShort.toLowerCase().includes(q)));
});
ui.btnSearchClear.addEventListener("click",()=>{ ui.searchInput.value=""; ui.searchResults.style.display="none"; });
ui.btnSearchShowAll.addEventListener("click",()=>renderSearchResults(state.searchIndex));
svg.on("click",()=>{
  state.selectedIri=null; ui.selPill.style.display="none";
  ui.editorCard.classList.add("locked"); ui.editorFields.style.display="none";
  ui.editorHint.textContent="Clique em um nÃ³ para editar.";
  rebuildAndRender(); ui.tooltip.style.display="none";
});

/* =========================================================
   INIT
========================================================= */
(function init(){
  const t=localStorage.getItem(P("theme"));
  if(t==="light"||t==="dark") setTheme(t,false);
  ui.editorCard.classList.add("locked"); ui.editorFields.style.display="none";
  resize(); enableControls(false);
  ui.dataUrl.value="https://raw.githubusercontent.com/luquizis/Ontohate/main/ontohate_.owl";
})();
</script>
</body>
</html>
