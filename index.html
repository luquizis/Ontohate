<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <title>Taxonomy Builder ‚Äî Conex√£o Raiz-Copa</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root { --bg: #ffffff; --panel: #f1f5f9; --text: #0f172a; --line: #e2e8f0; --accent: #2563eb; }
    [data-theme="dark"] { --bg: #000000; --panel: #0f172a; --text: #f1f5f9; --line: #1e293b; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: Arial, sans-serif; overflow: hidden; }
    header { background: var(--panel); border-bottom: 1px solid var(--line); padding: 10px 20px; display: flex; align-items: center; justify-content: space-between; height: 70px; }
    .btn { background: var(--bg); border: 1px solid var(--line); color: var(--text); padding: 8px 14px; border-radius: 8px; cursor: pointer; font-size: 11px; font-weight: bold; text-transform: uppercase; }
    #wrap { display: flex; height: calc(100% - 70px); }
    .sidebar { width: 340px; background: var(--panel); border-right: 1px solid var(--line); overflow-y: auto; padding: 20px; font-size: 13px; z-index: 10; }
    .canvas-area { flex: 1; position: relative; background: var(--bg); overflow: hidden; }
    .node rect { stroke-width: 1.5px; rx: 8; ry: 8; cursor: move; }
    .node text { font-family: Arial, sans-serif; font-weight: bold; pointer-events: none; font-size: 12px; }
    .link { fill: none; stroke: #94a3b8; stroke-width: 1.5px; opacity: 0.6; }
    .guide-step { background: rgba(37, 99, 235, 0.1); border-left: 4px solid var(--accent); padding: 10px; margin-bottom: 15px; border-radius: 4px; }
    svg { width: 100%; height: 100%; }
    .tooltip { position: fixed; background: #fff; border: 1px solid var(--line); padding: 10px; border-radius: 5px; display: none; z-index: 1000; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
  </style>
</head>
<body data-theme="light">
<header>
  <div class="controls">
    <label class="btn" style="background:var(--accent); color:#fff;">üìÅ CARREGAR ARQUIVO <input type="file" id="fileInput" accept=".xlsx" style="display:none"></label>
    <select id="themeSelect" class="btn"><option value="light">MODO CLARO</option><option value="dark">MODO ESCURO</option></select>
  </div>
  <div style="font-weight: bold; font-size: 14px;">üõ†Ô∏è CONSTRUTOR DE TAXONOMIA CONECTADA</div>
  <div class="controls">
    <button class="btn" id="btnExportPng" style="background:var(--accent); color:#fff;">üíæ SALVAR PNG PARA ARTIGO</button>
  </div>
</header>
<div id="wrap">
  <div class="sidebar">
    <div class="guide-step"><b>1.</b> Selecione as dimens√µes para destacar no gr√°fico.</div>
    <h3>DIMENS√ïES</h3>
    <div id="dimList">Aguardando arquivo...</div>
    <hr>
    <div class="guide-step"><b>2.</b> Escolha a <b>Raiz</b> (onde come√ßa) e a <b>Copa</b> (onde termina). O c√≥digo for√ßar√° a liga√ß√£o entre elas.</div>
    <h3>RAIZ (TOPO)</h3>
    <select id="rootSelect"></select>
    <h3 style="margin-top:15px;">COPA (LIMITE)</h3>
    <select id="canopySelect"><option value="">Sem limite (Exibir tudo)</option></select>
    <br><br>
    <button class="btn" id="btnGenerate" style="width:100%; background:var(--accent); color:#fff; padding:15px;">GERAR TAXONOMIA CONECTADA</button>
    <div class="guide-step" style="margin-top:20px;"><b>DICA:</b> Use o scroll do mouse para Zoom e arraste as classes para organizar o espa√ßo.</div>
  </div>
  <div class="canvas-area">
    <svg id="svg"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
</div>

<script>
let STORE = null;
const svg = d3.select("#svg"), gMain = svg.append("g");
// Zoom aprimorado para garantir visualiza√ß√£o total
const zoom = d3.zoom().scaleExtent([0.1, 3]).on("zoom", (e) => { 
  if (!e.sourceEvent || e.sourceEvent.type !== 'mousemove') gMain.attr("transform", e.transform); 
});
svg.call(zoom);

async function handleFile(f) {
  const data = await f.arrayBuffer();
  const wb = XLSX.read(data, {type: 'array'});
  const nodes = new Map(), dimensions = new Set(), hierarchy = new Map(), parentMap = new Map();
  
  wb.SheetNames.forEach(sheet => {
    const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheet]);
    rows.forEach(row => {
      const k = Object.keys(row);
      const n = String(row[k.find(x => /classe|item|name/i.test(x))] || "").trim();
      const p = String(row[k.find(x => /super|pai|parent/i.test(x))] || "").trim();
      if (n) {
        nodes.set(n, { name: n, dim: sheet, meta: row });
        dimensions.add(sheet);
        if (p && p !== n) {
          if (!hierarchy.has(p)) hierarchy.set(p, []);
          hierarchy.get(p).push(n);
          parentMap.set(n, p); // Guardar pai para reconstru√ß√£o de caminho
        }
      }
    });
  });
  STORE = { nodes, dimensions: Array.from(dimensions), hierarchy, parentMap };
  const dL = d3.select("#dimList").html("");
  STORE.dimensions.forEach(d => {
    const l = dL.append("label").attr("class", "dim-item").style("display","block");
    l.append("input").attr("type","checkbox").attr("checked",true).attr("value",d);
    l.append("span").text(" "+d);
  });
  const rS = d3.select("#rootSelect").html(""), cS = d3.select("#canopySelect").html('<option value="">Sem limite</option>');
  Array.from(STORE.nodes.keys()).sort().forEach(n => {
    rS.append("option").text(n).attr("value",n);
    cS.append("option").text(n).attr("value",n);
  });
}

function render() {
  if(!STORE) return;
  gMain.selectAll("*").remove();
  const rootName = d3.select("#rootSelect").property("value"), canopyName = d3.select("#canopySelect").property("value");
  const activeDims = new Set(); d3.selectAll("#dimList input:checked").each(function(){ activeDims.add(this.value); });

  // L√≥gica de Conex√£o: Identifica todos os ancestrais da Copa para garantir o caminho
  const ancestorsOfCanopy = new Set();
  if (canopyName) {
    let curr = canopyName;
    while (curr && curr !== rootName) {
      ancestorsOfCanopy.add(curr);
      curr = STORE.parentMap.get(curr);
    }
    ancestorsOfCanopy.add(rootName);
  }

  function build(name, visited = new Set()) {
    if (visited.has(name)) return null; visited.add(name);
    const n = STORE.nodes.get(name);
    
    // Se houver uma Copa definida, s√≥ desce pelos filhos se o n√≥ atual for um ancestral da Copa
    // OU se o n√≥ for a pr√≥pria Copa (parando nela).
    let children = [];
    if (!canopyName || ancestorsOfCanopy.has(name)) {
        if (name !== canopyName) {
            children = (STORE.hierarchy.get(name) || [])
                .map(c => build(c, new Set(visited)))
                .filter(Boolean);
        }
    } else {
        return null; // Fora do caminho Raiz-Copa
    }

    return { ...n, children, highlighted: activeDims.has(n.dim) };
  }

  const root = d3.hierarchy(build(rootName));
  // Aumentar espa√ßamento para evitar sobreposi√ß√µes
  d3.tree().nodeSize([280, 180])(root);

  const links = gMain.selectAll(".link").data(root.links()).enter().append("path").attr("class", "link")
    .attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));

  const drag = d3.drag().on("drag", function(event, d) {
    d.x = event.x; d.y = event.y;
    d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
    links.attr("d", d3.linkVertical().x(l => l.x).y(l => l.y));
  });

  const nodes = gMain.selectAll(".node").data(root.descendants()).enter().append("g").attr("class", "node")
    .attr("transform", d => `translate(${d.x},${d.y})`).call(drag);

  nodes.append("rect").attr("x", -110).attr("y", -25).attr("width", 220).attr("height", 50)
    .attr("fill", d => d.data.highlighted ? "#2563eb" : "#cbd5e1")
    .attr("stroke", "#1e40af");

  nodes.append("text").attr("text-anchor", "middle").attr("dy", 5).attr("fill", d => d.data.highlighted ? "#fff" : "#1e293b")
    .text(d => d.data.name.length > 25 ? d.data.name.substring(0, 23) + "..." : d.data.name);

  // Auto-fit inicial
  const bbox = gMain.node().getBBox();
  const svgSize = svg.node().getBoundingClientRect();
  const scale = Math.min(0.8, svgSize.width / bbox.width, svgSize.height / bbox.height);
  svg.call(zoom.transform, d3.zoomIdentity.translate(svgSize.width/2 - (bbox.x + bbox.width/2)*scale, 50).scale(scale));
}

d3.select("#btnGenerate").on("click", render);
d3.select("#fileInput").on("change", (e) => { if(e.target.files[0]) handleFile(e.target.files[0]); });
d3.select("#themeSelect").on("change", function(){ document.body.dataset.theme = this.value; });
d3.select("#btnExportPng").on("click", () => {
    const svgN = document.getElementById("svg"), bbox = gMain.node().getBBox(), canvas = document.createElement("canvas"), s = 3, p = 100;
    canvas.width = (bbox.width + p*2)*s; canvas.height = (bbox.height + p*2)*s;
    const ctx = canvas.getContext("2d"); ctx.scale(s, s);
    ctx.fillStyle = document.body.dataset.theme === "dark" ? "#000" : "#fff"; ctx.fillRect(0,0,canvas.width,canvas.height);
    const img = new Image(); img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svgN));
    img.onload = () => { ctx.drawImage(img, p-bbox.x, p-bbox.y); const a = document.createElement("a"); a.download="taxonomia_artigo.png"; a.href=canvas.toDataURL(); a.click(); };
});
</script>
</body>
</html>
