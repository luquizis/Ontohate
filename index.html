<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ONTOHATE V2 ‚Äî Taxonomia (Dimens√µes + Raiz) + Export</title>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#f6f7f9;
      --text:#101828;
      --muted:#475467;
      --line:#e4e7ec;
      --shadow: 0 10px 24px rgba(16,24,40,.10);
      --radius: 14px;
    }

    html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: Arial, Helvetica, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}

    header{
      position: sticky; top:0; z-index: 10;
      background: rgba(255,255,255,.94);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
      padding: 12px 14px;
      display:flex; flex-wrap:wrap;
      gap: 10px 12px;
      align-items:center; justify-content: space-between;
    }

    .brand{display:flex; flex-direction:column; gap:4px; min-width: 320px;}
    .brand h1{margin:0; font-size:14px; font-weight:800;}
    .brand .sub{margin:0; font-size:12px; color:var(--muted); max-width: 980px; line-height: 1.25;}

    .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end;}
    .btn,.file,.input,.select,.pill{
      border:1px solid var(--line);
      background: var(--panel);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1;
      display:inline-flex;
      gap:8px;
      align-items:center;
      box-shadow: 0 1px 0 rgba(16,24,40,.04);
    }
    .btn{cursor:pointer; user-select:none;}
    .btn:hover{filter: brightness(.98);}
    .file input[type="file"]{display:none;}
    .input input, .select select{
      border:none; outline:none; background:transparent; color:var(--text); font-size: 12px;
      font-family: Arial, Helvetica, sans-serif;
    }
    .input input{width: 220px;}
    .select select{appearance:none;}
    .pill{background:#fff; box-shadow:none;}
    .pill strong{font-weight:700;}
    .dot{width:10px; height:10px; border-radius:999px; display:inline-block;
      border: 1px solid rgba(16,24,40,.12);}

    #wrap{
      height: calc(100% - 72px);
      display:grid;
      grid-template-columns: 1fr 460px;
      gap: 14px;
      padding: 14px;
      box-sizing: border-box;
    }
    @media (max-width: 1100px){
      #wrap{grid-template-columns: 1fr; height:auto;}
      body{height:auto;}
    }

    .card{
      background:#fff;
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .canvas{min-height: 740px; display:flex; flex-direction:column;}
    .canvasHeader{
      padding: 10px 12px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .canvasHeader .title{display:flex; flex-direction:column; gap:4px;}
    .canvasHeader .title b{font-size:13px;}
    .canvasHeader .title span{font-size:12px; color:var(--muted);}
    .canvasHeader .meta{font-size:12px; color:var(--muted); text-align:right; white-space:nowrap;}
    .canvasBody{flex:1; overflow:hidden;}
    svg{width:100%; height:100%; display:block; background:#fff;}

    .side{padding: 12px; display:flex; flex-direction:column; gap:10px;}
    .side h2{font-size:13px; margin:0;}
    .side p{margin:0; font-size:12px; color:var(--muted); line-height:1.35;}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .sep{height:1px; background: var(--line); margin: 6px 0;}
    .mini{font-size:11px;color:var(--muted)}

    .dimList{
      border:1px solid var(--line);
      border-radius: 14px;
      overflow:hidden;
      background:#fff;
    }
    .dimListHeader{
      padding: 10px 10px;
      background: var(--panel);
      border-bottom:1px solid var(--line);
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .dimListHeader input{
      width: 100%;
      border:1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      outline:none;
      font-size:12px;
      font-family: Arial, Helvetica, sans-serif;
      background:#fff;
    }
    .dimItems{
      max-height: 260px;
      overflow:auto;
      padding: 8px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .dimItem{
      display:flex; align-items:center; gap:10px;
      border:1px solid var(--line);
      border-radius: 12px;
      padding: 8px 10px;
      font-size:12px;
      background:#fff;
    }
    .dimItem input{accent-color:#111827}
    .dimName{flex:1; font-weight:700;}
    .dimCount{color:var(--muted); font-size:11px;}

    /* SVG styles */
    .link{
      fill:none;
      stroke: rgba(16,24,40,.18);
      stroke-width: 1.25;
      stroke-linecap: round;
      stroke-linejoin: round;
      vector-effect: non-scaling-stroke;
    }
    .node rect{
      stroke: rgba(16,24,40,.18);
      stroke-width: 1.2;
      rx:10; ry:10;
      shape-rendering: geometricPrecision;
    }
    .node .name{
      font-size: 12px;
      font-weight: 700;
      font-family: Arial, Helvetica, sans-serif;
      text-rendering: geometricPrecision;
    }
    .node .small{
      font-size: 10px;
      font-weight: 700;
      font-family: Arial, Helvetica, sans-serif;
      opacity:.95;
    }
    .node--match rect{
      stroke-width: 2.4;
      stroke: rgba(249,115,22,.95);
    }

    .tooltip{
      position: fixed;
      z-index: 9999;
      display: none;
      max-width: 560px;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 10px 12px;
      font-size: 12px;
      color: var(--text);
      pointer-events: none;
      white-space: pre-wrap;
      font-family: Arial, Helvetica, sans-serif;
    }
    .tooltip .tTitle{font-weight: 800; margin-bottom: 6px;}
    .tooltip .tMeta{color: var(--muted); margin-bottom: 8px; font-weight: 700;}
    .tooltip .tSection{margin-top: 8px;}
    .tooltip .tSection b{display:block; margin-bottom: 4px;}
    .tooltip .tEmpty{color: var(--muted); font-style: italic;}

    .toast{
      position:fixed; left:14px; bottom:14px; z-index:50;
      background:#fff; border:1px solid var(--line);
      padding:10px 12px; border-radius: 12px;
      box-shadow: var(--shadow);
      font-size:12px; color: var(--muted);
      max-width: min(980px, calc(100% - 28px));
      white-space: pre-wrap;
      font-family: Arial, Helvetica, sans-serif;
    }
    .toast.bad{border-color: rgba(255,107,107,.55); color:#7a0b0b;}
  </style>
</head>

<body>
<header>
  <div class="brand">
    <h1>ONTOHATE V2 ‚Äî Taxonomia (Dimens√µes ‚Üí Raiz ‚Üí Gerar) + Export</h1>
    <p class="sub">
      1) Selecione as <b>Dimens√µes</b> (antes ‚Äúsubontologias‚Äù), 2) escolha a <b>Raiz</b>, 3) gere a taxonomia Top-Down.
    </p>
  </div>

  <div class="controls">
    <label class="file btn">
      üìÑ Carregar XLSX
      <input id="fileInput" type="file" accept=".xlsx,.xls" />
    </label>

    <div class="btn" id="btnLoadDefault">‚¨áÔ∏è Carregar Ontohate_V2.xlsx</div>

    <div class="input">
      üîé <input id="search" placeholder="Buscar classe no gr√°fico" />
    </div>

    <div class="btn" id="btnFit">‚§¢ Ajustar</div>
    <div class="btn" id="btnExpandAll">‚ûï Expandir</div>
    <div class="btn" id="btnCollapseAll">‚ûñ Recolher</div>

    <div class="btn" id="btnSvg">‚¨áÔ∏é SVG</div>
    <div class="select" title="PNG em alta resolu√ß√£o">
      PNG
      <select id="pngScale">
        <option value="3">3√ó</option>
        <option value="4">4√ó</option>
      </select>
    </div>
    <div class="btn" id="btnPng">‚¨áÔ∏é PNG</div>

    <div class="pill">
      <span class="dot" id="statusDot"></span>
      <span id="stats"><strong>Arquivo:</strong> ‚Äî | <strong>Taxonomia:</strong> ‚Äî</span>
    </div>
  </div>
</header>

<div id="wrap">
  <div class="card canvas">
    <div class="canvasHeader">
      <div class="title">
        <b id="canvasTitle">Selecione Dimens√µes e Raiz</b>
        <span id="canvasSubtitle">‚Äî</span>
      </div>
      <div class="meta" id="canvasMeta">‚Äî</div>
    </div>
    <div class="canvasBody">
      <svg id="svg"></svg>
    </div>
  </div>

  <div class="card side">
    <h2>1) Dimens√µes</h2>
    <p class="mini">Escolha as dimens√µes (classifica√ß√µes) que deseja incluir na taxonomia. Ex.: Contexto, Natureza, N√∫cleo.</p>

    <div class="dimList">
      <div class="dimListHeader">
        <input id="dimSearch" placeholder="Filtrar dimens√µes..." />
        <div class="btn" id="btnSelectAll" title="Marcar todas">‚úì Todas</div>
        <div class="btn" id="btnClearAll" title="Desmarcar todas">‚úï</div>
      </div>
      <div class="dimItems" id="dimItems"></div>
    </div>

    <div class="sep"></div>

    <h2>2) Raiz</h2>
    <p class="mini">Depois de escolher dimens√µes, selecione a raiz (ex.: <b>Discurso_de_odio_online</b>).</p>
    <div class="row">
      <span class="select">Raiz:
        <select id="rootSelect"></select>
      </span>
    </div>

    <div class="row">
      <span class="btn" id="btnGenerate">Gerar taxonomia</span>
    </div>

    <div class="sep"></div>

    <p class="mini"><b>Hover</b> em uma classe mostra comments/observa√ß√µes (se existirem no XLSX).</p>
  </div>
</div>

<div class="tooltip" id="tooltip"></div>
<div class="toast" id="toast" style="display:none;"></div>

<script>
/* ============================
   Helpers base
============================ */
const svg = d3.select("#svg");
let viewport = null;

const toastEl = document.getElementById("toast");
const tooltipEl = document.getElementById("tooltip");
const statusDot = document.getElementById("statusDot");
const statsEl = document.getElementById("stats");

const fileInput = document.getElementById("fileInput");
const btnLoadDefault = document.getElementById("btnLoadDefault");

const dimItemsEl = document.getElementById("dimItems");
const dimSearchEl = document.getElementById("dimSearch");
const btnSelectAll = document.getElementById("btnSelectAll");
const btnClearAll = document.getElementById("btnClearAll");

const rootSelect = document.getElementById("rootSelect");
const btnGenerate = document.getElementById("btnGenerate");

const searchEl = document.getElementById("search");
const btnFit = document.getElementById("btnFit");
const btnExpandAll = document.getElementById("btnExpandAll");
const btnCollapseAll = document.getElementById("btnCollapseAll");

const btnSvg = document.getElementById("btnSvg");
const btnPng = document.getElementById("btnPng");
const pngScaleSel = document.getElementById("pngScale");

const canvasTitle = document.getElementById("canvasTitle");
const canvasSubtitle = document.getElementById("canvasSubtitle");
const canvasMeta = document.getElementById("canvasMeta");

function toast(msg, bad=false){
  toastEl.textContent = msg;
  toastEl.classList.toggle("bad", !!bad);
  toastEl.style.display = "block";
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(()=> toastEl.style.display="none", 9000);
}
function norm(s){
  return String(s||"").trim().toLowerCase().normalize("NFD").replace(/\p{Diacritic}/gu,"");
}
function normalizeKey(k){ return norm(k); }
function pick(row, wanted){
  const keys = Object.keys(row || {});
  const map = new Map(keys.map(k => [normalizeKey(k), k]));
  for (const w of wanted){
    const kk = map.get(normalizeKey(w));
    if (kk != null) return row[kk];
  }
  return undefined;
}
function canonDimension(name){
  let s = String(name||"").trim();
  if (!s) return "";
  s = s.replace(/\(\s*v2\s*\)/ig, "").trim();
  s = s.replace(/\bv2\b/ig, "").trim();
  s = s.replace(/\s+/g, " ").trim();
  return s;
}
function wrapLabel(text, maxChars=28){
  const t = String(text||"");
  if (t.length <= maxChars) return [t];
  const parts = t.split(/[_\s-]+/);
  if (parts.length === 1) return [t.slice(0, maxChars) + "‚Ä¶"];
  const lines = [];
  let cur = "";
  for (const p of parts){
    const next = cur ? (cur + " " + p) : p;
    if (next.length > maxChars){
      if (cur) lines.push(cur);
      cur = p;
    } else cur = next;
    if (lines.length >= 2) break;
  }
  if (cur && lines.length < 2) lines.push(cur);
  const joined = parts.join(" ");
  if (joined.length > lines.join(" ").length) lines[lines.length-1] += "‚Ä¶";
  return lines;
}
function escapeHtml(s){
  return String(s||"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

/* ============================
   Tooltip
============================ */
function showTooltip(evt, payload){
  const pad = 14;
  const vw = window.innerWidth, vh = window.innerHeight;

  tooltipEl.innerHTML = `
    <div class="tTitle">${escapeHtml(payload.name || "")}</div>
    <div class="tMeta">${escapeHtml(payload.dimension || "")}</div>
    <div class="tSection">
      <b>Comments</b>
      <div>${payload.comment ? escapeHtml(payload.comment) : '<span class="tEmpty">(sem comments)</span>'}</div>
    </div>
    <div class="tSection">
      <b>Observa√ß√µes</b>
      <div>${payload.obs ? escapeHtml(payload.obs) : '<span class="tEmpty">(sem observa√ß√µes)</span>'}</div>
    </div>
  `;
  tooltipEl.style.display = "block";

  const rect = tooltipEl.getBoundingClientRect();
  let x = evt.clientX + 14;
  let y = evt.clientY + 14;
  if (x + rect.width + pad > vw) x = evt.clientX - rect.width - 14;
  if (y + rect.height + pad > vh) y = evt.clientY - rect.height - 14;
  x = Math.max(pad, x);
  y = Math.max(pad, y);
  tooltipEl.style.left = x + "px";
  tooltipEl.style.top = y + "px";
}
function moveTooltip(evt){
  if (tooltipEl.style.display !== "block") return;
  const pad = 14;
  const vw = window.innerWidth, vh = window.innerHeight;
  const rect = tooltipEl.getBoundingClientRect();
  let x = evt.clientX + 14;
  let y = evt.clientY + 14;
  if (x + rect.width + pad > vw) x = evt.clientX - rect.width - 14;
  if (y + rect.height + pad > vh) y = evt.clientY - rect.height - 14;
  x = Math.max(pad, x);
  y = Math.max(pad, y);
  tooltipEl.style.left = x + "px";
  tooltipEl.style.top = y + "px";
}
function hideTooltip(){ tooltipEl.style.display = "none"; tooltipEl.innerHTML = ""; }

/* ============================
   Color (dimens√£o -> cor)
   - cores determin√≠sticas via hash
============================ */
function hashColor(str){
  const s = String(str||"");
  let h = 2166136261;
  for (let i=0;i<s.length;i++){
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  // HSL agrad√°vel: 0..360
  const hue = Math.abs(h) % 360;
  return `hsl(${hue} 72% 45%)`;
}
function mixToWhite(hslOrHex, t=0.62){
  // usar d3.color para misturar com branco
  const c = d3.color(hslOrHex);
  const w = d3.rgb(255,255,255);
  const r = Math.round(c.r*(1-t) + w.r*t);
  const g = Math.round(c.g*(1-t) + w.g*t);
  const b = Math.round(c.b*(1-t) + w.b*t);
  return d3.rgb(r,g,b).formatHex();
}
function luminance(hex){
  const c = d3.color(hex);
  const srgb = [c.r,c.g,c.b].map(v=>{
    const x = v/255;
    return (x<=0.03928)? x/12.92 : Math.pow((x+0.055)/1.055, 2.4);
  });
  return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
}
function contrastText(bgHex){
  return luminance(bgHex) > 0.55 ? "#101828" : "#ffffff";
}

/* ============================
   Zoom
============================ */
const zoom = d3.zoom()
  .scaleExtent([0.10, 3.5])
  .on("zoom", (event) => { if (viewport) viewport.attr("transform", event.transform); });

/* ============================
   State (RAW + VIEW)
============================ */
let RAW = null;  // nodes Map, edges, dimensions list, fileName
let VIEW = null; // selected dimensions, root, allowedSet, treeData

let rootHierarchy = null;
let linkLayer = null;
let nodeLayer = null;
let updateFn = null;
let fitToCanvasFn = null;
let expandAllFn = null;
let collapseAllFn = null;

/* ============================
   Load XLSX
============================ */
btnLoadDefault.addEventListener("click", loadDefault);
fileInput.addEventListener("change", async (ev) => {
  const f = ev.target.files?.[0];
  if (!f) return;
  const buf = await f.arrayBuffer();
  await parseAndInit(buf, f.name);
});

async function loadDefault(){
  const url = "Ontohate_V2.xlsx";
  try{
    const res = await fetch(url, { cache:"no-store" });
    if (!res.ok) throw new Error(`N√£o encontrei ${url} (HTTP ${res.status}). Verifique o nome exato no repo.`);
    const buf = await res.arrayBuffer();
    await parseAndInit(buf, url);
  } catch(e){
    toast("Erro ao carregar XLSX:\n" + e.message, true);
  }
}

async function parseAndInit(buf, fileName){
  let wb;
  try{ wb = XLSX.read(buf, { type:"array" }); }
  catch(e){ toast("Falha ao ler o XLSX:\n" + e.message, true); return; }

  const sheetNames = wb.SheetNames || [];
  if (!sheetNames.length){ toast("XLSX sem abas.", true); return; }

  const nodes = new Map(); // name -> {name, dimension, comment, obs}
  const edges = [];
  const dimSet = new Set();

  function ensureNode(name, dimensionRaw="", comment="", obs=""){
    const n = String(name||"").trim();
    if (!n) return null;

    const dimCanon = canonDimension(dimensionRaw) || "(Sem dimens√£o)";
    if (!nodes.has(n)){
      nodes.set(n, { name:n, dimension: dimCanon, comment:String(comment||"").trim(), obs:String(obs||"").trim() });
    } else {
      const cur = nodes.get(n);
      if ((cur.dimension === "(Sem dimens√£o)" || !cur.dimension) && dimCanon) cur.dimension = dimCanon;
      const cmt = String(comment||"").trim();
      const ob = String(obs||"").trim();
      if (cmt && !cur.comment) cur.comment = cmt;
      if (ob && !cur.obs) cur.obs = ob;
    }
    if (dimCanon) dimSet.add(dimCanon);
    return n;
  }

  let usedRows = 0;
  for (const sname of sheetNames){
    const ws = wb.Sheets[sname];
    if (!ws) continue;
    const json = XLSX.utils.sheet_to_json(ws, { defval:"" });

    for (const r of json){
      const child = pick(r, ["Classe", "Class", "classe"]);
      const parent = pick(r, ["Superclasse", "Superclass", "superclasse"]);
      const group  = pick(r, ["Subontologia", "Sub-ontologia", "Subontology", "subontologia", "Dimens√£o", "Dimensao", "dimensao"]);

      const comment = pick(r, ["Comment", "Comments", "comment", "comments", "rdfs:comment", "RDFS:comment", "Anota√ß√£o", "Anotacao", "anotacao", "anota√ß√£o"]);
      const obs     = pick(r, ["Observa√ß√£o", "Observacao", "observacao", "observa√ß√£o", "Observa√ß√µes", "Observacoes", "observacoes", "notes", "Notes", "nota", "notas"]);

      const c = String(child||"").trim();
      if (!c) continue;

      const p = String(parent||"").trim();
      const g = String(group||"").trim();

      ensureNode(c, g, comment, obs);
      if (p) ensureNode(p, "", "", "");
      if (p) edges.push([c,p]);
      usedRows++;
    }
  }

  if (!usedRows || nodes.size === 0){
    toast("N√£o encontrei a coluna 'Classe' na planilha.", true);
    return;
  }

  // dedup edges
  const seen = new Set();
  const edgesUniq = [];
  for (const [c,p] of edges){
    const k = c + "‚Üí" + p;
    if (!seen.has(k)){ seen.add(k); edgesUniq.push([c,p]); }
  }

  const dimensions = Array.from(dimSet).sort((a,b)=>a.localeCompare(b));
  RAW = { nodes, edges: edgesUniq, dimensions, fileName };

  buildDimensionsUI();
  updateRootOptions(); // baseado nas dimens√µes marcadas
  statusDot.style.background = "#16a34a";
  statsEl.innerHTML = `<strong>Arquivo:</strong> ${fileName} | <strong>Taxonomia:</strong> selecione dimens√µes e raiz`;

  toast(`Planilha carregada: ${fileName}\nClasses: ${nodes.size}\nDimens√µes (padronizadas): ${dimensions.length}`);
}

/* ============================
   UI: Dimens√µes (checklist)
============================ */
function getSelectedDimensions(){
  const checks = dimItemsEl.querySelectorAll("input[type=checkbox][data-dim]");
  const set = new Set();
  checks.forEach(ch=>{
    if (ch.checked) set.add(ch.getAttribute("data-dim"));
  });
  return set;
}

function buildDimensionsUI(){
  const dimCounts = new Map();
  for (const obj of RAW.nodes.values()){
    dimCounts.set(obj.dimension, (dimCounts.get(obj.dimension)||0) + 1);
  }

  dimItemsEl.innerHTML = "";
  for (const dim of RAW.dimensions){
    const color = hashColor(dim);
    const item = document.createElement("label");
    item.className = "dimItem";
    item.innerHTML = `
      <input type="checkbox" data-dim="${escapeHtml(dim)}" checked />
      <span class="dot" style="background:${color}"></span>
      <span class="dimName">${escapeHtml(dim)}</span>
      <span class="dimCount">${dimCounts.get(dim) || 0} classes</span>
    `;
    dimItemsEl.appendChild(item);
  }

  // handlers
  dimItemsEl.querySelectorAll("input[type=checkbox][data-dim]").forEach(ch=>{
    ch.addEventListener("change", () => updateRootOptions());
  });

  dimSearchEl.value = "";
  dimSearchEl.addEventListener("input", () => {
    const q = norm(dimSearchEl.value);
    dimItemsEl.querySelectorAll(".dimItem").forEach(el=>{
      const name = el.querySelector(".dimName")?.textContent || "";
      el.style.display = norm(name).includes(q) ? "flex" : "none";
    });
  });

  btnSelectAll.onclick = () => {
    dimItemsEl.querySelectorAll("input[type=checkbox][data-dim]").forEach(ch=> ch.checked = true);
    updateRootOptions();
  };
  btnClearAll.onclick = () => {
    dimItemsEl.querySelectorAll("input[type=checkbox][data-dim]").forEach(ch=> ch.checked = false);
    updateRootOptions();
  };
}

/* ============================
   Raiz: op√ß√µes dependem das dimens√µes selecionadas
============================ */
function updateRootOptions(){
  if (!RAW) return;

  const selected = getSelectedDimensions();
  const candidates = [];

  // raiz pode ser qualquer classe dentro das dimens√µes selecionadas
  for (const [name, obj] of RAW.nodes.entries()){
    if (selected.has(obj.dimension)) candidates.push(name);
  }
  candidates.sort((a,b)=>a.localeCompare(b));

  rootSelect.innerHTML = "";
  const opt0 = document.createElement("option");
  opt0.value = "";
  opt0.textContent = "(Escolha a raiz)";
  rootSelect.appendChild(opt0);

  for (const c of candidates){
    const opt = document.createElement("option");
    opt.value = c;
    opt.textContent = c;
    rootSelect.appendChild(opt);
  }

  canvasSubtitle.textContent = `Dimens√µes selecionadas: ${selected.size} ‚Ä¢ Agora escolha a raiz`;
  canvasMeta.textContent = `Candidatas a raiz: ${candidates.length}`;
}

/* ============================
   Gerar taxonomia (dimens√µes + raiz)
   Regra do usu√°rio:
   - seleciona Dimens√µes (Contexto, Natureza, N√∫cleo)
   - escolhe Raiz (Discurso_de_odio_online)
   - taxonomia engloba da raiz para baixo considerando classes/subclasses dessas dimens√µes
============================ */
btnGenerate.addEventListener("click", generateTaxonomy);

function generateTaxonomy(){
  if (!RAW) return;

  const selected = getSelectedDimensions();
  if (selected.size === 0){
    toast("Selecione pelo menos 1 dimens√£o.", true);
    return;
  }

  const root = rootSelect.value;
  if (!root){
    toast("Escolha uma raiz para gerar a taxonomia.", true);
    return;
  }

  // childrenOf dentro do recorte de dimens√µes (mas a raiz sempre entra, mesmo que esteja fora)
  const allowedNodes = new Set();
  for (const [name, obj] of RAW.nodes.entries()){
    if (selected.has(obj.dimension)) allowedNodes.add(name);
  }
  allowedNodes.add(root);

  // adjacency (parent -> children) apenas se ambos est√£o no allowedNodes
  const childrenOf = new Map();
  for (const [child, parent] of RAW.edges){
    if (!allowedNodes.has(child)) continue;
    if (!allowedNodes.has(parent)) continue;
    if (!childrenOf.has(parent)) childrenOf.set(parent, []);
    childrenOf.get(parent).push(child);
  }
  for (const [p, kids] of childrenOf.entries()){
    kids.sort((a,b)=>a.localeCompare(b));
  }

  // descendentes a partir da raiz (top-down real)
  const desc = descendantsSet(childrenOf, root);
  if (!desc.has(root)){
    toast("A raiz n√£o est√° conectada dentro do recorte selecionado. Tente incluir mais dimens√µes.", true);
    return;
  }

  // montar treeData
  const treeData = buildTreeDataFromRoot(root, childrenOf, desc);

  // map dimens√£o -> cor (para o recorte)
  const dimColor = new Map();
  for (const d of selected){
    dimColor.set(d, hashColor(d));
  }
  // caso raiz esteja fora das dimens√µes selecionadas, d√° uma cor neutra
  if (!dimColor.has(RAW.nodes.get(root)?.dimension || "")){
    dimColor.set("(Sem dimens√£o)", "hsl(220 10% 55%)");
  }

  VIEW = { selected, root, allowedNodes, childrenOf, desc, treeData, dimColor };

  canvasTitle.textContent = `Raiz: ${root}`;
  canvasSubtitle.textContent = `Dimens√µes: ${Array.from(selected).join(" | ")}`;
  canvasMeta.textContent = `Classes na √°rvore: ${desc.size}`;
  statsEl.innerHTML = `<strong>Arquivo:</strong> ${RAW.fileName} | <strong>Taxonomia:</strong> ${desc.size} classes`;

  renderTopDown(treeData, dimColor);
  // d√° um frame para o browser finalizar layout antes de qualquer export
  requestAnimationFrame(()=> fitToCanvasFn?.(true));
  applySearchHighlight();
}

/* ============================
   Descendentes + √°rvore
============================ */
function descendantsSet(childrenOf, root){
  const st = [root];
  const seen = new Set();
  while(st.length){
    const cur = st.pop();
    if (seen.has(cur)) continue;
    seen.add(cur);
    const kids = childrenOf.get(cur) || [];
    for (const k of kids) st.push(k);
  }
  return seen;
}
function buildTreeDataFromRoot(root, childrenOf, allowedSet){
  let id = 0;
  function build(name, path=new Set()){
    const base = RAW.nodes.get(name) || {name, dimension:"(Sem dimens√£o)", comment:"", obs:""};
    const node = {
      _id: `N${++id}`,
      name: base.name,
      dimension: base.dimension || "(Sem dimens√£o)",
      comment: base.comment || "",
      obs: base.obs || "",
      children: []
    };
    if (path.has(name)) return node;
    path.add(name);
    const kids = (childrenOf.get(name) || []).filter(k => allowedSet.has(k));
    for (const k of kids) node.children.push(build(k, new Set(path)));
    return node;
  }
  return build(root, new Set());
}

/* ============================
   Render top-down
============================ */
function renderTopDown(treeData, dimColor){
  svg.selectAll("*").remove();
  viewport = svg.append("g").attr("id","viewport");
  svg.call(zoom);
  svg.call(zoom.transform, d3.zoomIdentity.translate(18, 18).scale(1));

  linkLayer = viewport.append("g").attr("id","links");
  nodeLayer = viewport.append("g").attr("id","nodes");

  const dx = 340;  // horizontal spacing
  const dy = 125;  // vertical spacing
  const tree = d3.tree().nodeSize([dx, dy]);

  rootHierarchy = d3.hierarchy(treeData);

  // collapse deeper initially
  collapseDeep(rootHierarchy);

  function collapseDeep(r){
    r.children?.forEach(c => c.children?.forEach(cc => collapse(cc)));
  }
  function collapse(d){
    if (d.children){
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  expandAllFn = () => expandAll(rootHierarchy);
  collapseAllFn = () => collapseAll(rootHierarchy);

  function expandAll(d){
    if (d._children){ d.children = d._children; d._children = null; }
    (d.children||[]).forEach(expandAll);
  }
  function collapseAll(d){
    (d.children||[]).forEach(collapseAll);
    if (d.depth >= 2) collapse(d);
  }

  function linkVertical(d){
    return d3.linkVertical().x(p => p.x).y(p => p.y)(d);
  }

  updateFn = () => {
    tree(rootHierarchy);

    const nodes = rootHierarchy.descendants();
    const links = rootHierarchy.links();

    for (const n of nodes){
      n.y = n.y + 40;
      n.x = n.x + 20;
    }

    // LINKS
    const linkSel = linkLayer.selectAll("path.link")
      .data(links, d => d.target.data._id);

    linkSel.enter().append("path")
      .attr("class","link")
      .attr("d", d => {
        const o = {x: d.source.x, y: d.source.y};
        return linkVertical({source:o, target:o});
      })
      .merge(linkSel)
      .transition().duration(220)
      .attr("d", d => linkVertical(d));

    linkSel.exit().transition().duration(180).attr("opacity",0).remove();

    // NODES
    const nodeSel = nodeLayer.selectAll("g.node")
      .data(nodes, d => d.data._id);

    const nodeEnter = nodeSel.enter().append("g")
      .attr("class","node")
      .attr("transform", d => `translate(${d.x},${d.y})`)
      .on("click", (_, d) => {
        if (d.children){ d._children = d.children; d.children = null; }
        else { d.children = d._children; d._children = null; }
        updateFn();
        applySearchHighlight();
      })
      .on("mouseenter", (evt, d) => {
        const dd = d.data;
        showTooltip(evt, { name: dd.name, dimension: dd.dimension, comment: dd.comment, obs: dd.obs });
      })
      .on("mousemove", (evt) => moveTooltip(evt))
      .on("mouseleave", () => hideTooltip());

    nodeEnter.each(function(d){
      const g = d3.select(this);

      const dim = d.data.dimension || "(Sem dimens√£o)";
      const strokeColor = dimColor.get(dim) || hashColor(dim);
      const fill = mixToWhite(strokeColor, 0.64);
      const text = contrastText(fill);

      const lines = wrapLabel(d.data.name, 28);
      const hasKids = (d.children || d._children);

      const w = 370;
      const h = lines.length === 1 ? 52 : 68;

      g.append("rect")
        .attr("x", -w/2).attr("y", 0)
        .attr("width", w).attr("height", h)
        .attr("fill", fill)
        .attr("stroke", strokeColor)
        .attr("stroke-width", d.depth === 0 ? 2.6 : 1.5);

      const t = g.append("text")
        .attr("class","name")
        .attr("text-anchor","middle")
        .attr("fill", text)
        .attr("x", 0).attr("y", 22);

      if (lines.length === 1){
        t.text(lines[0]);
      } else {
        t.append("tspan").attr("x",0).attr("dy",0).text(lines[0]);
        t.append("tspan").attr("x",0).attr("dy",16).text(lines[1]);
      }

      // ‚ÄúDimens√£o‚Äù (sem falar ‚Äúsubontologia‚Äù)
      g.append("text")
        .attr("class","small")
        .attr("text-anchor","middle")
        .attr("fill", text)
        .attr("x", 0).attr("y", h - 10)
        .text(dim);

      g.append("text")
        .attr("class","small")
        .attr("fill", text)
        .attr("x", w/2 - 10).attr("y", 18)
        .attr("text-anchor","end")
        .text(hasKids ? (d.children ? "‚ñæ" : "‚ñ∏") : "");
    });

    nodeSel.merge(nodeEnter)
      .transition().duration(220)
      .attr("transform", d => `translate(${d.x},${d.y})`);

    nodeSel.exit().transition().duration(180).attr("opacity",0).remove();
  };

  updateFn();

  fitToCanvasFn = (strong=true) => {
    if (!viewport) return;
    const bounds = viewport.node().getBBox();
    const svgEl = svg.node();
    const w = svgEl.clientWidth || 900;
    const h = svgEl.clientHeight || 600;
    const pad = 50;

    const bw = bounds.width + pad*2;
    const bh = bounds.height + pad*2;
    const scale = Math.min(3.0, Math.max(0.10, Math.min(w/bw, h/bh)));

    const tx = (w - bounds.width*scale)/2 - bounds.x*scale;
    const ty = (h - bounds.height*scale)/2 - bounds.y*scale;

    svg.transition().duration(strong ? 380 : 220).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
  };

  fitToCanvasFn(true);
}

/* ============================
   Search highlight
============================ */
searchEl.addEventListener("input", applySearchHighlight);
function applySearchHighlight(){
  const q = norm(searchEl.value);
  svg.selectAll("g.node").classed("node--match", false);
  if (!q) return;

  svg.selectAll("g.node").each(function(d){
    if (!d || !d.data) return;
    if (norm(d.data.name).includes(q)){
      d3.select(this).classed("node--match", true);
    }
  });
}

/* ============================
   Expand/Collapse/Fit
============================ */
btnFit.addEventListener("click", () => fitToCanvasFn?.(true));
btnExpandAll.addEventListener("click", () => {
  if (!expandAllFn || !updateFn) return;
  expandAllFn();
  updateFn();
  applySearchHighlight();
  fitToCanvasFn?.(false);
});
btnCollapseAll.addEventListener("click", () => {
  if (!collapseAllFn || !updateFn) return;
  collapseAllFn();
  updateFn();
  applySearchHighlight();
  fitToCanvasFn?.(false);
});

/* ============================
   Export SVG / PNG (corrigido: n√£o vem branco)
============================ */
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=> URL.revokeObjectURL(url), 1000);
}
function exportName(ext){
  const root = (VIEW?.root || "root").replace(/[^\w\-]+/g,"_");
  return `ONTOHATE_TAXONOMIA_${root}.${ext}`;
}
function embeddedExportStyle(){
  return `
    svg { background:#ffffff; font-family: Arial, Helvetica, sans-serif; }
    .link{
      fill:none; stroke: rgba(16,24,40,.18); stroke-width: 1.25;
      stroke-linecap: round; stroke-linejoin: round;
      vector-effect: non-scaling-stroke;
    }
    .node rect{
      stroke: rgba(16,24,40,.18); stroke-width: 1.2;
      rx:10; ry:10; shape-rendering: geometricPrecision;
    }
    .node .name{
      font-size: 12px; font-weight: 700; font-family: Arial, Helvetica, sans-serif;
      text-rendering: geometricPrecision;
    }
    .node .small{
      font-size: 10px; font-weight: 700; font-family: Arial, Helvetica, sans-serif;
    }
  `;
}
function serializeSvgForExport(){
  if (!viewport) throw new Error("Nada para exportar. Gere a taxonomia antes.");
  const svgNode = svg.node();
  const clone = svgNode.cloneNode(true);
  clone.setAttribute("xmlns","http://www.w3.org/2000/svg");

  // remove event handlers
  clone.querySelectorAll("*").forEach(el=>{
    [...el.attributes].forEach(a=>{
      if (a.name.startsWith("on")) el.removeAttribute(a.name);
    });
  });

  // fundo branco
  const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
  bg.setAttribute("x","0"); bg.setAttribute("y","0");
  bg.setAttribute("width","100%"); bg.setAttribute("height","100%");
  bg.setAttribute("fill","#ffffff");
  clone.insertBefore(bg, clone.firstChild);

  // estilo embutido
  const style = document.createElementNS("http://www.w3.org/2000/svg","style");
  style.textContent = embeddedExportStyle();
  clone.insertBefore(style, clone.firstChild.nextSibling);

  // inline fonts (evita PNG branco por perda de CSS)
  clone.querySelectorAll("text").forEach(t=>{
    t.setAttribute("font-family","Arial, Helvetica, sans-serif");
    t.setAttribute("font-weight","700");
  });
  clone.querySelectorAll("path.link").forEach(p=>{
    p.setAttribute("vector-effect","non-scaling-stroke");
    p.setAttribute("stroke-linecap","round");
    p.setAttribute("stroke-linejoin","round");
  });

  // viewBox baseado no bbox real do viewport original
  const bbox = viewport.node().getBBox();
  const pad = 40;
  const x = bbox.x - pad, y = bbox.y - pad, w = bbox.width + pad*2, h = bbox.height + pad*2;
  clone.setAttribute("viewBox", `${x} ${y} ${w} ${h}`);
  clone.setAttribute("width", String(Math.round(w)));
  clone.setAttribute("height", String(Math.round(h)));

  return new XMLSerializer().serializeToString(clone);
}

btnSvg.addEventListener("click", () => {
  try{
    const xml = serializeSvgForExport();
    downloadBlob(new Blob([xml], {type:"image/svg+xml;charset=utf-8"}), exportName("svg"));
  } catch(e){
    toast("Falha ao exportar SVG: " + e.message, true);
  }
});

btnPng.addEventListener("click", async () => {
  try{
    const scale = parseInt(pngScaleSel.value || "3", 10);
    const xml = serializeSvgForExport();

    const svgBlob = new Blob([xml], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(svgBlob);

    const img = new Image();
    img.decoding = "async";
    img.src = url;

    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = () => reject(new Error("Falha ao renderizar SVG no PNG."));
    });

    // l√™ width/height do SVG exportado (n√£o depende de bbox em DOM)
    const tmp = document.createElement("div");
    tmp.style.position="fixed"; tmp.style.left="-9999px";
    tmp.innerHTML = xml;
    document.body.appendChild(tmp);
    const s = tmp.querySelector("svg");
    const w = parseFloat(s.getAttribute("width")) || 1600;
    const h = parseFloat(s.getAttribute("height")) || 900;
    tmp.remove();

    const canvas = document.createElement("canvas");
    canvas.width = Math.round(w * scale);
    canvas.height = Math.round(h * scale);

    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.setTransform(scale,0,0,scale,0,0);
    ctx.drawImage(img, 0, 0);

    URL.revokeObjectURL(url);

    canvas.toBlob((blob)=>{
      if (!blob) return toast("Falha ao gerar PNG.", true);
      downloadBlob(blob, exportName("png"));
    }, "image/png", 1.0);

  } catch(e){
    toast("Falha ao exportar PNG: " + e.message, true);
  }
});

/* ============================
   Boot
============================ */
(async function(){
  try{ await loadDefault(); } catch(_) {}
})();
</script>
</body>
</html>
