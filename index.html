<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Taxonomia (OWL ‚Üí √Årvore)</title>

  <!-- D3 for layout + zoom/pan -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

  <!-- rdflib.js for RDF/OWL parsing -->
  <script src="https://cdn.jsdelivr.net/npm/rdflib@2.2.35/dist/rdflib.min.js"></script>

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #111826;
      --text: #e6edf3;
      --muted: #9aa4b2;
      --line: rgba(255,255,255,.10);
      --chip: rgba(255,255,255,.08);
      --accent: #7aa2f7;
      --warn: #f7c97a;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    header {
      position: sticky; top: 0; z-index: 10;
      background: linear-gradient(180deg, rgba(11,15,20,.98), rgba(11,15,20,.85));
      border-bottom: 1px solid var(--line);
      padding: 12px 14px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 12px;
      align-items: center;
    }
    .title { display: flex; flex-direction: column; gap: 4px; }
    .title h1 { margin: 0; font-size: 14px; font-weight: 700; letter-spacing: .2px; }
    .title .sub { font-size: 12px; color: var(--muted); }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: flex-end; }
    .btn, .file, .input {
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .btn { cursor: pointer; user-select: none; }
    .btn:hover { border-color: rgba(255,255,255,.22); }
    .file input[type="file"] { display: none; }
    .input input {
      border: none; outline: none; background: transparent; color: var(--text);
      width: 240px; font-size: 12px;
    }
    .chip {
      background: var(--chip);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    #wrap { height: calc(100% - 66px); }
    svg { width: 100%; height: 100%; display: block; }
    .node rect {
      fill: rgba(255,255,255,.06);
      stroke: rgba(255,255,255,.16);
      stroke-width: 1;
      rx: 10;
      ry: 10;
    }
    .node text { font-size: 12px; fill: var(--text); pointer-events: none; }
    .node .small { font-size: 10px; fill: var(--muted); }
    .link { fill: none; stroke: rgba(255,255,255,.16); stroke-width: 1.2; }
    .node--highlight rect { stroke: var(--accent); stroke-width: 2; }
    .node--match rect { stroke: var(--warn); stroke-width: 2; }
    .toast {
      position: fixed; left: 14px; bottom: 14px; z-index: 50;
      background: rgba(17,24,38,.92);
      border: 1px solid var(--line);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      color: var(--muted);
      max-width: min(640px, calc(100% - 28px));
      white-space: pre-wrap;
    }
    .legend {
      position: fixed; right: 14px; bottom: 14px; z-index: 40;
      background: rgba(17,24,38,.92);
      border: 1px solid var(--line);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      color: var(--muted);
      max-width: 380px;
    }
    .legend b { color: var(--text); }
  </style>
</head>

<body>
<header>
  <div class="title">
    <h1>Taxonomia gerada a partir de OWL (todas as classes)</h1>
    <div class="sub">
      Carrega um arquivo <b>.owl/.rdf/.ttl</b> e monta uma √°rvore por <code>rdfs:subClassOf</code>.
      Classes √≥rf√£s (sem superclasse) aparecem em ‚ÄúOrphan Classes‚Äù.
    </div>
  </div>

  <div class="controls">
    <label class="file btn" title="Carregar OWL do seu computador">
      üìÑ Carregar OWL
      <input id="fileInput" type="file" accept=".owl,.rdf,.ttl,.xml,.n3,.nt,.jsonld,.json" />
    </label>

    <div class="btn" id="btnLoadDefault" title="Tenta carregar ontohate_.owl do mesmo diret√≥rio do index.html">
      ‚¨áÔ∏è Carregar ontohate_.owl
    </div>

    <div class="input" title="Buscar classe pelo nome/label">
      üîé <input id="search" placeholder="Buscar (ex.: Motiva√ß√£o, Modera√ß√£o...)" />
    </div>

    <div class="btn" id="btnExpandAll" title="Expandir tudo">‚ûï Expandir</div>
    <div class="btn" id="btnCollapseAll" title="Recolher tudo">‚ûñ Recolher</div>

    <span class="chip" id="stats">Classes: ‚Äî | Rela√ß√µes: ‚Äî</span>
  </div>
</header>

<div id="wrap">
  <svg id="svg"></svg>
</div>

<div class="legend">
  <div><b>Dicas</b></div>
  <div>‚Ä¢ Arraste para mover, roda do mouse para zoom.</div>
  <div>‚Ä¢ Clique em um n√≥ para recolher/expandir.</div>
  <div>‚Ä¢ Busca destaca n√≥s (amarelo) e centraliza no primeiro match.</div>
</div>

<div class="toast" id="toast" style="display:none;"></div>

<script>
/**
 * index.html (browser-only)
 * - Parses OWL/RDF with rdflib.js
 * - Extracts ALL owl:Class and rdfs:subClassOf relations
 * - Builds a forest with:
 *    - owl:Thing (if present) as a root
 *    - plus a synthetic "Orphan Classes" root for anything without a superclass
 * - Renders collapsible tree (D3) with zoom/pan + search
 */

const RDF = $rdf.Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
const RDFS = $rdf.Namespace("http://www.w3.org/2000/01/rdf-schema#");
const OWL = $rdf.Namespace("http://www.w3.org/2002/07/owl#");

const svg = d3.select("#svg");
const g = svg.append("g");

const toastEl = document.getElementById("toast");
function toast(msg) {
  toastEl.textContent = msg;
  toastEl.style.display = "block";
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(() => (toastEl.style.display = "none"), 6500);
}

const statsEl = document.getElementById("stats");
const searchEl = document.getElementById("search");
const fileInput = document.getElementById("fileInput");

document.getElementById("btnLoadDefault").addEventListener("click", async () => {
  try {
    const res = await fetch("ontohate_.owl", { cache: "no-store" });
    if (!res.ok) throw new Error("N√£o consegui baixar 'ontohate_.owl'. Rode via servidor local e coloque o arquivo na mesma pasta do index.html.");
    const text = await res.text();
    await buildFromText(text, guessContentType("ontohate_.owl"));
  } catch (e) {
    toast("Erro ao carregar arquivo padr√£o:\n" + e.message);
  }
});

fileInput.addEventListener("change", async (ev) => {
  const f = ev.target.files?.[0];
  if (!f) return;
  const text = await f.text();
  await buildFromText(text, guessContentType(f.name));
});

// D3 zoom/pan
const zoom = d3.zoom()
  .scaleExtent([0.15, 2.5])
  .on("zoom", (event) => g.attr("transform", event.transform));
svg.call(zoom);

// Layout parameters
let root = null;
let treeLayout = d3.tree();
let nodeIdCounter = 0;
let currentMatches = [];

function guessContentType(filename) {
  const lower = filename.toLowerCase();
  if (lower.endsWith(".ttl")) return "text/turtle";
  if (lower.endsWith(".nt")) return "application/n-triples";
  if (lower.endsWith(".n3")) return "text/n3";
  if (lower.endsWith(".jsonld") || lower.endsWith(".json")) return "application/ld+json";
  // .owl/.rdf/.xml defaults to RDF/XML
  return "application/rdf+xml";
}

function termToNiceName(store, term) {
  // Prefer rdfs:label, else fragment, else full IRI
  const label = store.any(term, RDFS("label"));
  if (label && label.value) return label.value;

  const v = term.value || "";
  const hash = v.lastIndexOf("#");
  if (hash >= 0 && hash < v.length - 1) return decodeURIComponent(v.slice(hash + 1));

  const slash = v.lastIndexOf("/");
  if (slash >= 0 && slash < v.length - 1) return decodeURIComponent(v.slice(slash + 1));

  return v || "(blank node)";
}

function isBuiltinToIgnore(iri) {
  // Keep owl:Thing (we want it), but ignore other built-ins if you prefer.
  // We'll ignore RDF/RDFS/OWL vocabulary classes except owl:Thing.
  const v = iri || "";
  if (v === OWL("Thing").value) return false;
  return (
    v.startsWith(RDF("").value) ||
    v.startsWith(RDFS("").value) ||
    v.startsWith(OWL("").value)
  );
}

function uniqByValue(arr) {
  const s = new Set();
  const out = [];
  for (const x of arr) {
    const v = x.value || String(x);
    if (!s.has(v)) { s.add(v); out.push(x); }
  }
  return out;
}

async function buildFromText(text, contentType) {
  // Parse RDF into rdflib store
  const store = $rdf.graph();
  const baseIRI = "http://example.local/base#";

  try {
    $rdf.parse(text, store, baseIRI, contentType);
  } catch (e) {
    // Fallback attempts: if contentType guess was wrong
    const fallbacks = ["application/rdf+xml", "text/turtle", "application/n-triples", "application/ld+json"];
    let ok = false;
    for (const ct of fallbacks) {
      try {
        $rdf.parse(text, store, baseIRI, ct);
        ok = true;
        toast(`Parse ok usando fallback: ${ct}`);
        break;
      } catch (_) {}
    }
    if (!ok) {
      toast("Falha ao interpretar o arquivo. Verifique se √© um OWL/RDF v√°lido.\nDetalhe:\n" + e.message);
      return;
    }
  }

  // Extract ALL classes:
  // - explicit: ?c rdf:type owl:Class
  // - plus anything appearing in rdfs:subClassOf positions (both subject & object)
  const explicitClasses = store.each(undefined, RDF("type"), OWL("Class"));
  const subSubjects = store.each(undefined, RDFS("subClassOf"), undefined);
  const subObjects  = store.each(undefined, RDFS("subClassOf"), undefined).map(s => store.any(s, RDFS("subClassOf")));
  // Note: subObjects above returns superclasses; easier:
  const superclasses = store.each(undefined, RDFS("subClassOf"), undefined).map(s => store.any(s, RDFS("subClassOf"))).filter(Boolean);

  let allClasses = uniqByValue([...explicitClasses, ...subSubjects, ...superclasses].filter(Boolean));

  // Remove blank nodes that represent restrictions / anonymous classes
  // but keep named classes. For restrictions, we still keep the named class that points to them.
  allClasses = allClasses.filter(t => t.termType === "NamedNode");

  // Optionally ignore built-in vocab terms (except owl:Thing)
  allClasses = allClasses.filter(t => !isBuiltinToIgnore(t.value));

  // Build subclass edges (named class -> named superclass)
  const subclassTriples = store.statementsMatching(undefined, RDFS("subClassOf"), undefined);
  const edges = [];
  for (const st of subclassTriples) {
    if (st.subject.termType !== "NamedNode") continue;
    // object can be Restriction (blank node). We skip anonymous superclasses in the taxonomy.
    if (st.object.termType !== "NamedNode") continue;

    if (isBuiltinToIgnore(st.subject.value) || isBuiltinToIgnore(st.object.value)) {
      // keep owl:Thing as superclass if present
      if (st.object.value !== OWL("Thing").value) continue;
      if (st.subject.value === OWL("Thing").value) continue;
    }

    edges.push([st.subject.value, st.object.value]);
  }

  // Ensure all class IRIs appear in maps even if disconnected
  const classesByIri = new Map();
  for (const c of allClasses) {
    classesByIri.set(c.value, {
      iri: c.value,
      name: termToNiceName(store, c),
      children: []
    });
  }

  // Also ensure any class appearing in edges is included
  for (const [childIri, parentIri] of edges) {
    if (!classesByIri.has(childIri)) {
      const t = $rdf.namedNode(childIri);
      classesByIri.set(childIri, { iri: childIri, name: termToNiceName(store, t), children: [] });
    }
    if (!classesByIri.has(parentIri)) {
      const t = $rdf.namedNode(parentIri);
      classesByIri.set(parentIri, { iri: parentIri, name: termToNiceName(store, t), children: [] });
    }
  }

  // Parent links (a class can have multiple superclasses; we‚Äôll attach it under ALL superclasses)
  // For rendering as a tree, multi-parent makes it a DAG. We handle by cloning nodes per parent.
  // That guarantees "nenhuma classe fique de fora".
  const parentsOf = new Map(); // childIri -> Set(parentIri)
  for (const [childIri, parentIri] of edges) {
    if (!parentsOf.has(childIri)) parentsOf.set(childIri, new Set());
    parentsOf.get(childIri).add(parentIri);
  }

  // Find roots:
  // A root is a class that has no named superclass (in our filtered edge list)
  const hasParent = new Set(edges.map(e => e[0]));
  const allIris = Array.from(classesByIri.keys());
  const roots = [];
  for (const iri of allIris) {
    const pset = parentsOf.get(iri);
    const noParents = !pset || pset.size === 0;
    if (noParents) roots.push(iri);
  }

  // If owl:Thing exists, we attach everything to it (directly or via existing links),
  // but we still keep Orphans to ensure coverage.
  const hasThing = classesByIri.has(OWL("Thing").value);

  // Build a synthetic forest root
  const forest = {
    iri: "__FOREST__",
    name: "Ontology Taxonomy",
    children: []
  };

  // Create a "Thing" node if present
  if (hasThing) {
    forest.children.push({ iri: OWL("Thing").value, name: classesByIri.get(OWL("Thing").value).name, children: [] });
  }

  // Orphan bucket
  const orphanBucket = { iri: "__ORPHANS__", name: "Orphan Classes", children: [] };
  forest.children.push(orphanBucket);

  // Helper: clone DAG into a tree under a given parent
  function buildSubtree(iri, stack = new Set()) {
    const base = classesByIri.get(iri);
    const node = {
      iri: base.iri,
      name: base.name,
      children: [],
      _id: ++nodeIdCounter
    };

    // Prevent infinite loops (just in case)
    if (stack.has(iri)) return node;
    stack.add(iri);

    // children = all classes where this iri is a parent
    const kids = [];
    for (const [childIri, pset] of parentsOf.entries()) {
      if (pset.has(iri)) kids.push(childIri);
    }

    // stable sort
    kids.sort((a, b) => {
      const na = (classesByIri.get(a)?.name || a).toLowerCase();
      const nb = (classesByIri.get(b)?.name || b).toLowerCase();
      return na.localeCompare(nb);
    });

    for (const k of kids) node.children.push(buildSubtree(k, new Set(stack)));
    return node;
  }

  // Build under owl:Thing if present:
  // - children = those that explicitly have owl:Thing as a superclass
  // - (if none do) we still keep orphans list.
  if (hasThing) {
    const thingNode = forest.children.find(c => c.iri === OWL("Thing").value);
    const directThingKids = [];
    for (const [childIri, pset] of parentsOf.entries()) {
      if (pset.has(OWL("Thing").value)) directThingKids.push(childIri);
    }
    directThingKids.sort((a, b) => (classesByIri.get(a).name || "").localeCompare(classesByIri.get(b).name || ""));
    for (const kid of directThingKids) thingNode.children.push(buildSubtree(kid));
  }

  // Orphans = roots excluding owl:Thing (and excluding those already under owl:Thing path)
  const orphanCandidates = roots.filter(r => r !== OWL("Thing").value);

  // Also ensure any disconnected class still appears: if a class has parents but parent is anonymous (skipped),
  // it may be in roots by our filtered graph; good. If not, but it never appears in subtree, we add it too.
  const seenInTree = new Set();
  function markSeen(node) {
    if (node.iri && !node.iri.startsWith("__")) seenInTree.add(node.iri);
    (node.children || []).forEach(markSeen);
  }
  // temporarily render forest to mark after building thing kids
  forest.children.forEach(markSeen);

  // Add orphan roots
  orphanCandidates.sort((a, b) => (classesByIri.get(a).name || "").localeCompare(classesByIri.get(b).name || ""));
  for (const r of orphanCandidates) {
    orphanBucket.children.push(buildSubtree(r));
  }

  // Ensure coverage: add any missing class as a leaf under Orphans
  for (const iri of allIris) {
    if (iri === OWL("Thing").value) continue;
    if (!seenInTree.has(iri)) {
      orphanBucket.children.push({
        iri,
        name: classesByIri.get(iri).name,
        children: [],
        _id: ++nodeIdCounter
      });
    }
  }

  // Update stats
  const classCount = allIris.length;
  const relCount = edges.length;
  statsEl.textContent = `Classes: ${classCount} | Rela√ß√µes: ${relCount}`;

  // Render
  renderTree(forest);

  toast(
    `Arquivo carregado.\n` +
    `Classes (incluindo desconectadas): ${classCount}\n` +
    `Rela√ß√µes rdfs:subClassOf (nomeadas): ${relCount}\n` +
    `Obs.: Superclasses an√¥nimas (restrictions) n√£o entram como n√≥s; a classe nomeada fica no lugar correto e, se necess√°rio, vai para "Orphan Classes".`
  );
}

function renderTree(data) {
  svg.selectAll("*").remove();
  const g = svg.append("g");

  const { width, height } = svg.node().getBoundingClientRect();
  const margin = { top: 30, right: 30, bottom: 30, left: 30 };

  // Convert to d3 hierarchy
  root = d3.hierarchy(data);

  // Default collapse: keep first two levels open
  root.x0 = height / 2;
  root.y0 = 0;

  root.children?.forEach((c) => {
    // keep top level open
    c.children?.forEach((cc) => {
      // collapse deeper
      collapse(cc);
    });
  });

  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  // Tree layout sizing: y based on depth
  const dx = 34;
  const dy = 220;
  treeLayout = d3.tree().nodeSize([dx, dy]);

  // Links + nodes layers
  const linkLayer = g.append("g").attr("fill", "none").attr("stroke", "currentColor").attr("stroke-opacity", 0.6);
  const nodeLayer = g.append("g").attr("cursor", "pointer");

  // Zoom
  svg.call(
    d3.zoom()
      .scaleExtent([0.15, 2.5])
      .on("zoom", (event) => g.attr("transform", event.transform))
  );

  // Initial center
  svg.call(d3.zoom().transform, d3.zoomIdentity.translate(margin.left, margin.top).scale(1));

  function update(source) {
    // Compute new tree
    treeLayout(root);

    const nodes = root.descendants();
    const links = root.links();

    // Compute bounds
    let left = root, right = root;
    root.eachBefore(node => {
      if (node.x < left.x) left = node;
      if (node.x > right.x) right = node;
    });

    const treeHeight = right.x - left.x + margin.top + margin.bottom;
    const treeWidth = (d3.max(nodes, d => d.depth) || 1) * dy + margin.left + margin.right;

    svg.attr("viewBox", [0, 0, Math.max(width, treeWidth), Math.max(height, treeHeight)]);

    // --- Links
    const link = linkLayer.selectAll("path.link")
      .data(links, d => d.target.data._id || (d.target.data._id = ++nodeIdCounter));

    link.enter()
      .append("path")
      .attr("class", "link")
      .attr("d", d => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
      })
      .merge(link)
      .transition()
      .duration(220)
      .attr("d", diagonal);

    link.exit()
      .transition()
      .duration(220)
      .attr("d", d => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
      })
      .remove();

    // --- Nodes
    const node = nodeLayer.selectAll("g.node")
      .data(nodes, d => d.data._id || (d.data._id = ++nodeIdCounter));

    const nodeEnter = node.enter()
      .append("g")
      .attr("class", "node")
      .attr("transform", d => `translate(${source.y0},${source.x0})`)
      .on("click", (_, d) => {
        if (d.children) { d._children = d.children; d.children = null; }
        else { d.children = d._children; d._children = null; }
        update(d);
      });

    // Node cards
    nodeEnter.append("rect")
      .attr("x", -6)
      .attr("y", -18)
      .attr("width", 14)
      .attr("height", 14)
      .attr("opacity", 0.0); // placeholder to keep layout stable

    // Main label
    nodeEnter.append("rect")
      .attr("x", 0)
      .attr("y", -18)
      .attr("width", 360)
      .attr("height", 36);

    nodeEnter.append("text")
      .attr("x", 12)
      .attr("y", -2)
      .text(d => d.data.name || "(sem nome)");

    // Small IRI line (muted)
    nodeEnter.append("text")
      .attr("class", "small")
      .attr("x", 12)
      .attr("y", 14)
      .text(d => (d.data.iri && !String(d.data.iri).startsWith("__")) ? compactIri(d.data.iri) : "");

    // Expand/collapse indicator
    nodeEnter.append("text")
      .attr("x", 330)
      .attr("y", -2)
      .attr("text-anchor", "end")
      .attr("class", "small")
      .text(d => (d.children || d._children) ? (d.children ? "‚ñæ" : "‚ñ∏") : "");

    const nodeMerge = nodeEnter.merge(node);

    nodeMerge.transition()
      .duration(220)
      .attr("transform", d => `translate(${d.y},${d.x})`);

    nodeMerge.select("rect:nth-child(2)")
      .attr("width", d => Math.min(520, 160 + (d.data.name?.length || 10) * 7))
      .attr("height", 36);

    nodeMerge.select("text:nth-of-type(3)")
      .text(d => (d.children || d._children) ? (d.children ? "‚ñæ" : "‚ñ∏") : "");

    node.exit()
      .transition()
      .duration(220)
      .attr("transform", d => `translate(${source.y},${source.x})`)
      .remove();

    // Store old positions for transition
    nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });

    // Re-apply highlight after update (for search)
    applySearchHighlight();
  }

  function diagonal(d) {
    return d3.linkHorizontal()
      .x(d => d.y)
      .y(d => d.x)(d);
  }

  function compactIri(iri) {
    // show only tail, but keep some context
    try {
      const u = new URL(iri);
      const tail = iri.includes("#") ? iri.split("#").pop() : iri.split("/").pop();
      return `${u.hostname}‚Ä¶/${tail}`;
    } catch {
      const tail = iri.includes("#") ? iri.split("#").pop() : iri.split("/").pop();
      return tail;
    }
  }

  // Public controls
  document.getElementById("btnExpandAll").onclick = () => {
    expandAll(root);
    update(root);
  };
  document.getElementById("btnCollapseAll").onclick = () => {
    root.children?.forEach(collapseAllButTop);
    update(root);
  };

  function expandAll(d) {
    if (d._children) { d.children = d._children; d._children = null; }
    (d.children || []).forEach(expandAll);
  }
  function collapseAllButTop(d) {
    // Keep one level open under root; collapse deeper
    (d.children || []).forEach(c => {
      if (c.children) {
        c._children = c.children;
        c.children = null;
      }
      (c._children || []).forEach(cc => collapseDeep(cc));
    });
  }
  function collapseDeep(d) {
    if (d.children) {
      d._children = d.children;
      d.children = null;
    }
    (d._children || []).forEach(collapseDeep);
  }

  // Search
  searchEl.oninput = () => applySearchHighlight(true);

  function applySearchHighlight(centerFirst = false) {
    const q = (searchEl.value || "").trim().toLowerCase();
    currentMatches = [];
    g.selectAll("g.node").classed("node--match", false);

    if (!q) return;

    g.selectAll("g.node").each(function(d) {
      const name = (d.data.name || "").toLowerCase();
      const iri = (d.data.iri || "").toLowerCase();
      if (name.includes(q) || iri.includes(q)) {
        d3.select(this).classed("node--match", true);
        currentMatches.push(d);
      }
    });

    if (centerFirst && currentMatches.length) {
      const d = currentMatches[0];
      // Expand path to node so it's visible
      expandAncestors(d);
      update(d);
      centerOnNode(d);
    }
  }

  function expandAncestors(d) {
    let cur = d;
    while (cur) {
      if (cur._children) { cur.children = cur._children; cur._children = null; }
      cur = cur.parent;
    }
  }

  function centerOnNode(d) {
    const { width, height } = svg.node().getBoundingClientRect();
    const t = d3.zoomTransform(svg.node());
    const scale = t.k;
    const x = d.y * scale;
    const y = d.x * scale;
    const tx = width / 2 - x;
    const ty = height / 2 - y;

    svg.transition()
      .duration(350)
      .call(d3.zoom().transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
  }

  update(root);
}

// Auto-load hint (optional): try to fetch ontohate_.owl if present
(async function autoTry() {
  try {
    const res = await fetch("ontohate_.owl", { cache: "no-store" });
    if (res.ok) {
      const text = await res.text();
      await buildFromText(text, guessContentType("ontohate_.owl"));
    } else {
      toast("Dica: coloque 'ontohate_.owl' na mesma pasta do index.html e clique em ‚ÄúCarregar ontohate_.owl‚Äù.");
    }
  } catch {
    toast("Dica: rode um servidor local (ex.: 'python -m http.server') para permitir fetch do arquivo OWL.");
  }
})();
</script>
</body>
</html>
