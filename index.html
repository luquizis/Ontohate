<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ONTOHATE Taxonomy Explorer</title>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/rdflib@2.2.37/dist/rdflib.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --panel:#121c2f;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --stroke:#24324f;
      --accent:#60a5fa;
      --danger:#fb7185;
      --ok:#34d399;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    body{background:var(--bg); color:var(--text); overflow:hidden;}
    a{color:var(--accent); text-decoration:none}
    .app{display:grid; grid-template-columns: 380px 1fr; height:100%;}
    .sidebar{
      background:linear-gradient(180deg, rgba(18,28,47,0.96), rgba(15,23,42,0.96));
      border-right:1px solid var(--stroke);
      padding:14px;
      overflow:auto;
    }
    .main{position:relative;}
    .topbar{
      position:absolute; left:0; right:0; top:0;
      display:flex; gap:10px; align-items:center;
      padding:10px 12px;
      background:rgba(15,23,42,0.70);
      backdrop-filter: blur(8px);
      border-bottom:1px solid var(--stroke);
      z-index:10;
      flex-wrap:wrap;
    }
    .card{
      background:rgba(18,28,47,0.75);
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:12px;
      margin-bottom:12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.25);
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .col{display:flex; flex-direction:column; gap:6px;}
    label{font-size:12px; color:var(--muted);}
    input[type="text"], select, textarea{
      width:100%;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:rgba(11,18,32,0.7);
      color:var(--text);
      outline:none;
    }
    textarea{min-height:70px; resize:vertical}
    input[type="color"]{
      width:34px; height:34px; border:none; background:transparent; padding:0;
    }
    input[type="range"]{width:170px}
    button{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:rgba(96,165,250,0.12);
      color:var(--text);
      cursor:pointer;
    }
    button:hover{border-color:rgba(96,165,250,0.65)}
    button.primary{background:rgba(96,165,250,0.20); border-color:rgba(96,165,250,0.55)}
    button.danger{background:rgba(251,113,133,0.16); border-color:rgba(251,113,133,0.55)}
    button.ghost{background:rgba(11,18,32,0.35)}
    .small{font-size:12px; color:var(--muted); line-height:1.35}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid var(--stroke);
      background:rgba(11,18,32,0.55);
      padding:8px 10px; border-radius:999px;
    }
    .dims{display:flex; flex-direction:column; gap:8px; margin-top:8px;}
    .dimItem{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border:1px solid var(--stroke);
      border-radius:14px;
      background:rgba(11,18,32,0.55);
    }
    .dimLeft{display:flex; align-items:center; gap:10px; min-width:0;}
    .dimName{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-size:13px;}
    .status{font-size:12px; color:var(--muted);}
    #svgWrap{position:absolute; inset:0; padding-top:64px;}
    svg{width:100%; height:100%; display:block;}
    .node rect{
      rx:10; ry:10;
      stroke:rgba(0,0,0,0.35);
      stroke-width:1;
      filter: drop-shadow(0px 6px 14px rgba(0,0,0,0.25));
    }
    .node text{
      font-size:12px;
      pointer-events:none;
      fill: var(--text);
    }
    .node.selected rect{
      stroke: rgba(255,255,255,0.85);
      stroke-width: 2.2;
      filter: drop-shadow(0px 8px 18px rgba(96,165,250,0.30));
    }
    .link{
      fill:none;
      stroke:rgba(148,163,184,0.65);
      stroke-width:1.8;
    }
    .tooltip{
      position:absolute;
      max-width: 420px;
      pointer-events:none;
      background:rgba(15,23,42,0.92);
      border:1px solid rgba(36,50,79,0.9);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-size:12px;
      line-height:1.35;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      z-index:50;
    }
    .tooltip .tTitle{font-weight:700; font-size:13px;}
    .tooltip .tMeta{color:var(--muted)}
    .tooltip hr{border:none; border-top:1px solid rgba(36,50,79,0.7); margin:8px 0;}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:11px; padding:2px 6px; border-radius:8px;
      border:1px solid rgba(36,50,79,0.9);
      background:rgba(11,18,32,0.65);
      color:var(--text);
    }
    .searchResults{
      margin-top:8px;
      border:1px solid var(--stroke);
      border-radius:14px;
      overflow:hidden;
      background:rgba(11,18,32,0.45);
    }
    .searchItem{
      padding:8px 10px;
      border-top:1px solid rgba(36,50,79,0.7);
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      gap:12px;
    }
    .searchItem:hover{background:rgba(96,165,250,0.10)}
    .searchItem:first-child{border-top:none}
    .tag{
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
    }
  </style>
</head>

<body>
<div class="app">
  <aside class="sidebar">
    <div class="card">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
        <div>
          <div style="font-weight:800; font-size:16px;">ONTOHATE • Taxonomy Explorer</div>
          <div class="small">GitHub Pages + OWL (rdflib) + D3</div>
        </div>
        <div class="pill"><span class="status" id="loadStatus">aguardando…</span></div>
      </div>
      <div class="small" style="margin-top:10px;">
        <b>Interação:</b> clique = selecionar • <span class="kbd">Alt</span> + clique = expandir/colapsar • arrastar = mover
      </div>
    </div>

    <div class="card">
      <div class="col">
        <label>URL do OWL (RAW do GitHub)</label>
        <input id="owlUrl" type="text" />
        <div class="row">
          <button class="primary" id="btnLoad">Carregar ontologia</button>
          <button class="ghost" id="btnFit">Ajustar na tela</button>
          <button class="danger" id="btnReset">Reset</button>
        </div>
        <div class="small">
          Este repositório: <span class="kbd">raw.githubusercontent.com/luquizis/Ontohate/main/ontohate_.owl</span>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="col">
        <label>Busca por classe</label>
        <input id="searchInput" type="text" placeholder="Digite parte do nome (ex.: natureza, moderação, ameaça…)" disabled />
        <div class="row">
          <button id="btnSearchClear" class="ghost" disabled>Limpar</button>
          <button id="btnSearchShowAll" class="ghost" disabled>Mostrar todas</button>
        </div>
        <div class="small">A lista mostra correspondências por <b>label</b> e por fragmento do IRI.</div>
        <div id="searchResults" class="searchResults" style="display:none;"></div>
      </div>
    </div>

    <div class="card">
      <div class="col">
        <label>Classe raiz (dimensões = subclasses diretas)</label>
        <select id="rootSelect" disabled></select>
        <div class="small">
          Dimensões/subontologias são as <b>subclasses diretas</b> da raiz.
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="col" style="flex:1;">
          <label>Dimensões (selecione 1+)</label>
          <div class="small">Selecionar dimensões faz a taxonomia ser formada por união das subárvores.</div>
        </div>
        <div class="row">
          <button id="btnAll">Todas</button>
          <button id="btnNone">Nenhuma</button>
        </div>
      </div>
      <div class="dims" id="dimsList"></div>
    </div>

    <div class="card">
      <div class="col">
        <label>Visualização</label>
        <select id="layoutSelect" disabled>
          <option value="topdown">Top-down</option>
          <option value="leftright">Esquerda → Direita</option>
          <option value="radial">Radial</option>
          <option value="a4">A4 (vertical)</option>
        </select>

        <div class="row" style="margin-top:10px;">
          <div class="col">
            <label>Curvatura das arestas</label>
            <input id="edgeCurve" type="range" min="0" max="100" value="35" disabled />
          </div>
          <div class="col">
            <label>Espessura</label>
            <input id="edgeWidth" type="range" min="1" max="6" value="2" disabled />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div class="col">
            <label>Cor das arestas</label>
            <input id="edgeColor" type="color" value="#94a3b8" disabled />
          </div>
          <div class="col">
            <label>Cor de fundo</label>
            <input id="bgColor" type="color" value="#0b1220" disabled />
          </div>
          <div class="col">
            <label>Persistir (localStorage)</label>
            <select id="persistSelect">
              <option value="on" selected>Ligado</option>
              <option value="off">Desligado</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnExportSVG" disabled>Exportar SVG</button>
          <button id="btnExportPNG" disabled>Exportar PNG</button>
        </div>

        <div class="small" style="margin-top:10px;">
          Export PNG usa a área visível atual (após zoom/pan).  
          Use “A4” + “Ajustar na tela” para obter uma figura pronta para artigo.
        </div>
      </div>
    </div>

    <div class="card" id="editorCard" style="opacity:0.55;">
      <div class="col">
        <label>Editor do nó selecionado</label>
        <div class="small" id="editorHint">Selecione um nó no gráfico para editar.</div>

        <label style="margin-top:6px;">Nome (label local)</label>
        <input id="edLabel" type="text" disabled />

        <div class="row" style="margin-top:8px;">
          <div class="col">
            <label>Cor (fill)</label>
            <input id="edFill" type="color" value="#64748b" disabled />
          </div>
          <div class="col">
            <label>Borda</label>
            <input id="edStroke" type="color" value="#111827" disabled />
          </div>
          <div class="col">
            <label>Opacidade</label>
            <input id="edOpacity" type="range" min="10" max="100" value="92" disabled />
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <div class="col">
            <label>Largura</label>
            <input id="edW" type="range" min="120" max="520" value="180" disabled />
          </div>
          <div class="col">
            <label>Altura</label>
            <input id="edH" type="range" min="26" max="90" value="36" disabled />
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <div class="col">
            <label>Fonte</label>
            <input id="edFont" type="range" min="10" max="18" value="12" disabled />
          </div>
          <div class="col">
            <label>Raio</label>
            <input id="edRadius" type="range" min="0" max="22" value="10" disabled />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnEditorApply" class="primary" disabled>Aplicar</button>
          <button id="btnEditorReset" class="ghost" disabled>Reset nó</button>
        </div>
        <div class="small" style="margin-top:8px;">
          Tudo aqui é <b>local</b> (não altera o OWL).  
          Se persistência estiver ligada, fica salvo no navegador.
        </div>
      </div>
    </div>

    <div class="card">
      <div class="small">
        <b>Tooltip</b> mostra: IRI, labels, comentários, super/subclasses, relações OWL e
        <b>propriedades</b> (object/datatype) onde a classe aparece como domain/range, e restrições quando detectáveis.
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="topbar">
      <div class="pill"><span class="status" id="graphInfo">sem grafo</span></div>
      <div class="pill"><span class="status">Zoom: <span id="zoomInfo">100%</span></span></div>
      <div class="pill"><span class="status">Nós: <span id="nodeCount">0</span> • Arestas: <span id="edgeCount">0</span></span></div>
      <div class="pill"><span class="status">Selecionado: <span id="selInfo">—</span></span></div>
      <div style="margin-left:auto" class="pill">
        <span class="status">Wheel zoom • Drag pan</span>
      </div>
    </div>

    <div id="svgWrap">
      <svg id="svg"></svg>
      <div id="tooltip" class="tooltip" style="display:none;"></div>
    </div>
  </main>
</div>

<script>
/* =========================
   CONFIG / STATE
========================= */
const RDF  = $rdf.Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
const RDFS = $rdf.Namespace("http://www.w3.org/2000/01/rdf-schema#");
const OWL  = $rdf.Namespace("http://www.w3.org/2002/07/owl#");

const STORE = $rdf.graph();

const ui = {
  owlUrl: document.getElementById("owlUrl"),
  btnLoad: document.getElementById("btnLoad"),
  loadStatus: document.getElementById("loadStatus"),

  rootSelect: document.getElementById("rootSelect"),
  dimsList: document.getElementById("dimsList"),
  btnAll: document.getElementById("btnAll"),
  btnNone: document.getElementById("btnNone"),

  layoutSelect: document.getElementById("layoutSelect"),
  edgeCurve: document.getElementById("edgeCurve"),
  edgeWidth: document.getElementById("edgeWidth"),
  edgeColor: document.getElementById("edgeColor"),
  bgColor: document.getElementById("bgColor"),
  persistSelect: document.getElementById("persistSelect"),

  btnFit: document.getElementById("btnFit"),
  btnReset: document.getElementById("btnReset"),
  btnExportSVG: document.getElementById("btnExportSVG"),
  btnExportPNG: document.getElementById("btnExportPNG"),

  graphInfo: document.getElementById("graphInfo"),
  zoomInfo: document.getElementById("zoomInfo"),
  nodeCount: document.getElementById("nodeCount"),
  edgeCount: document.getElementById("edgeCount"),
  tooltip: document.getElementById("tooltip"),

  searchInput: document.getElementById("searchInput"),
  btnSearchClear: document.getElementById("btnSearchClear"),
  btnSearchShowAll: document.getElementById("btnSearchShowAll"),
  searchResults: document.getElementById("searchResults"),

  editorCard: document.getElementById("editorCard"),
  editorHint: document.getElementById("editorHint"),
  edLabel: document.getElementById("edLabel"),
  edFill: document.getElementById("edFill"),
  edStroke: document.getElementById("edStroke"),
  edOpacity: document.getElementById("edOpacity"),
  edW: document.getElementById("edW"),
  edH: document.getElementById("edH"),
  edFont: document.getElementById("edFont"),
  edRadius: document.getElementById("edRadius"),
  btnEditorApply: document.getElementById("btnEditorApply"),
  btnEditorReset: document.getElementById("btnEditorReset"),

  selInfo: document.getElementById("selInfo"),
};

const persistedKey = (suffix) => `ontohate_taxo_${suffix}`;

let state = {
  loaded:false,
  classNodes: new Map(),   // iri -> { iri, label, comments[] }
  subclasses: new Map(),   // iri -> Set(childIri)
  superclasses: new Map(), // iri -> Set(parentIri)
  dimensions: [],          // [{iri,label,color}]
  rootIri: null,
  selectedDims: new Set(),
  collapsed: new Set(),
  customLabels: new Map(),
  nodePositions: new Map(),// layout|iri -> {x,y}
  nodeStyles: new Map(),   // iri -> {fill, stroke, opacity, w, h, font, radius}
  selectedIri: null,
};

const defaultDimPalette = [
  "#60a5fa","#34d399","#fbbf24","#fb7185","#a78bfa",
  "#22c55e","#f472b6","#38bdf8","#f97316","#e879f9"
];

/* =========================
   SVG SETUP
========================= */
const svg = d3.select("#svg");
const wrap = document.getElementById("svgWrap");

const gRoot = svg.append("g").attr("class","gRoot");
const gLinks = gRoot.append("g").attr("class","links");
const gNodes = gRoot.append("g").attr("class","nodes");

let width = 1000, height = 800;

const zoom = d3.zoom()
  .scaleExtent([0.2, 3.5])
  .on("zoom", (event) => {
    gRoot.attr("transform", event.transform);
    ui.zoomInfo.textContent = Math.round(event.transform.k * 100) + "%";
  });

svg.call(zoom);

/* =========================
   HELPERS
========================= */
function setStatus(text, ok=true){
  ui.loadStatus.textContent = text;
  ui.loadStatus.style.color = ok ? "var(--ok)" : "var(--danger)";
}
function uniq(arr){ return [...new Set(arr)]; }
function persistEnabled(){ return ui.persistSelect.value === "on"; }

function shrinkIri(iri){
  try{
    const u = new URL(iri);
    const frag = u.hash ? u.hash.slice(1) : "";
    if (frag) return frag;
    const parts = u.pathname.split("/").filter(Boolean);
    return parts[parts.length-1] || iri;
  }catch(e){
    return iri;
  }
}

function termLabel(iri){
  if (state.customLabels.has(iri)) return state.customLabels.get(iri);
  const node = state.classNodes.get(iri);
  return (node && node.label) ? node.label : shrinkIri(iri);
}

function getLiterals(subject, predicate){
  return STORE.each(subject, predicate, null).filter(o => o.termType === "Literal").map(o=>o.value);
}
function getFirstLiteral(subject, predicate){
  const lits = getLiterals(subject, predicate);
  return lits[0] || "";
}

function loadPersisted(){
  if (!persistEnabled()) return;
  try{
    state.customLabels = new Map(Object.entries(JSON.parse(localStorage.getItem(persistedKey("labels")) || "{}")));
    state.collapsed = new Set(JSON.parse(localStorage.getItem(persistedKey("collapsed")) || "[]"));
    state.nodePositions = new Map(Object.entries(JSON.parse(localStorage.getItem(persistedKey("positions")) || "{}")).map(([k,v]) => [k, v]));
    state.nodeStyles = new Map(Object.entries(JSON.parse(localStorage.getItem(persistedKey("styles")) || "{}")).map(([k,v]) => [k, v]));
  }catch(e){}
}
function savePersisted(){
  if (!persistEnabled()) return;
  try{
    localStorage.setItem(persistedKey("labels"), JSON.stringify(Object.fromEntries(state.customLabels)));
    localStorage.setItem(persistedKey("collapsed"), JSON.stringify([...state.collapsed]));
    localStorage.setItem(persistedKey("positions"), JSON.stringify(Object.fromEntries(state.nodePositions)));
    localStorage.setItem(persistedKey("styles"), JSON.stringify(Object.fromEntries(state.nodeStyles)));
  }catch(e){}
}
function clearPersisted(){
  localStorage.removeItem(persistedKey("labels"));
  localStorage.removeItem(persistedKey("collapsed"));
  localStorage.removeItem(persistedKey("positions"));
  localStorage.removeItem(persistedKey("styles"));
  localStorage.removeItem(persistedKey("dims"));
}

function enableControls(enabled){
  ui.rootSelect.disabled = !enabled;
  ui.layoutSelect.disabled = !enabled;
  ui.edgeCurve.disabled = !enabled;
  ui.edgeWidth.disabled = !enabled;
  ui.edgeColor.disabled = !enabled;
  ui.bgColor.disabled = !enabled;
  ui.btnExportSVG.disabled = !enabled;
  ui.btnExportPNG.disabled = !enabled;
  ui.searchInput.disabled = !enabled;
  ui.btnSearchClear.disabled = !enabled;
  ui.btnSearchShowAll.disabled = !enabled;
}

/* =========================
   ONTOLOGY LOAD & PARSE
========================= */
async function loadOntology(url){
  setStatus("carregando OWL…");
  ui.graphInfo.textContent = "carregando…";
  STORE.statements.length = 0;

  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`Falha HTTP ${res.status} ao buscar OWL`);
  const data = await res.text();

  const base = url;
  let parsed = false;
  try{
    $rdf.parse(data, STORE, base, "application/rdf+xml");
    parsed = true;
  }catch(e1){
    try{
      $rdf.parse(data, STORE, base, "text/turtle");
      parsed = true;
    }catch(e2){
      throw new Error("Não consegui parsear como RDF/XML nem Turtle. Verifique o formato do OWL.");
    }
  }

  state.classNodes = new Map();
  state.subclasses = new Map();
  state.superclasses = new Map();
  state.dimensions = [];
  state.selectedDims = new Set();
  state.selectedIri = null;

  // Classes
  const classSet = new Set();
  STORE.each(null, RDF("type"), OWL("Class")).forEach(s => classSet.add(s.value));
  STORE.each(null, RDF("type"), RDFS("Class")).forEach(s => classSet.add(s.value));
  STORE.each(null, RDFS("subClassOf"), null).forEach(s => classSet.add(s.value));
  STORE.each(null, RDFS("subClassOf"), null).forEach(o => { if (o.termType === "NamedNode") classSet.add(o.value); });

  for (const iri of classSet){
    const s = $rdf.sym(iri);
    const label = getFirstLiteral(s, RDFS("label")) || getFirstLiteral(s, $rdf.sym("http://www.w3.org/2004/02/skos/core#prefLabel"));
    const comment = getLiterals(s, RDFS("comment"));
    state.classNodes.set(iri, { iri, label, comment });
    if (!state.subclasses.has(iri)) state.subclasses.set(iri, new Set());
    if (!state.superclasses.has(iri)) state.superclasses.set(iri, new Set());
  }

  // subClassOf named links
  const subclassTriples = STORE.statementsMatching(null, RDFS("subClassOf"), null);
  for (const st of subclassTriples){
    const child = st.subject;
    const parent = st.object;
    if (child.termType !== "NamedNode") continue;
    const cIri = child.value;
    if (parent.termType === "NamedNode"){
      const pIri = parent.value;
      if (!state.subclasses.has(pIri)) state.subclasses.set(pIri, new Set());
      if (!state.superclasses.has(cIri)) state.superclasses.set(cIri, new Set());
      state.subclasses.get(pIri).add(cIri);
      state.superclasses.get(cIri).add(pIri);
    }
  }

  state.loaded = parsed;

  // Root candidates
  const rootCandidates = [];
  for (const [iri] of state.classNodes){
    const supers = state.superclasses.get(iri) || new Set();
    const namedSupers = [...supers].filter(x => state.classNodes.has(x));
    if (namedSupers.length === 0) rootCandidates.push(iri);
  }
  if (rootCandidates.length < 3){
    const byDegree = [...state.classNodes.keys()].map(iri=>{
      const out = (state.subclasses.get(iri)||new Set()).size;
      const inn = (state.superclasses.get(iri)||new Set()).size;
      return {iri,score: out*3 + inn};
    }).sort((a,b)=>b.score-a.score).slice(0,15).map(d=>d.iri);
    for (const iri of byDegree) if (!rootCandidates.includes(iri)) rootCandidates.push(iri);
  }

  populateRootSelect(rootCandidates);

  setStatus("ontologia carregada", true);
  ui.graphInfo.textContent = `ontologia carregada • classes: ${state.classNodes.size}`;
  enableControls(true);

  buildSearchIndex(); // enable search results
}

/* =========================
   ROOT + DIMENSIONS
========================= */
function populateRootSelect(iris){
  ui.rootSelect.innerHTML = "";
  const sorted = iris
    .map(iri => ({ iri, label: termLabel(iri)}))
    .sort((a,b)=>a.label.localeCompare(b.label, "pt-BR"));
  for (const it of sorted){
    const opt = document.createElement("option");
    opt.value = it.iri;
    opt.textContent = it.label;
    ui.rootSelect.appendChild(opt);
  }
  state.rootIri = ui.rootSelect.value;
  rebuildDimensions();
}

function rebuildDimensions(){
  if (!state.rootIri) return;

  const kids = [...(state.subclasses.get(state.rootIri) || new Set())]
    .filter(iri => state.classNodes.has(iri));

  const dims = kids.map((iri, idx) => ({
    iri,
    label: termLabel(iri),
    color: defaultDimPalette[idx % defaultDimPalette.length]
  })).sort((a,b)=>a.label.localeCompare(b.label,"pt-BR"));

  // restore saved dim colors/selection
  if (persistEnabled()){
    try{
      const saved = JSON.parse(localStorage.getItem(persistedKey("dims")) || "{}");
      for (const d of dims){
        if (saved[d.iri]){
          d.color = saved[d.iri].color || d.color;
        }
      }
      state.selectedDims = new Set(Object.entries(saved).filter(([k,v]) => v.selected).map(([k]) => k));
    }catch(e){
      state.selectedDims = new Set();
    }
  }else{
    state.selectedDims = new Set();
  }

  state.dimensions = dims;
  renderDimsList();
  rebuildAndRender();
}

function saveDimsPersisted(){
  if (!persistEnabled()) return;
  const obj = {};
  for (const d of state.dimensions){
    obj[d.iri] = { color:d.color, selected: state.selectedDims.has(d.iri) };
  }
  localStorage.setItem(persistedKey("dims"), JSON.stringify(obj));
}

function renderDimsList(){
  ui.dimsList.innerHTML = "";
  if (!state.dimensions.length){
    ui.dimsList.innerHTML = `<div class="small">Nenhuma dimensão detectada para esta raiz.</div>`;
    return;
  }
  for (const dim of state.dimensions){
    const row = document.createElement("div");
    row.className = "dimItem";

    const left = document.createElement("div");
    left.className = "dimLeft";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = state.selectedDims.has(dim.iri);
    cb.addEventListener("change", () => {
      if (cb.checked) state.selectedDims.add(dim.iri);
      else state.selectedDims.delete(dim.iri);
      saveDimsPersisted();
      rebuildAndRender();
    });

    const name = document.createElement("div");
    name.className = "dimName";
    name.textContent = dim.label;

    const right = document.createElement("div");
    right.className = "row";

    const color = document.createElement("input");
    color.type = "color";
    color.value = dim.color;
    color.addEventListener("input", () => {
      dim.color = color.value;
      saveDimsPersisted();
      rebuildAndRender();
    });

    left.appendChild(cb);
    left.appendChild(name);
    right.appendChild(color);

    row.appendChild(left);
    row.appendChild(right);

    ui.dimsList.appendChild(row);
  }
}

/* =========================
   BUILD TREE (UNION)
========================= */
function buildUnionTree(){
  const root = state.rootIri;
  const selected = [...state.selectedDims];
  if (!selected.length) return { iri: root, children: [] };
  return { iri: root, children: selected.map(dimIri => buildSubtree(dimIri)) };
}

function buildSubtree(iri){
  const kids = [...(state.subclasses.get(iri) || new Set())].filter(x=>state.classNodes.has(x));
  const isCollapsed = state.collapsed.has(iri);
  return {
    iri,
    children: isCollapsed ? [] : kids.map(k => buildSubtree(k))
  };
}

function flattenNodes(tree){
  const nodes = [];
  const links = [];
  function rec(n, parent=null){
    nodes.push(n);
    if (parent) links.push({source: parent, target: n});
    (n.children || []).forEach(ch => rec(ch, n));
  }
  rec(tree);
  return {nodes, links};
}

/* =========================
   TOOLTIP (ALL PROPS)
========================= */
function tooltipHTML(classIri){
  const s = $rdf.sym(classIri);
  const label = termLabel(classIri);

  const comments = uniq(getLiterals(s, RDFS("comment")));
  const supers = uniq([...(state.superclasses.get(classIri)||new Set())]).map(termLabel).sort();
  const subs = uniq([...(state.subclasses.get(classIri)||new Set())]).map(termLabel).sort();

  const equiv = STORE.each(s, OWL("equivalentClass"), null)
    .filter(o=>o.termType==="NamedNode").map(o=>termLabel(o.value));
  const disj = STORE.each(s, OWL("disjointWith"), null)
    .filter(o=>o.termType==="NamedNode").map(o=>termLabel(o.value));

  const objProps = STORE.each(null, RDF("type"), OWL("ObjectProperty")).map(x=>x.value);
  const dtProps  = STORE.each(null, RDF("type"), OWL("DatatypeProperty")).map(x=>x.value);

  const asDomainObj = [];
  const asRangeObj  = [];
  const asDomainDt  = [];
  const asRangeDt   = [];

  for (const pIri of objProps){
    const p = $rdf.sym(pIri);
    const domains = STORE.each(p, RDFS("domain"), null).filter(x=>x.termType==="NamedNode").map(x=>x.value);
    const ranges  = STORE.each(p, RDFS("range"), null).filter(x=>x.termType==="NamedNode").map(x=>x.value);
    if (domains.includes(classIri)) asDomainObj.push(pIri);
    if (ranges.includes(classIri))  asRangeObj.push(pIri);
  }
  for (const pIri of dtProps){
    const p = $rdf.sym(pIri);
    const domains = STORE.each(p, RDFS("domain"), null).filter(x=>x.termType==="NamedNode").map(x=>x.value);
    const ranges  = STORE.each(p, RDFS("range"), null).map(x=>x.value);
    if (domains.includes(classIri)) asDomainDt.push(pIri);
    if (ranges.includes(classIri))  asRangeDt.push(pIri);
  }

  function propLine(pIri){
    const p = $rdf.sym(pIri);
    const plabel = getFirstLiteral(p, RDFS("label")) || shrinkIri(pIri);
    return `${escapeHTML(plabel)} <span class="tMeta">(${escapeHTML(shrinkIri(pIri))})</span>`;
  }

  // OWL restrictions (blank nodes) inside subClassOf
  const restrictions = [];
  const subClassOfObjs = STORE.each(s, RDFS("subClassOf"), null);
  for (const o of subClassOfObjs){
    if (o.termType !== "BlankNode") continue;
    const bn = o;
    const onProp = STORE.any(bn, OWL("onProperty"), null);
    const some = STORE.any(bn, OWL("someValuesFrom"), null);
    const all  = STORE.any(bn, OWL("allValuesFrom"), null);
    const hasV = STORE.any(bn, OWL("hasValue"), null);
    if (!onProp) continue;

    const pIri = onProp.value;
    const pName = getFirstLiteral($rdf.sym(pIri), RDFS("label")) || shrinkIri(pIri);

    let rhs = "";
    if (some && some.termType === "NamedNode") rhs = `some ${termLabel(some.value)}`;
    else if (all && all.termType === "NamedNode") rhs = `only ${termLabel(all.value)}`;
    else if (hasV) rhs = `value ${hasV.value}`;
    else rhs = "(restrição)";

    restrictions.push(`${pName}: ${rhs}`);
  }

  const parts = [];
  parts.push(`<div class="tTitle">${escapeHTML(label)}</div>`);
  parts.push(`<div class="tMeta">${escapeHTML(classIri)}</div>`);

  const section = (title, items) => {
    if (!items || !items.length) return;
    parts.push(`<hr/>`);
    parts.push(`<div><b>${escapeHTML(title)}</b></div>`);
    parts.push(items.slice(0, 18).map(it => `<div>• ${it}</div>`).join(""));
    if (items.length > 18) parts.push(`<div class="tMeta">(+ ${items.length-18} itens)</div>`);
  };

  if (comments.length){
    parts.push(`<hr/><div><b>Comentário</b></div>`);
    parts.push(comments.slice(0,3).map(c=>`<div>${escapeHTML(c)}</div>`).join(""));
    if (comments.length > 3) parts.push(`<div class="tMeta">(+ ${comments.length-3} comentários)</div>`);
  }

  section("Superclasses", supers.map(x=>escapeHTML(x)));
  section("Subclasses (diretas)", subs.map(x=>escapeHTML(x)));
  section("EquivalentClass", equiv.map(x=>escapeHTML(x)));
  section("DisjointWith", disj.map(x=>escapeHTML(x)));
  section("Restrições OWL (subClassOf)", restrictions.map(x=>escapeHTML(x)));

  section("ObjectProperties (Domain)", asDomainObj.map(propLine));
  section("ObjectProperties (Range)", asRangeObj.map(propLine));
  section("DatatypeProperties (Domain)", asDomainDt.map(propLine));
  section("DatatypeProperties (Range)", asRangeDt.map(propLine));

  return parts.join("");
}

function escapeHTML(s){
  return String(s)
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}

/* =========================
   RENDER
========================= */
function layoutKey(){ return ui.layoutSelect.value || "topdown"; }

function resize(){
  const r = wrap.getBoundingClientRect();
  width = r.width; height = r.height;
  svg.attr("viewBox", `0 0 ${width} ${height}`);
}
window.addEventListener("resize", () => { resize(); if (state.loaded) rebuildAndRender(); });

function linkPath(a, b, c){
  const x1 = a.x, y1 = a.y;
  const x2 = b.x, y2 = b.y;
  const cx1 = x1 + (x2 - x1) * c;
  const cy1 = y1 + (y2 - y1) * (1 - c);
  const cx2 = x1 + (x2 - x1) * (1 - c);
  const cy2 = y1 + (y2 - y1) * c;
  return `M${x1},${y1} C${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`;
}

function rebuildAndRender(){
  const tree = buildUnionTree();
  const flat = flattenNodes(tree);
  ui.nodeCount.textContent = flat.nodes.length;
  ui.edgeCount.textContent = flat.links.length;

  // Build dim color map (DFS from selected dims)
  const dimMap = new Map();
  for (const dim of state.dimensions){
    if (!state.selectedDims.has(dim.iri)) continue;
    (function dfs(i){
      if (dimMap.has(i)) return;
      dimMap.set(i, dim.color);
      const kids = state.subclasses.get(i) || new Set();
      for (const k of kids){
        if (!state.classNodes.has(k)) continue;
        dfs(k);
      }
    })(dim.iri);
  }
  dimMap.set(state.rootIri, "#64748b");

  resize();

  const root = d3.hierarchy(tree, d => d.children);
  const padTop = 30;

  let baseW = 180, baseH = 36, dx = 62, dy = 240;
  if (layoutKey() === "a4"){ baseW=200; baseH=34; dx=56; dy=270; }

  let centerX = width/2, centerY = (height+padTop)/2;

  if (layoutKey() === "radial"){
    const layout = d3.tree().size([2*Math.PI, Math.min(width, height)/2 - 90]);
    layout(root);
    root.descendants().forEach(d => {
      const r = d.y;
      const a = d.x;
      d.x = centerX + r * Math.cos(a - Math.PI/2);
      d.y = centerY + r * Math.sin(a - Math.PI/2);
    });
  } else if (layoutKey() === "leftright"){
    const layout = d3.tree().nodeSize([dx, dy]);
    layout(root);
    root.descendants().forEach(d => { d.x = (height/2) + d.x; d.y = padTop + d.y; });
  } else {
    const layout = d3.tree().nodeSize([dx, dy]);
    layout(root);
    root.descendants().forEach(d => { d.x = centerX + d.x; d.y = padTop + d.y; });
  }

  // Apply persisted/manual positions
  const lk = layoutKey();
  root.descendants().forEach(d => {
    const k = `${lk}|${d.data.iri}`;
    if (state.nodePositions.has(k)){
      const p = state.nodePositions.get(k);
      d.x = p.x; d.y = p.y;
    }
  });

  // Links
  const curve = +ui.edgeCurve.value / 100;
  const strokeW = +ui.edgeWidth.value;
  const edgeCol = ui.edgeColor.value;

  const linkSel = gLinks.selectAll("path.link")
    .data(root.links(), d => d.target.data.iri);

  linkSel.exit().remove();

  linkSel.enter()
    .append("path")
    .attr("class","link")
    .merge(linkSel)
    .attr("stroke", edgeCol)
    .attr("stroke-width", strokeW)
    .attr("d", d => linkPath(d.source, d.target, curve));

  // Nodes
  const nodeSel = gNodes.selectAll("g.node")
    .data(root.descendants(), d => d.data.iri);

  nodeSel.exit().remove();

  const nodeEnter = nodeSel.enter()
    .append("g")
    .attr("class","node")
    .style("cursor","pointer")
    .on("mousemove", (event, d) => showTooltip(event, d.data.iri))
    .on("mouseleave", hideTooltip)
    .on("click", (event, d) => {
      event.stopPropagation();
      const iri = d.data.iri;
      if (event.altKey){
        toggleCollapse(iri);
      }else{
        selectNode(iri);
      }
    })
    .call(d3.drag()
      .on("start", (event) => event.sourceEvent?.stopPropagation())
      .on("drag", (event, d) => {
        d.x = event.x; d.y = event.y;
        const k = `${layoutKey()}|${d.data.iri}`;
        state.nodePositions.set(k, {x:d.x, y:d.y});
        savePersisted();
        gNodes.selectAll("g.node")
          .filter(n => n.data.iri === d.data.iri)
          .attr("transform", `translate(${d.x},${d.y})`);
        gLinks.selectAll("path.link")
          .attr("d", l => linkPath(l.source, l.target, curve));
      })
    );

  nodeEnter.append("rect");
  nodeEnter.append("text")
    .attr("text-anchor","middle")
    .attr("dominant-baseline","middle");

  const nodeMerge = nodeEnter.merge(nodeSel)
    .attr("transform", d => `translate(${d.x},${d.y})`)
    .classed("selected", d => d.data.iri === state.selectedIri);

  nodeMerge.select("rect")
    .each(function(d){
      const iri = d.data.iri;
      const style = state.nodeStyles.get(iri) || {};
      const t = termLabel(iri);

      const w = style.w ?? (baseW + Math.min(240, Math.max(0, (t.length - 18) * 6)));
      const h = style.h ?? baseH;
      const r = style.radius ?? 10;

      d3.select(this)
        .attr("width", w)
        .attr("height", h)
        .attr("x", -w/2)
        .attr("y", -h/2)
        .attr("rx", r)
        .attr("ry", r)
        .attr("fill", style.fill ?? (dimMap.get(iri) || "#64748b"))
        .attr("opacity", (iri === state.rootIri) ? 0.45 : ((style.opacity ?? 92)/100))
        .attr("stroke", style.stroke ?? "rgba(0,0,0,0.35)")
        .attr("stroke-width", (iri === state.selectedIri) ? 2.2 : 1.0);
    });

  nodeMerge.select("text")
    .each(function(d){
      const iri = d.data.iri;
      const style = state.nodeStyles.get(iri) || {};
      const font = style.font ?? 12;
      const s = termLabel(iri);
      const maxChars = 30;

      const text = d3.select(this).style("font-size", font + "px");
      if (s.length <= maxChars){
        text.text(s);
        return;
      }
      const line1 = s.slice(0, maxChars).trim();
      const line2 = s.slice(maxChars, maxChars*2).trim();
      text.text(null);
      text.append("tspan").attr("x",0).attr("dy","-0.2em").text(line1 + "…");
      text.append("tspan").attr("x",0).attr("dy","1.2em").text(line2 ? line2 + (s.length > maxChars*2 ? "…" : "") : "");
    });

  document.body.style.background = ui.bgColor.value;

  // keep selection info updated
  ui.selInfo.textContent = state.selectedIri ? termLabel(state.selectedIri) : "—";

  if (!rebuildAndRender._didFit){
    fitToView();
    rebuildAndRender._didFit = true;
  }
}

/* =========================
   TOOLTIP
========================= */
function showTooltip(evt, iri){
  ui.tooltip.style.display = "block";
  ui.tooltip.innerHTML = tooltipHTML(iri);

  const pad = 14;
  const rect = wrap.getBoundingClientRect();
  const x = evt.clientX - rect.left + pad;
  const y = evt.clientY - rect.top + pad;

  ui.tooltip.style.left = x + "px";
  ui.tooltip.style.top = y + "px";
}
function hideTooltip(){ ui.tooltip.style.display = "none"; }

/* =========================
   COLLAPSE / SELECT / EDITOR
========================= */
function toggleCollapse(iri){
  if (state.collapsed.has(iri)) state.collapsed.delete(iri);
  else state.collapsed.add(iri);
  savePersisted();
  rebuildAndRender();
}

function selectNode(iri){
  state.selectedIri = iri;
  ui.selInfo.textContent = termLabel(iri);
  openEditorFor(iri);
  rebuildAndRender();
}

function openEditorFor(iri){
  ui.editorCard.style.opacity = "1";
  ui.editorHint.textContent = shrinkIri(iri);

  // enable controls
  ui.edLabel.disabled = false;
  ui.edFill.disabled = false;
  ui.edStroke.disabled = false;
  ui.edOpacity.disabled = false;
  ui.edW.disabled = false;
  ui.edH.disabled = false;
  ui.edFont.disabled = false;
  ui.edRadius.disabled = false;
  ui.btnEditorApply.disabled = false;
  ui.btnEditorReset.disabled = false;

  const style = state.nodeStyles.get(iri) || {};
  ui.edLabel.value = state.customLabels.get(iri) || (state.classNodes.get(iri)?.label || shrinkIri(iri));
  ui.edFill.value = style.fill || "#64748b";
  ui.edStroke.value = style.stroke ? normalizeColor(style.stroke) : "#111827";
  ui.edOpacity.value = style.opacity ?? 92;
  ui.edW.value = style.w ?? 180;
  ui.edH.value = style.h ?? 36;
  ui.edFont.value = style.font ?? 12;
  ui.edRadius.value = style.radius ?? 10;
}

function normalizeColor(val){
  // accept rgba(...) or hex, best-effort convert to hex-like fallback
  if (typeof val !== "string") return "#111827";
  if (val.startsWith("#") && (val.length===7 || val.length===4)) return val;
  return "#111827";
}

ui.btnEditorApply.addEventListener("click", () => {
  const iri = state.selectedIri;
  if (!iri) return;

  const newLabel = ui.edLabel.value.trim();
  if (newLabel) state.customLabels.set(iri, newLabel);
  else state.customLabels.delete(iri);

  const style = {
    fill: ui.edFill.value,
    stroke: ui.edStroke.value,
    opacity: +ui.edOpacity.value,
    w: +ui.edW.value,
    h: +ui.edH.value,
    font: +ui.edFont.value,
    radius: +ui.edRadius.value
  };
  state.nodeStyles.set(iri, style);

  savePersisted();
  rebuildAndRender();
});

ui.btnEditorReset.addEventListener("click", () => {
  const iri = state.selectedIri;
  if (!iri) return;

  state.customLabels.delete(iri);
  state.nodeStyles.delete(iri);
  savePersisted();
  openEditorFor(iri);
  rebuildAndRender();
});

/* =========================
   FIT / RESET
========================= */
function fitToView(){
  const nodes = gNodes.selectAll("g.node").nodes();
  if (!nodes.length) return;

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  nodes.forEach(n=>{
    const box = n.getBBox();
    const tr = n.getCTM();
    const x = tr.e + box.x, y = tr.f + box.y;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + box.width);
    maxY = Math.max(maxY, y + box.height);
  });

  const w = maxX - minX;
  const h = maxY - minY;
  if (!isFinite(w) || !isFinite(h) || w<=0 || h<=0) return;

  const scale = Math.min(0.95, Math.max(0.2, Math.min(width / (w+100), height / (h+100))));
  const tx = (width/2) - scale * (minX + w/2);
  const ty = (height/2) - scale * (minY + h/2);

  svg.transition().duration(350).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

function resetAll(){
  clearPersisted();
  state.customLabels.clear();
  state.collapsed.clear();
  state.nodePositions.clear();
  state.nodeStyles.clear();
  state.selectedIri = null;
  ui.selInfo.textContent = "—";
  ui.editorCard.style.opacity = "0.55";
  ui.editorHint.textContent = "Selecione um nó no gráfico para editar.";
  rebuildAndRender._didFit = false;
  rebuildDimensions();
  rebuildAndRender();
}

/* =========================
   SEARCH
========================= */
let searchIndex = []; // [{iri, label, iriShort}]
function buildSearchIndex(){
  searchIndex = [...state.classNodes.keys()].map(iri => ({
    iri,
    label: termLabel(iri),
    iriShort: shrinkIri(iri)
  })).sort((a,b)=>a.label.localeCompare(b.label, "pt-BR"));
}

function renderSearchResults(items){
  const box = ui.searchResults;
  box.innerHTML = "";
  if (!items.length){
    box.innerHTML = `<div class="searchItem"><div class="small">Nenhum resultado</div></div>`;
    box.style.display = "block";
    return;
  }
  for (const it of items.slice(0, 30)){
    const row = document.createElement("div");
    row.className = "searchItem";
    row.innerHTML = `<div>${escapeHTML(it.label)}</div><div class="tag">${escapeHTML(it.iriShort)}</div>`;
    row.addEventListener("click", () => {
      selectNode(it.iri);
      zoomToNode(it.iri);
    });
    box.appendChild(row);
  }
  if (items.length > 30){
    const more = document.createElement("div");
    more.className = "searchItem";
    more.innerHTML = `<div class="small">(+ ${items.length-30} resultados)</div><div class="tag">refine a busca</div>`;
    box.appendChild(more);
  }
  box.style.display = "block";
}

function zoomToNode(iri){
  // find node DOM
  const node = gNodes.selectAll("g.node").filter(d => d.data.iri === iri).node();
  if (!node){
    // node not in current view (dimensões não selecionadas). Mesmo assim, selecionar ajuda.
    return;
  }
  const box = node.getBBox();
  const tr = node.getCTM();
  const x = tr.e + box.x + box.width/2;
  const y = tr.f + box.y + box.height/2;

  const scale = Math.max(0.7, Math.min(2.2, d3.zoomTransform(svg.node()).k));
  const tx = (width/2) - scale * x;
  const ty = (height/2) - scale * y;

  svg.transition().duration(350).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

ui.searchInput.addEventListener("input", () => {
  const q = ui.searchInput.value.trim().toLowerCase();
  if (!q){
    ui.searchResults.style.display = "none";
    return;
  }
  const hits = searchIndex.filter(it =>
    it.label.toLowerCase().includes(q) || it.iriShort.toLowerCase().includes(q)
  );
  renderSearchResults(hits);
});

ui.btnSearchClear.addEventListener("click", () => {
  ui.searchInput.value = "";
  ui.searchResults.style.display = "none";
});

ui.btnSearchShowAll.addEventListener("click", () => {
  renderSearchResults(searchIndex);
});

/* =========================
   EXPORT SVG / PNG
========================= */
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function exportSVG(){
  // clone SVG and inline basic styles
  const svgNode = svg.node().cloneNode(true);

  // ensure viewBox exists
  svgNode.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  svgNode.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");

  // add a background rect
  const vb = svgNode.getAttribute("viewBox") || `0 0 ${width} ${height}`;
  const [x,y,w,h] = vb.split(" ").map(Number);
  const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  bg.setAttribute("x", x); bg.setAttribute("y", y);
  bg.setAttribute("width", w); bg.setAttribute("height", h);
  bg.setAttribute("fill", ui.bgColor.value);
  svgNode.insertBefore(bg, svgNode.firstChild);

  const serializer = new XMLSerializer();
  const text = serializer.serializeToString(svgNode);
  const blob = new Blob([text], {type:"image/svg+xml;charset=utf-8"});
  downloadBlob(blob, `ontohate_taxonomy_${layoutKey()}.svg`);
}

function exportPNG(){
  // render SVG -> canvas -> PNG
  const serializer = new XMLSerializer();
  const vb = svg.attr("viewBox");
  const [vx, vy, vw, vh] = vb.split(" ").map(Number);

  const cloned = svg.node().cloneNode(true);
  cloned.setAttribute("xmlns", "http://www.w3.org/2000/svg");

  // background
  const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  bg.setAttribute("x", vx); bg.setAttribute("y", vy);
  bg.setAttribute("width", vw); bg.setAttribute("height", vh);
  bg.setAttribute("fill", ui.bgColor.value);
  cloned.insertBefore(bg, cloned.firstChild);

  const svgText = serializer.serializeToString(cloned);
  const svgBlob = new Blob([svgText], {type:"image/svg+xml;charset=utf-8"});
  const url = URL.createObjectURL(svgBlob);

  const img = new Image();
  img.onload = () => {
    const canvas = document.createElement("canvas");

    // Increase resolution for article: 2x
    const scale = 2;
    canvas.width = Math.floor(vw * scale);
    canvas.height = Math.floor(vh * scale);

    const ctx = canvas.getContext("2d");
    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    ctx.drawImage(img, 0, 0);

    canvas.toBlob((pngBlob) => {
      downloadBlob(pngBlob, `ontohate_taxonomy_${layoutKey()}.png`);
      URL.revokeObjectURL(url);
    }, "image/png");
  };
  img.onerror = () => {
    URL.revokeObjectURL(url);
    alert("Falha ao exportar PNG. Tente exportar SVG (sempre funciona) e converter externamente.");
  };
  img.src = url;
}

/* =========================
   UI EVENTS
========================= */
ui.btnLoad.addEventListener("click", async () => {
  try{
    loadPersisted();
    await loadOntology(ui.owlUrl.value.trim());
    rebuildDimensions();
    rebuildAndRender();
  }catch(e){
    setStatus("erro ao carregar", false);
    ui.graphInfo.textContent = "erro";
    alert(e.message || String(e));
  }
});

ui.rootSelect.addEventListener("change", () => {
  state.rootIri = ui.rootSelect.value;
  rebuildDimensions();
});

ui.btnAll.addEventListener("click", () => {
  state.dimensions.forEach(d => state.selectedDims.add(d.iri));
  saveDimsPersisted();
  renderDimsList();
  rebuildAndRender();
});

ui.btnNone.addEventListener("click", () => {
  state.selectedDims.clear();
  saveDimsPersisted();
  renderDimsList();
  rebuildAndRender();
});

ui.layoutSelect.addEventListener("change", () => rebuildAndRender());
ui.edgeCurve.addEventListener("input", () => rebuildAndRender());
ui.edgeWidth.addEventListener("input", () => rebuildAndRender());
ui.edgeColor.addEventListener("input", () => rebuildAndRender());
ui.bgColor.addEventListener("input", () => rebuildAndRender());
ui.btnFit.addEventListener("click", fitToView);
ui.btnReset.addEventListener("click", resetAll);

ui.btnExportSVG.addEventListener("click", exportSVG);
ui.btnExportPNG.addEventListener("click", exportPNG);

ui.persistSelect.addEventListener("change", () => {
  if (!persistEnabled()){
    clearPersisted();
  }else{
    savePersisted();
  }
});

/* =========================
   INIT
========================= */
resize();
enableControls(false);

// Pre-fill with your repo RAW OWL:
ui.owlUrl.value = "https://raw.githubusercontent.com/luquizis/Ontohate/main/ontohate_.owl";

svg.on("click", () => {
  // click background unselect
  state.selectedIri = null;
  ui.selInfo.textContent = "—";
  ui.editorCard.style.opacity = "0.55";
  ui.editorHint.textContent = "Selecione um nó no gráfico para editar.";
  rebuildAndRender();
  hideTooltip();
});
</script>
</body>
</html>
